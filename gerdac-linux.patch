diff -uNr linux-3.14.19/KMC/Kconfig_kmc linux-gerda/KMC/Kconfig_kmc
--- linux-3.14.19/KMC/Kconfig_kmc	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/Kconfig_kmc	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,80 @@
+#
+# PARTNER-Jet Linux support patch by KMC
+#
+# Ver2.0	08.04.14
+# Ver2.01	08.07.22	depends keyword "on"
+#
+
+menu 'PARTNER Debugging'
+
+config KMC_PATCH
+    bool "Enable patch for PARTNER debug"
+    default n
+    select DEBUG_INFO
+
+config KMC_DEBUG_ON_QEMU
+    bool "kernel running on qemu simulator (ARM only)"
+    default n
+    depends on KMC_PATCH && ARM
+
+config KMC_DEBUG_FOR_ANDROID
+    bool "debug mode for android"
+    default n
+    depends on KMC_PATCH
+    select KMC_NO_USER_PATCH
+
+config KMC_MODULE_DEBUG
+    bool "Loadable module debug by PARTNER-Jet"
+    default n
+    depends on KMC_PATCH && MODULES
+
+config KMC_NO_USER_PATCH
+    bool "include userland debug patch"
+    default n
+    depends on KMC_PATCH
+
+config KMC_NOTIFY_UPDATE_CONTEXTID
+    bool "Enable H/W breakpoints for user space processes"
+    default n
+    depends on KMC_PATCH && ARM
+
+config KMC_USE_BT
+    bool "use PARTNER GigaTrace(PARTNER-Jet M40, ...)"
+    default n
+    depends on KMC_PATCH
+
+config KMC_EVENTTRACKER_SUPPORT
+    bool "enable PARNTER-Jet Event Tracker"
+    default n
+    depends on KMC_PATCH
+
+config KMC_EVT_USE_ARM_GLOBAL_TIMER
+    bool "use ARM Cortex-A9 MPCore Global Timer"
+    default n
+    depends on KMC_EVENTTRACKER_SUPPORT && ARM
+
+config KMC_EVENTTRACKER_RTM
+    bool "event data is only from CPU's trace"
+    default n
+    depends on KMC_EVENTTRACKER_SUPPORT && KMC_USE_BT
+
+config KMC_EVENTTRACKER_LOG_SIZE
+    int "max event count (x1024, set is 1, 2, 4, 8, 16, 32, 64, .....)"
+    depends on KMC_EVENTTRACKER_SUPPORT && !KMC_EVENTTRACKER_RTM
+    default 4
+
+config KMC_EVENTTRACKER_PNAME_SIZE
+    int "max process&thread name count(x256, set 2^n(1,2,4,8,16,32,64,....))"
+    depends on KMC_EVENTTRACKER_SUPPORT
+    default 4
+
+    menu 'PARTNER Extend menu'
+        depends on KMC_PATCH
+
+        config KMC_PARTNER_COLLECT_THREAD_OFF
+        bool "OFF:PARTNER THREAD COLLECTING"
+        default n
+
+    endmenu
+
+endmenu
diff -uNr linux-3.14.19/KMC/Makefile linux-gerda/KMC/Makefile
--- linux-3.14.19/KMC/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/Makefile	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,21 @@
+#
+# Makefile for KMC debugger support code
+#
+
+ifeq ($(CONFIG_KMC_PATCH),y)
+obj-y					+= kmc.o
+
+ifeq ($(CONFIG_KMC_MODULE_DEBUG),y)
+obj-y					+= kmc-mod.o
+endif
+
+ifeq ($(CONFIG_KMC_NO_USER_PATCH),y)
+obj-y					+= kmc-support.o
+endif
+
+ifeq ($(CONFIG_KMC_EVENTTRACKER_SUPPORT),y)
+obj-y					+= kmc-evtr.o
+endif
+
+endif
+
diff -uNr linux-3.14.19/KMC/__brk_code.h linux-gerda/KMC/__brk_code.h
--- linux-3.14.19/KMC/__brk_code.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/__brk_code.h	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,47 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * A definition of S/W break-point instruction
+ *
+ * Ver3.0	12.06.10
+ *
+ */
+
+#ifndef __BRK_CODE_H__
+#define __BRK_CODE_H__
+
+
+#ifdef CONFIG_ARM
+ #if defined(CONFIG_CPU_V6) || defined(CONFIG_CPU_V7) || defined(CONFIG_KMC_DEBUG_ON_QEMU)
+  #define	__KMC_BRK_CODE()	asm("	.long	0xe1200070")
+ #else
+  #define	__KMC_BRK_CODE()	asm("	.long	0xdeeedeee")
+ #endif
+#endif
+
+#ifdef CONFIG_MIPS
+ #if defined(CONFIG_CPU_TX49XX)
+  #define	__KMC_BRK_CODE()	asm("	.long	0x0000000e")
+ #else
+  #define	__KMC_BRK_CODE()	asm("	.long	0x7000003f")
+ #endif
+#endif
+
+#ifdef CONFIG_CPU_SH4
+ #define	__KMC_BRK_CODE()					\
+					asm("	.align 2");		\
+					asm("	.long	0x003b003b")
+#endif
+#ifdef CONFIG_CPU_SH3
+ #define	__KMC_BRK_CODE()	asm("	.long	0x00000000")
+#endif
+
+#ifdef CONFIG_MN10300
+ #define	__KMC_BRK_CODE()	asm("	.long	0xffffffff")
+#endif
+
+#ifndef __KMC_BRK_CODE
+ #error	!! __KMC_BRK_CODE is not defined !!
+#endif
+
+#endif
diff -uNr linux-3.14.19/KMC/kmc-evtr.c linux-gerda/KMC/kmc-evtr.c
--- linux-3.14.19/KMC/kmc-evtr.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc-evtr.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,340 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mman.h>
+#include <linux/kmc.h>
+#include <linux/module.h>
+#include <linux/vmalloc.h>
+#include <linux/printk.h>
+#include <linux/io.h>
+#include <asm/io.h>
+#include <asm/delay.h>
+
+#include "kmc-evtr.h"
+
+#define KMC_LINUX_EVENTLOG_VERSION	(0x00000003)
+
+
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+#define	KMC_LINUX_EVENTLOG_MAXLOG	0
+#else
+#define KMC_LINUX_EVENTLOG_MAXLOG	(CONFIG_KMC_EVENTTRACKER_LOG_SIZE * 1024)	// must be 2^n
+#endif
+#define KMC_LINUX_EVENTLOG_MAXPNAME	(CONFIG_KMC_EVENTTRACKER_PNAME_SIZE * 256)	// must be 2^n
+#define KMC_LINUX_EVENTLOG_MAXPNAMELENGTH	(32)
+#define	KMC_LINUX_EVENTLOG_MAXTHREADINFO	(1024)	// must be 2^n
+
+typedef struct {
+	u64 evtTime;
+	int evtId;
+	int evtPid;
+	int evtParam;
+#ifdef CONFIG_SMP
+	int cpuId;
+#endif
+} T_KMC_LINUX_EVENTLOG;
+
+typedef struct {
+	int	pid;
+	char	name[KMC_LINUX_EVENTLOG_MAXPNAMELENGTH];
+} T_KMC_LINUX_PNAME;
+
+typedef struct {
+	unsigned short	thid;
+	unsigned short	pid;
+} T_KMC_LINUX_THINFO;
+
+typedef struct {
+	int	version;
+	int	ticks_per_10msec;
+
+	/* EventLog Info. */
+	int	log_offset;
+	int	log_max;
+	int	log_size;
+	int	log_index;
+
+	/* Process Name Table */
+	int	pname_offset;
+	int	pname_max;
+	int	pname_size;
+	int	pname_index;
+
+	/* Thread Info Table */
+	int	thinfo_offset;
+	int	thinfo_max;
+	int	thinfo_size;
+	int	thinfo_index;
+
+	/* EventLog */
+	T_KMC_LINUX_EVENTLOG	log[KMC_LINUX_EVENTLOG_MAXLOG];
+
+	/* Process Name Table */
+	T_KMC_LINUX_PNAME	pname[KMC_LINUX_EVENTLOG_MAXPNAME];
+
+	/* Thread Info Table */
+	T_KMC_LINUX_THINFO	thinfo[KMC_LINUX_EVENTLOG_MAXTHREADINFO];
+
+#ifdef CONFIG_KMC_EVENTTRACKER_THNAME
+	/* Thread Name Table */
+	T_KMC_LINUX_THNAME	thname[KMC_LINUX_EVENTLOG_MAXTHNAME];
+#endif
+} T_KMC_LINUX_LOGAREA;
+
+static spinlock_t __kmc_linux_event_lock = __SPIN_LOCK_UNLOCKED(__kmc_linux_event_lock);
+
+T_KMC_LINUX_LOGAREA	*__kmc_linux_event_data = NULL;
+unsigned long		__kmc_linux_event_data_size = sizeof(T_KMC_LINUX_LOGAREA);
+int __kmc_linux_event_errcount;
+
+#ifdef CONFIG_KMC_EVT_USE_ARM_GLOBAL_TIMER
+static void __iomem *arm_a9_timer_base = 0;
+#define	GLOBAL_TIMER_COUNTER_LOW	0x0
+#define	GLOBAL_TIMER_COUNTER_HIGH	0x4
+#define	GLOBAL_TIMER_CONTROL		0x8
+
+static inline unsigned long armv7_read_configbase(void)
+{
+	u32	val;
+	asm volatile("mrc p15, 4, %0, c15, c0, 0" : "=r"(val));
+	return val;
+}
+
+static unsigned long __init_arm_global_timer(void)
+{
+	unsigned long	tmL1, tmL2, tmH1, tmH2, ctl, ticks_per_10msec;
+	unsigned long	arm_a9_timer_base_phy;
+
+	arm_a9_timer_base_phy = armv7_read_configbase();
+	if (0 != arm_a9_timer_base_phy) {
+		arm_a9_timer_base = ioremap_nocache(arm_a9_timer_base_phy + 0x200, 0x100);
+	} else {
+		arm_a9_timer_base = 0;
+	}
+
+	if (arm_a9_timer_base) {
+		ctl = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_CONTROL);
+		if (0 == (ctl & 1)) {
+			__raw_writel(ctl | 1, arm_a9_timer_base + GLOBAL_TIMER_CONTROL);
+		}
+		tmH1 = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_HIGH);
+		tmL1 = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_LOW);
+		udelay(100);
+		tmL2 = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_LOW);
+		tmH2 = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_HIGH);
+		if (tmH2 != tmH1) {
+			unsigned long tmH = tmH2 - tmH1;
+			ticks_per_10msec = tmL2 + (0xffffffff - tmL1) + (0xffffffff * (tmH - 1));
+			ticks_per_10msec = ticks_per_10msec * 100;
+		} else {
+			ticks_per_10msec = (tmL2- tmL1) * 100;
+		}
+		printk(KERN_INFO "KMC: EventTracker, ARM global timer enable, addr=0x%pK, ticks/10ms=%lu(0x%lx)\n", arm_a9_timer_base, ticks_per_10msec, ticks_per_10msec);
+	} else {
+#ifdef CONFIG_HZ
+		ticks_per_10msec = CONFIG_HZ / 100;
+#else
+		ticks_per_10msec = 10;
+#endif
+	}
+
+	return ticks_per_10msec;
+}
+
+static inline u64 __get_arm_global_timer(void)
+{
+	u64	evtTime;
+
+	if (arm_a9_timer_base) {
+		evtTime = __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_HIGH);
+		evtTime = evtTime << 32;
+		evtTime = evtTime | __raw_readl(arm_a9_timer_base + GLOBAL_TIMER_COUNTER_LOW);
+	} else {
+		evtTime = jiffies_64;
+	}
+
+	return evtTime;
+}
+#endif
+
+void __kmc_linux_event_log_init(void)
+{
+#ifdef CONFIG_SMP
+	unsigned long flags;
+	spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+	if (!__kmc_linux_event_data) {
+#endif
+
+#if defined(CONFIG_CPU_SUBTYPE_SH7757)
+	__kmc_linux_event_data = kmalloc(sizeof(T_KMC_LINUX_LOGAREA), GFP_ATOMIC);
+#else
+	__kmc_linux_event_data = vmalloc(sizeof(T_KMC_LINUX_LOGAREA));
+#endif
+	if (__kmc_linux_event_data) {
+		memset(__kmc_linux_event_data, 0, sizeof(T_KMC_LINUX_LOGAREA));
+		__kmc_linux_event_data->version = KMC_LINUX_EVENTLOG_VERSION;
+#if defined CONFIG_KMC_EVT_USE_ARM_GLOBAL_TIMER
+		__kmc_linux_event_data->ticks_per_10msec = __init_arm_global_timer();
+#elif defined CONFIG_MACH_MX3KZ
+		__kmc_linux_event_data->ticks_per_10msec = 105472;		/* LATCH */
+#else
+#ifdef CONFIG_HZ
+		__kmc_linux_event_data->ticks_per_10msec = CONFIG_HZ / 100;	/* jiffies */
+#else
+		__kmc_linux_event_data->ticks_per_10msec = 10;			/* jiffies */
+#endif
+#endif
+		__kmc_linux_event_data->log_offset 	= (int)&__kmc_linux_event_data->log[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->log_max		= KMC_LINUX_EVENTLOG_MAXLOG;
+		__kmc_linux_event_data->log_size	= (int)&__kmc_linux_event_data->log[1] - (int)&__kmc_linux_event_data->log[0];
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+		__kmc_linux_event_data->log_index	= 1;
+#endif
+		__kmc_linux_event_data->pname_offset	= (int)&__kmc_linux_event_data->pname[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->pname_max	= KMC_LINUX_EVENTLOG_MAXPNAME;
+		__kmc_linux_event_data->pname_size	= (int)&__kmc_linux_event_data->pname[1] - (int)&__kmc_linux_event_data->pname[0];
+
+		__kmc_linux_event_data->thinfo_offset	= (int)&__kmc_linux_event_data->thinfo[0] - (int)&__kmc_linux_event_data->version;
+		__kmc_linux_event_data->thinfo_max	= KMC_LINUX_EVENTLOG_MAXTHREADINFO;
+		__kmc_linux_event_data->thinfo_size	= (int)&__kmc_linux_event_data->thinfo[1] - (int)&__kmc_linux_event_data->thinfo[0];
+	}
+
+#ifdef CONFIG_SMP
+	}
+	spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+#endif
+
+	return;
+}
+
+#ifdef CONFIG_KMC_EVENTTRACKER_RTM
+void __kmc_linux_event_set_logI(int evtid, int pid, int param)
+{
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if ((__kmc_linux_event_data)&&(evtid == KMC_LINUX_EVENTID_NEWTHREAD)) {
+		unsigned long flags;
+		int thindex;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+		thindex = (__kmc_linux_event_data->thinfo_index++) & (KMC_LINUX_EVENTLOG_MAXTHREADINFO - 1);
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+		__kmc_linux_event_data->thinfo[thindex].thid = (unsigned short)pid;
+		__kmc_linux_event_data->thinfo[thindex].pid  = (unsigned short)param;
+	}
+}
+#else
+void __kmc_linux_event_set_logI(int evtid, int pid, int param)
+{
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if (__kmc_linux_event_data) {
+		T_KMC_LINUX_EVENTLOG *pLog;
+		unsigned long flags;
+		int	index;
+		u64	evtTime;
+		int	thindex;
+
+		thindex = KMC_LINUX_EVENTLOG_MAXTHREADINFO;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+
+#if defined CONFIG_KMC_EVT_USE_ARM_GLOBAL_TIMER
+		evtTime = __get_arm_global_timer();
+#elif defined CONFIG_MACH_MX3KZ
+		evtTime = __raw_readl(MXC_GPT_GPTCNT);
+#else
+#if LINUX_VERSION_CODE >= 0x020600
+		evtTime = jiffies_64;
+#else
+		evtTime = jiffies;
+#endif
+#endif
+		index = (__kmc_linux_event_data->log_index++) & (KMC_LINUX_EVENTLOG_MAXLOG - 1);
+		if (evtid == KMC_LINUX_EVENTID_NEWTHREAD) {
+			thindex = (__kmc_linux_event_data->thinfo_index++) & (KMC_LINUX_EVENTLOG_MAXTHREADINFO - 1);
+		}
+
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+
+		pLog = &(__kmc_linux_event_data->log[index]);
+
+		pLog->evtTime = evtTime;
+		pLog->evtId = evtid;
+		pLog->evtPid = pid;
+		pLog->evtParam = param;
+#ifdef CONFIG_SMP
+		pLog->cpuId = raw_smp_processor_id();
+#endif
+		if (thindex < KMC_LINUX_EVENTLOG_MAXTHREADINFO) {
+			__kmc_linux_event_data->thinfo[thindex].thid = (unsigned short)pid;
+			__kmc_linux_event_data->thinfo[thindex].pid  = (unsigned short)param;
+		}
+	}
+}
+#endif
+EXPORT_SYMBOL(__kmc_linux_event_set_logI);
+
+static int RegisterPname(int pid, const char *pname)
+{
+	int ret = -1;
+
+	if (!__kmc_linux_event_data) __kmc_linux_event_log_init();
+
+	if (__kmc_linux_event_data) {
+		int i;
+		unsigned long flags;
+
+		spin_lock_irqsave(&__kmc_linux_event_lock, flags);
+
+		//search slot
+		for (i = 0; i < KMC_LINUX_EVENTLOG_MAXPNAME; i++) {
+			int ppid = __kmc_linux_event_data->pname[i].pid;
+			if (ppid == 0) {
+				i = KMC_LINUX_EVENTLOG_MAXPNAME;
+				break;
+			} else if (ppid == pid) {
+				break;
+			}
+		}
+		if (i >= KMC_LINUX_EVENTLOG_MAXPNAME) {
+			// overwrite slot
+			i = __kmc_linux_event_data->pname_index++ & (KMC_LINUX_EVENTLOG_MAXPNAME - 1);
+			__kmc_linux_event_data->pname[i].pid = pid;
+		}
+
+		spin_unlock_irqrestore(&__kmc_linux_event_lock, flags);
+
+		strncpy(__kmc_linux_event_data->pname[i].name, pname, KMC_LINUX_EVENTLOG_MAXPNAMELENGTH-1);
+		ret = i;
+	}
+	return ret;
+}
+
+void __kmc_linux_event_set_Pname(int pid, const char* pname)
+{
+	RegisterPname(pid, pname);
+}
+
+void __kmc_linux_event_set_logS(int evtid, int pid, const char* pname)
+{
+	__kmc_linux_event_set_logI(evtid, pid, RegisterPname(pid, pname));
+}
+
+void __kmc_linux_event_set_logT(int evtid, struct task_struct* t)
+{
+	__kmc_linux_event_set_logI(evtid, t->pid, 0);
+}
+
+asmlinkage void __kmc_event_post(int id, int param1, int param2)
+{
+	__kmc_linux_event_set_logI(id, param1, param2);
+}
+
+
diff -uNr linux-3.14.19/KMC/kmc-evtr.h linux-gerda/KMC/kmc-evtr.h
--- linux-3.14.19/KMC/kmc-evtr.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc-evtr.h	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,14 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+
+#define KMC_LINUX_EVENTID_NONE          (0)
+#define KMC_LINUX_EVENTID_TASKSWITCH    (1)
+#define KMC_LINUX_EVENTID_FORK          (2)
+#define KMC_LINUX_EVENTID_EXEC          (3)
+#define KMC_LINUX_EVENTID_NEWTHREAD     (4)
+#define KMC_LINUX_EVENTID_EXIT          (5)
+
diff -uNr linux-3.14.19/KMC/kmc-mod.c linux-gerda/KMC/kmc-mod.c
--- linux-3.14.19/KMC/kmc-mod.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc-mod.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,161 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/string.h>
+#include <linux/kmc.h>
+
+#include "__brk_code.h"
+
+#ifdef noinline
+#undef noinline
+#define noinline        noinline
+#endif
+#define __KMC_DEBUG_FUNC_ATTR   __attribute__ ((noinline))
+// #define      __KMC_DEBUG_FUNC_ATTR   __attribute__ ((aligned (4), noinline))
+
+char __kmc_debug_module_name[8][64];
+struct module *__kmc_debug_module[8];
+void *__kmc_tmp_mod_array[7];
+
+__KMC_DEBUG_FUNC_ATTR
+void __kmc_mod_init_brfore(struct module *mod, int i)
+{
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d88");
+}
+
+__KMC_DEBUG_FUNC_ATTR
+void __kmc_mod_init_after(struct module *mod)
+{
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d89");
+}
+
+__KMC_DEBUG_FUNC_ATTR
+void __kmc_mod_exit(struct module *mod)
+{
+	__KMC_BRK_CODE();
+	asm("   .long   0x4c434d8a");
+}
+
+void __kmc_mod_init_brfore__(struct module *mod)
+{
+
+	int	i, st;
+
+	for (i = 0; i < 8; i++) {
+		st = strnicmp(mod->name, __kmc_debug_module_name[i], 64);
+		if (0 == st) {
+			__kmc_debug_module[i] = mod;
+			__kmc_mod_init_brfore(mod, i);
+			break;
+		} else {
+			if (strchr(__kmc_debug_module_name[i], '-')) {
+				char	__tmp_name[64], *p;
+				p = strcpy(__tmp_name, __kmc_debug_module_name[i]);
+				while ((p = strchr(p, '-')) != NULL) {
+					*p = '_';
+				}
+				st = strnicmp(mod->name, __tmp_name, 64);
+				if (0 == st) {
+					__kmc_debug_module[i] = mod;
+					__kmc_mod_init_brfore(mod, i);
+					break;
+				}
+			}
+		}
+	}
+
+	return;
+}
+
+void __kmc_mod_init_after__(struct module *mod, int ret)
+{
+	int	i;
+
+	for (i = 0; i < 8; i++) {
+		if (__kmc_debug_module[i] == mod) {
+			__kmc_mod_init_after(mod);
+			if (0 != ret) {
+				__kmc_mod_exit(mod);
+				__kmc_debug_module[i] = (void *)0;
+			}
+			break;
+		}
+	}
+
+	return;
+}
+
+void __kmc_mod_exit__(struct module *mod)
+{
+	int	i;
+
+	for (i = 0; i < 8; i++) {
+		if (__kmc_debug_module[i] == mod) {
+			__kmc_mod_exit(mod);
+			__kmc_debug_module[i] = (void *)0;
+			break;
+		}
+	}
+
+	return;
+}
+
+void __kmc_chk_mod_sec__(struct module *mod, char *secname, void *adr)
+{
+	if (0 == strnicmp(".text", secname, sizeof(".text"))) {
+		__kmc_tmp_mod_array[0] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".data", secname, sizeof(".data"))) {
+		__kmc_tmp_mod_array[1] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".bss", secname, sizeof(".bss"))) {
+		__kmc_tmp_mod_array[2] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".exit.text", secname, sizeof(".exit.text"))) {
+		__kmc_tmp_mod_array[3] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".exit.data", secname, sizeof(".exit.data"))) {
+		__kmc_tmp_mod_array[4] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".init.text", secname, sizeof(".init.text"))) {
+		__kmc_tmp_mod_array[5] = adr;
+		goto out;
+	}
+	if (0 == strnicmp(".init.data", secname, sizeof(".init.data"))) {
+		__kmc_tmp_mod_array[6] = adr;
+	}
+out:
+	return;
+}
+
+void __kmc_set_mod_sec(struct module *mod)
+{
+	mod->__kmc_mod_text = __kmc_tmp_mod_array[0];
+	mod->__kmc_mod_data = __kmc_tmp_mod_array[1];
+	mod->__kmc_mod_bss = __kmc_tmp_mod_array[2];
+	mod->__kmc_mod_exit_text = __kmc_tmp_mod_array[3];
+	mod->__kmc_mod_exit_data = __kmc_tmp_mod_array[4];
+	mod->__kmc_mod_init_text = __kmc_tmp_mod_array[5];
+	mod->__kmc_mod_init_data = __kmc_tmp_mod_array[6];
+	memset(__kmc_tmp_mod_array, 0, sizeof(__kmc_tmp_mod_array));
+
+	return;
+}
+
+
+
+
+
diff -uNr linux-3.14.19/KMC/kmc-support.c linux-gerda/KMC/kmc-support.c
--- linux-3.14.19/KMC/kmc-support.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc-support.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,433 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+#include <asm/unistd.h>
+
+#include "__brk_code.h"
+
+#define __val0(x)	#x
+#define __val1(x)	__val0(x)
+
+#if defined(__arm__)
+
+#if defined(__ARM_EABI__)			/* add 07.02.07 support eabi */
+ #define        __BL_SCHED_YIELD()                                      \
+		__asm__("       mov     r7,#" __val1(__NR_sched_yield));        \
+		__asm__("       swi     0")
+ #define        __BL_GETTID()                                           \
+		__asm__("       mov     r7,#" __val1(__NR_gettid));     \
+		__asm__("       swi     0")
+#else
+ #define	__BL_SCHED_YIELD()					\
+			__asm__("	swi	" __val1(__NR_sched_yield))
+ #define	__BL_GETTID()						\
+			__asm__("	swi	" __val1(__NR_gettid))
+#endif	// __ARM_EABI__
+
+
+ #define	__KMC_BRK_CODE__()	__KMC_BRK_CODE()
+
+ #define	__KMC_ALIGN()		__asm__("	.align	4")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	b	___ksup_sleep_thread");			\
+	__asm__("	b	___ksup_mem_hit");			\
+	__asm__("	b  	__kmc_start_debuger");			\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	stmfd	sp!, {r0-r12,r14}");			\
+	__asm__("	mrs	r0,cpsr");				\
+	__asm__("	stmfd	sp!, {r0}");				\
+	__asm__(".L4_arm:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp	r4, r0");				\
+	__asm__("	bne	.L4_arm");				\
+	__asm__("	ldmfd	sp!, {r0}");				\
+	__asm__("	msr	cpsr, r0");				\
+	__asm__("	ldmfd	sp!, {r0-r12,r14}");			\
+	__asm__("	b	___ksup_sleep_thread_brk")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	ldrb	r0, [r0, #0]");				\
+	__asm__("	b	___ksup_sleep_thread_brk")
+
+#if 0
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	stmfd	sp!, {r0, lr}");			\
+	__asm__("	bl	getpid");				\
+	__asm__("	ldmfd	sp!, {r1, lr}");			\
+	__asm__("	ldr	r2, .start");				\
+	__asm__("	b	___ksup_start_debuger_brk")
+#endif
+
+#if 1
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	b	___ksup_start_debuger_brk")
+#endif
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	4");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	4");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+
+
+#elif defined(__mips__)
+
+ #define	__BL_SCHED_YIELD()					\
+		__asm__("	li	$2,"__val1(__NR_sched_yield));	\
+		__asm__("	syscall")
+ #define	__BL_GETTID()						\
+		__asm__("	li	$2,"__val1(__NR_gettid));	\
+		__asm__("	syscall")
+
+
+ #define	__KMC_BRK_CODE__()	__KMC_BRK_CODE()
+
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()		__asm__("	.set	noat")
+
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	b	___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	b	___ksup_mem_hit");			\
+	__asm__("	nop");						\
+	__asm__("	b  	__kmc_start_debuger");			\
+	__asm__("	nop");						\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	addiu	$sp,$sp,-0x90");			\
+	__asm__("	sw	$1,0x4($sp)");				\
+	__asm__("	sw	$2,0x8($sp)");				\
+	__asm__("	sw	$3,0xc($sp)");				\
+	__asm__("	sw	$4,0x10($sp)");				\
+	__asm__("	sw	$5,0x14($sp)");				\
+	__asm__("	sw	$6,0x18($sp)");				\
+	__asm__("	sw	$7,0x1c($sp)");				\
+	__asm__("	sw	$8,0x20($sp)");				\
+	__asm__("	sw	$9,0x24($sp)");				\
+	__asm__("	sw	$10,0x28($sp)");			\
+	__asm__("	sw	$11,0x2c($sp)");			\
+	__asm__("	sw	$12,0x30($sp)");			\
+	__asm__("	sw	$13,0x34($sp)");			\
+	__asm__("	sw	$14,0x38($sp)");			\
+	__asm__("	sw	$15,0x3c($sp)");			\
+	__asm__("	sw	$16,0x40($sp)");			\
+	__asm__("	sw	$17,0x44($sp)");			\
+	__asm__("	sw	$18,0x48($sp)");			\
+	__asm__("	sw	$19,0x4c($sp)");			\
+	__asm__("	sw	$20,0x50($sp)");			\
+	__asm__("	sw	$21,0x54($sp)");			\
+	__asm__("	sw	$22,0x58($sp)");			\
+	__asm__("	sw	$23,0x5c($sp)");			\
+	__asm__("	sw	$24,0x60($sp)");			\
+	__asm__("	sw	$25,0x64($sp)");			\
+	__asm__("	sw	$26,0x68($sp)");			\
+	__asm__("	sw	$27,0x6c($sp)");			\
+	__asm__("	sw	$28,0x70($sp)");			\
+	__asm__("	sw	$30,0x74($sp)");			\
+	__asm__("	sw	$31,0x78($sp)");			\
+	__asm__("	mfhi	$1");					\
+	__asm__("	sw	$1,0x7c($sp)");				\
+	__asm__("	mflo	$1");					\
+	__asm__("	sw	$1,0x80($sp)");				\
+	__asm__(".L4_mips:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	bne	$4,$2,.L4_mips");			\
+	__asm__("	nop");						\
+	__asm__("	lw	$2,0x8($sp)");				\
+	__asm__("	lw	$3,0xc($sp)");				\
+	__asm__("	lw	$4,0x10($sp)");				\
+	__asm__("	lw	$5,0x14($sp)");				\
+	__asm__("	lw	$6,0x18($sp)");				\
+	__asm__("	lw	$7,0x1c($sp)");				\
+	__asm__("	lw	$8,0x20($sp)");				\
+	__asm__("	lw	$9,0x24($sp)");				\
+	__asm__("	lw	$10,0x28($sp)");			\
+	__asm__("	lw	$11,0x2c($sp)");			\
+	__asm__("	lw	$12,0x30($sp)");			\
+	__asm__("	lw	$13,0x34($sp)");			\
+	__asm__("	lw	$14,0x38($sp)");			\
+	__asm__("	lw	$15,0x3c($sp)");			\
+	__asm__("	lw	$16,0x40($sp)");			\
+	__asm__("	lw	$17,0x44($sp)");			\
+	__asm__("	lw	$18,0x48($sp)");			\
+	__asm__("	lw	$19,0x4c($sp)");			\
+	__asm__("	lw	$20,0x50($sp)");			\
+	__asm__("	lw	$21,0x54($sp)");			\
+	__asm__("	lw	$22,0x58($sp)");			\
+	__asm__("	lw	$23,0x5c($sp)");			\
+	__asm__("	lw	$24,0x60($sp)");			\
+	__asm__("	lw	$25,0x64($sp)");			\
+	__asm__("	lw	$26,0x68($sp)");			\
+	__asm__("	lw	$27,0x6c($sp)");			\
+	__asm__("	lw	$28,0x70($sp)");			\
+	__asm__("	lw	$30,0x74($sp)");			\
+	__asm__("	lw	$31,0x78($sp)");			\
+	__asm__("	lw	$1,0x7c($sp)");				\
+	__asm__("	mthi	$1");					\
+	__asm__("	lw	$1,0x80($sp)");				\
+	__asm__("	mtlo	$1");					\
+	__asm__("	lw	$1,0x4($sp)");				\
+	__asm__("	addiu	$sp,$sp,0x90");				\
+	__asm__("	beq	$0,$0,___ksup_sleep_thread_brk");	\
+	__asm__("	nop")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	lb	$1,0($1)");				\
+	__asm__("	beq	$0,$0,___ksup_sleep_thread_brk");	\
+	__asm__("	nop")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	beq	$0,$0,___ksup_start_debuger_brk");	\
+	__asm__("	nop")
+
+ #define	__KMC_START()
+
+
+#elif defined(__sh__)
+
+ #define	__BL_SCHED_YIELD()					\
+	__asm__("	mov	#" __val1(__NR_sched_yield) ",r3");	\
+	__asm__("	extu.b	r3,r3");				\
+	__asm__("	trapa	#0x10")
+ #define	__BL_GETTID()						\
+	__asm__("	mov	#" __val1(__NR_gettid) ",r3");		\
+	__asm__("	extu.b	r3,r3");				\
+	__asm__("	trapa	#0x10");				\
+
+
+ #define	__KMC_BRK_CODE__()	__KMC_BRK_CODE()
+
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	bra	___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	bra	___ksup_mem_hit");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	bra	__kmc_start_debuger");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	.long	0x014c434d")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	mov.l	r0,@-r15");				\
+	__asm__("	mov.l	r1,@-r15");				\
+	__asm__("	mov.l	r2,@-r15");				\
+	__asm__("	mov.l	r3,@-r15");				\
+	__asm__("	mov.l	r4,@-r15");				\
+	__asm__("	mov.l	r5,@-r15");				\
+	__asm__("	mov.l	r6,@-r15");				\
+	__asm__("	mov.l	r7,@-r15");				\
+	__asm__("	mov.l	r8,@-r15");				\
+	__asm__("	mov.l	r9,@-r15");				\
+	__asm__("	mov.l	r10,@-r15");				\
+	__asm__("	mov.l	r11,@-r15");				\
+	__asm__("	mov.l	r12,@-r15");				\
+	__asm__("	mov.l	r13,@-r15");				\
+	__asm__("	mov.l	r14,@-r15");				\
+	__asm__("	sts.l	pr,@-r15");				\
+	__asm__("	sts.l	macl,@-r15");				\
+	__asm__("	sts.l	mach,@-r15");				\
+	__asm__(".L4_sh:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp/eq	r4,r0");				\
+	__asm__("	bf	.L4_sh");				\
+	__asm__("	nop");						\
+	__asm__("	lds.l	@r15+,mach");				\
+	__asm__("	lds.l	@r15+,macl");				\
+	__asm__("	lds.l	@r15+,pr");				\
+	__asm__("	mov.l	@r15+,r14");				\
+	__asm__("	mov.l	@r15+,r13");				\
+	__asm__("	mov.l	@r15+,r12");				\
+	__asm__("	mov.l	@r15+,r11");				\
+	__asm__("	mov.l	@r15+,r10");				\
+	__asm__("	mov.l	@r15+,r9");				\
+	__asm__("	mov.l	@r15+,r8");				\
+	__asm__("	mov.l	@r15+,r7");				\
+	__asm__("	mov.l	@r15+,r6");				\
+	__asm__("	mov.l	@r15+,r5");				\
+	__asm__("	mov.l	@r15+,r4");				\
+	__asm__("	mov.l	@r15+,r3");				\
+	__asm__("	mov.l	@r15+,r2");				\
+	__asm__("	mov.l	@r15+,r1");				\
+	__asm__("	mov.l	@r15+,r0");				\
+	__asm__("	bra	___ksup_sleep_thread_brk");		\
+	__asm__("	nop")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	mov.b	@r8,r9");				\
+	__asm__("	bra	___ksup_sleep_thread_brk");		\
+	__asm__("	nop")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	mov.l	.start,r6");				\
+	__asm__("	bra	___ksup_start_debuger_brk");		\
+	__asm__("	nop")
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+
+#elif defined(__mn10300__)
+
+ #define	__BL_SCHED_YIELD()					\
+	__asm__("	mov	" __val1(__NR_sched_yield) ",d0");	\
+	__asm__("	syscall 0")
+ #define	__BL_GETTID()						\
+	__asm__("	mov	" __val1(__NR_gettid) ",d0");		\
+	__asm__("	syscall 0")
+
+
+ #define	__KMC_BRK_CODE__()	__KMC_BRK_CODE()
+
+ #define	__KMC_ALIGN()		__asm__("	.align	2")
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()					\
+	__asm__("	jmp ___ksup_sleep_thread");			\
+	__asm__("	nop");						\
+	__asm__("	nop");						\
+	__asm__("	jmp ___ksup_mem_hit");				\
+	__asm__("	nop");						\
+	__asm__("	nop")
+
+ #define	__KSUP_SLEEP_THREAD()					\
+	__asm__("	movm	[d2,d3,a2,a3,other,exreg0,exreg1,exother],(sp)");	\
+	__asm__(".L4_mn103:");						\
+	__BL_SCHED_YIELD();						\
+	__BL_GETTID();							\
+	__asm__("	cmp	d0,d3");				\
+	__asm__("	bne	.L4_mn103");				\
+	__asm__("	movm	(sp),[d2,d3,a2,a3,other,exreg0,exreg1,exother]");	\
+	__asm__("	jmp	___ksup_sleep_thread_brk")
+
+ #define	__KSUP_MEM_HIT()					\
+	__asm__("	movbu	(a0),d0");				\
+	__asm__("	jmp	___ksup_sleep_thread_brk")
+
+ #define	__KMC_START_DEBUGER()					\
+	__asm__("	mov	(.start),d2");				\
+	__asm__("	jmp	___ksup_start_debuger_brk")
+
+#ifndef __KMC_STATIC_SUPPORT
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	0x0000849c")
+#else
+ #define	__KMC_START()						\
+	__asm__("	.align	2");					\
+	__asm__(".start:");						\
+	__asm__("	.long	_start")
+#endif
+
+#else
+
+ #define	__KMC_BRK_CODE__()
+ #define	__KMC_ALIGN()
+ #define	__KMC_NOAT()
+
+ #define	__KMC_SLEEP_THREAD()
+ #define	__KSUP_SLEEP_THREAD()
+ #define	__KSUP_MEM_HIT()
+ #define	__KMC_START_DEBUGER()
+ #define	__KMC_START()
+
+ #error "not support CPU"
+#endif
+
+
+
+
+/*** ’Ç‰Á Sato ***/
+__asm__("	.globl	__kmc_sup_start");
+__asm__("	.equ	__kmc_sup_start, __kmc_user_debug_end");
+
+__asm__("	.globl	__kmc_sup_size");
+__asm__("	.equ	__kmc_sup_size, __kmc_user_debug_end + 4");
+
+__asm__("	.globl	__kmc_sleep_thr_offs");
+__asm__("	.equ	__kmc_sleep_thr_offs, __kmc_user_debug_end + 8");
+/****/
+
+
+__asm__("	.text");
+__KMC_ALIGN();
+/*** Sato ***/
+__asm__("__kmc_user_debug:");
+__asm__("__kmc_user_debug_tmp_start:");
+/******/
+__asm__("	.long	0x4c434d02");	// magic code 'KMC' + function no
+
+__asm__("___ksup_start_debuger_brk:");
+__KMC_BRK_CODE__();			// r0.. pid , r1.. arg[0](app filename)
+__asm__("	.long	0x4c434d01");	// magic code 'KMC' + function no
+
+__asm__("___ksup_sleep_thread_brk:");
+__KMC_BRK_CODE__();			// r0.. pid , r1.. arg[0](app filename)
+__asm__("	.long	0x4c434d00");	// magic code 'KMC' + function no
+
+__KMC_NOAT();
+__asm__("	.global	__kmc_sleep_thread");
+__asm__("__kmc_sleep_thread:");
+__KMC_SLEEP_THREAD();
+
+__asm__("___ksup_sleep_thread:");
+__KSUP_SLEEP_THREAD();
+
+
+__asm__("___ksup_mem_hit:");
+__KSUP_MEM_HIT();
+
+#ifndef	__KMC_DYNAMIC_SUPPORT
+__asm__("	.global	__kmc_start_debuger");
+#endif
+__asm__("__kmc_start_debuger:");
+__KMC_START_DEBUGER();
+
+
+__KMC_START();
+
+/*** Sato ***/
+__asm__("__kmc_user_debug_end:");
+__asm__("	.long	__kmc_user_debug");	/* kmcsup code start address */
+__asm__("	.long	__kmc_user_debug_end - __kmc_user_debug"); /* kmcsup code size */
+__asm__("	.long	__kmc_sleep_thread - __kmc_user_debug"); /* __kmc_sleep_thread offset */
+__asm__("");
+/*****/
+
+
diff -uNr linux-3.14.19/KMC/kmc.c linux-gerda/KMC/kmc.c
--- linux-3.14.19/KMC/kmc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,415 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+#include <linux/pagemap.h>
+#include <linux/spinlock.h>
+#include <linux/version.h>
+#include <linux/sched.h>
+#include <linux/mman.h>
+#include <linux/syscalls.h>
+#include <asm/uaccess.h>
+#include <asm/param.h>
+#include <asm/page.h>
+
+#include <linux/kmc.h>
+
+#include "kmc-evtr.h"
+#include "__brk_code.h"
+
+
+
+#ifdef noinline
+#undef noinline
+#define noinline        noinline
+#endif
+#define	__KMC_DEBUG_FUNC_ATTR	__attribute__ ((noinline))
+// #define	__KMC_DEBUG_FUNC_ATTR	__attribute__ ((aligned (4), noinline))
+
+
+__KMC_DEBUG_FUNC_ATTR
+void __kmc_do_exit(void)
+{
+	__asm__("nop");
+
+}
+
+#ifdef CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF 
+
+#define __KMC_MAX_PT_COUNT	32
+
+struct task_struct *__kmc_tss_list[__KMC_MAX_PT_COUNT + 1];
+
+void __kmc_do_exit__(struct task_struct *tsk)
+{
+	int	i;
+
+	__KMC_LINUX_EVENT_SET_LOG_T(KMC_LINUX_EVENTID_EXIT, tsk);
+	
+	if (__kmc_tss_list[0] != 0) {
+		for (i = 1; i < (__KMC_MAX_PT_COUNT + 1); ++i) {
+			if (__kmc_tss_list[i] == tsk) {
+				__kmc_tss_list[0] = (struct task_struct *)i;
+				__kmc_do_exit();
+			}
+		}
+	}
+	return;
+}
+#else
+
+#define	__KMC_MAX_THREAD_COUNT	256
+#define	__KMC_MAX_PT_COUNT	4
+
+struct task_struct *__kmc_tss_list_array[__KMC_MAX_PT_COUNT + 1][__KMC_MAX_THREAD_COUNT];
+
+void __kmc_do_exit__(struct task_struct *tsk)
+{
+	int	i;
+
+	__KMC_LINUX_EVENT_SET_LOG_T(KMC_LINUX_EVENTID_EXIT, tsk);
+
+	if (__kmc_tss_list_array[0][0] != 0) {
+#ifdef CONFIG_SMP
+		static spinlock_t __kmc_do_exit_lock = __SPIN_LOCK_UNLOCKED(__kmc_do_exit_lock);
+		spin_lock(&__kmc_do_exit_lock);
+#endif
+		for (i = 1; i < (__KMC_MAX_PT_COUNT + 1); ++i) {
+			int	j;
+			struct task_struct **tpp;
+			struct task_struct *tp;
+
+			tpp = __kmc_tss_list_array[i];
+			for (j = 0; j < __KMC_MAX_THREAD_COUNT; ++j) {
+				tp = *(tpp++);
+				if (tp == 0) break;
+				if (tp == tsk) {
+					while (j < (__KMC_MAX_THREAD_COUNT - 1)) {
+						if (*tpp == 0) break;
+						*(tpp - 1) = *tpp;
+						*tpp = tsk;
+						++tpp;
+						++j;
+					}
+					__kmc_tss_list_array[0][0] = (struct task_struct *)i;
+					__kmc_tss_list_array[0][1] = (struct task_struct *)j;
+					__kmc_do_exit();
+					i = (__KMC_MAX_PT_COUNT + 1);
+					break;
+				}
+			}
+		}
+#ifdef CONFIG_SMP
+		spin_unlock(&__kmc_do_exit_lock);
+#endif
+	}
+	return;
+}
+#endif
+
+
+
+#define KMC_MAX_SHEDULE_LIST    1024
+
+#ifdef CONFIG_SMP
+
+#define	CORE_SMP_NUMBER	CONFIG_NR_CPUS
+int __kmc_schedules_list_pid_smp[CORE_SMP_NUMBER][KMC_MAX_SHEDULE_LIST];
+int __kmc_schedules_index_smp[CORE_SMP_NUMBER];
+int __kmc_schedules_index_max = KMC_MAX_SHEDULE_LIST;
+
+#else
+
+int __kmc_schedules_index_max = KMC_MAX_SHEDULE_LIST;
+int __kmc_schedules_index;
+int __kmc_schedules_list_pid[KMC_MAX_SHEDULE_LIST];
+
+#endif
+
+#ifdef CONFIG_MN10300
+int __kmc_am33_trace = 0;
+#endif
+
+#ifdef CONFIG_KMC_USE_BT
+int  __kmc_schedule_trace_point;
+void __kmc_code_data(int);
+#ifdef CONFIG_ARM
+#include	"kmc_dt_arm.c"
+#endif
+#ifdef  CONFIG_MIPS
+#include	"kmc_dt_mips.c"
+#endif
+#ifdef CONFIG_SUPERH
+#include	"kmc_dt_sh.c"
+#endif
+#ifdef CONFIG_MN10300
+#include	"kmc_dt_am33.c"
+#endif
+#endif
+
+#ifdef CONFIG_KMC_USE_BT
+static spinlock_t __kmc_linux_schedule_lock = __SPIN_LOCK_UNLOCKED(__kmc_linux_schedule_lock);
+#endif
+
+__KMC_DEBUG_FUNC_ATTR
+void __kmc_schedule(struct task_struct *prev,struct task_struct *next)
+{
+	int	index_next;
+#ifdef CONFIG_SMP
+    	int	cpu;
+
+	cpu = raw_smp_processor_id();
+	index_next=__kmc_schedules_index_smp[cpu] & (KMC_MAX_SHEDULE_LIST-1);
+	++__kmc_schedules_index_smp[cpu];
+	#ifdef CONFIG_KMC_USE_BT
+		__kmc_code_data(__kmc_schedule_trace_point=__kmc_schedules_list_pid_smp[cpu][index_next]=next->pid);
+	#else
+		__kmc_schedules_list_pid_smp[cpu][index_next]=next->pid;
+	#endif
+#else
+
+	index_next=__kmc_schedules_index & (KMC_MAX_SHEDULE_LIST-1);
+	++__kmc_schedules_index;
+
+	#ifdef CONFIG_KMC_USE_BT
+    		__kmc_code_data(__kmc_schedule_trace_point=__kmc_schedules_list_pid[index_next]=next->pid);
+	#else
+		__kmc_schedules_list_pid[index_next]=next->pid;
+	#endif
+#endif
+#ifdef CONFIG_MN10300
+	if(__kmc_am33_trace==7){
+		*(char *)(0xC00001C3) |= 0x01;
+	}
+#endif
+}
+
+void (*__kmc_schedule_call)(struct task_struct *,struct task_struct *)=__kmc_schedule;
+
+void __kmc_schedule__(struct task_struct *prev,struct task_struct *next)
+{
+#ifdef CONFIG_KMC_USE_BT
+	unsigned long flags;
+
+	spin_lock_irqsave(&__kmc_linux_schedule_lock, flags);
+#endif
+
+	__kmc_schedule_call(prev, next);
+
+	__KMC_LINUX_EVENT_SET_LOG_I( KMC_LINUX_EVENTID_TASKSWITCH, prev->pid, next->pid );
+
+#ifdef CONFIG_KMC_USE_BT
+	spin_unlock_irqrestore(&__kmc_linux_schedule_lock, flags);
+#endif
+}
+
+
+
+/* This code is for thread debugging to realize delayed attach */
+void __kmc_delayed_attach(void) {
+	asm(".global __kmc_thr_debug_area");
+	asm("__kmc_thr_debug_area:");
+	__KMC_BRK_CODE();
+	asm (" .long  0x4c434dad");
+}
+void (*__kmc_delayed_attach_tmp)(void) = __kmc_delayed_attach;
+
+#ifdef CONFIG_KMC_NO_USER_PATCH
+#define __KMC_EXEC(a, b, c)	__kmc_exec(a, b, c)
+#define	__KMC_INJECT_SUPCODE(a)	__kmc_inject_supcode(a)
+#else
+#define __KMC_EXEC(a, b, c)
+#define	__KMC_INJECT_SUPCODE(a)
+#endif
+
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH) 
+
+#ifdef CONFIG_KMC_NO_USER_PATCH
+#define TARGET_TABLE_MAX	16+1
+char __kmc_target_process_name[TARGET_TABLE_MAX][128];
+
+__KMC_DEBUG_FUNC_ATTR
+void ___kmc_exec(char *comm, struct task_struct *taskp) {
+	__KMC_BRK_CODE();
+	asm (" .long  0x4c434daa");
+	asm (" nop");
+}
+
+__KMC_DEBUG_FUNC_ATTR
+void ___kmc_thread_start(struct task_struct *taskp, char *name) {
+	__KMC_BRK_CODE();
+	asm (" .long  0x4c434d11");
+	asm (" nop");
+}
+
+extern void __kmc_start_debuger(struct task_struct *, char *);
+
+void __kmc_exec(char *comm, struct task_struct *taskp, int isthread)
+{
+    int i;
+
+	if (isthread) {		// isthread:1 -> NPTL, isthread:2 -> linuxthreads
+		for (i = 1; i < __KMC_MAX_PT_COUNT; i++) {
+			struct task_struct *t;
+#ifdef CONFIG_KMC_PARTNER_COLLECT_THREAD_OFF
+			r = __kmc_tss_list[i];
+#else
+			t = __kmc_tss_list_array[i][0];
+#endif
+			if (NULL != t && (struct task_struct *)0xffffffff != t) {
+				if (1 == isthread) {	// NPTL
+					if (taskp->tgid == t->tgid) {
+						___kmc_thread_start(taskp, NULL);
+						break;
+					}
+				} else {		// linuxthreads
+					if (taskp->mm == t->mm) {
+						___kmc_thread_start(taskp, NULL);
+						break;
+					}
+				}
+			}
+		}
+	} else {
+    		for (i = 0; i < TARGET_TABLE_MAX; i++) {
+        		if (strncmp(__kmc_target_process_name[i], comm, strlen(comm)) == 0) {
+				unsigned long start_code = (unsigned long)taskp->mm->start_code;
+				unsigned long end_code = (unsigned long)taskp->mm->end_code;
+				char dummy;
+				while (end_code > start_code) {
+		    			volatile char __user *hit = (char *)start_code;
+		    			dummy = *hit;
+		    			start_code += PAGE_SIZE;
+				}
+				___kmc_exec(comm, taskp);
+				break;
+			}
+		}
+	}
+}
+
+extern char	*__kmc_sup_start;
+extern int	__kmc_sup_size;
+
+void __kmc_inject_supcode(struct task_struct *task)
+{
+
+	char *usrcode = (char *)(task->mm->start_brk - PAGE_SIZE);
+	access_process_vm(task, (unsigned long)usrcode, (void *)__kmc_sup_start, __kmc_sup_size, 1);
+
+	return;
+}
+
+void __kmc_copy_supcode(unsigned long elf_brk)
+{
+	char __user *usrcode;
+	int	ret;
+
+	if (__kmc_sup_size) {
+		usrcode = (char *)(PAGE_ALIGN(elf_brk) - PAGE_SIZE);
+		ret = copy_to_user(usrcode, __kmc_sup_start, __kmc_sup_size);
+		flush_icache_range((unsigned long)usrcode, (unsigned long)(usrcode + __kmc_sup_size));
+		sys_mlock((unsigned long)usrcode, PAGE_SIZE);
+		sys_mprotect((unsigned long)usrcode, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC);
+	}
+	return;
+
+}
+
+asmlinkage void __kmc_mlock(void)
+{
+	if (current->mm) {
+		if (current->mm->start_brk) {
+			sys_mlock(current->mm->start_brk - PAGE_SIZE, PAGE_SIZE);
+			sys_mprotect(current->mm->start_brk - PAGE_SIZE, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC);
+		}
+	}
+}
+
+#endif // CONFIG_KMC_NO_USER_PATCH
+
+// mode;		0.. fork,clone , 1... execv 
+// param;		mode = 0, clone_flags, mode = 1, filename
+void __kmc_make_fork_tbl(struct task_struct *task_p, int mode, unsigned long param)
+{
+	if(mode==0){
+		/* fork,clone */
+		if (task_p->mm == 0) {
+			// kernel thread
+			__KMC_LINUX_EVENT_SET_LOG_I( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, 0 );
+		} else if ((param & CSIGNAL) != SIGCHLD) {
+			// user thread
+			int thread_mode = 2;		// 1 = NPTL, 2 = linuxthreads
+			if (task_p == task_p->group_leader) {
+				thread_mode = 2;	// linux_threads
+			} else {
+				thread_mode = 1;	// NPTL
+			}
+			if (1 == thread_mode) {
+				// NPTL
+				__KMC_LINUX_EVENT_SET_LOG_I( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, task_p->group_leader->pid );
+			} else {
+				// linuxthreads
+				__KMC_LINUX_EVENT_SET_LOG_I( KMC_LINUX_EVENTID_NEWTHREAD, task_p->pid, task_p->parent->pid );
+			}
+			__KMC_EXEC(task_p->comm, task_p, thread_mode);
+		} else {
+			// user process
+			__KMC_LINUX_EVENT_SET_LOG_S( KMC_LINUX_EVENTID_FORK, task_p->pid, task_p->comm );
+ 			__KMC_INJECT_SUPCODE(task_p);
+		}
+	} else{
+		/* execv */
+		__KMC_LINUX_EVENT_SET_LOG_S( KMC_LINUX_EVENTID_EXEC, current->pid, (char *)param);
+		__KMC_EXEC(task_p->comm, task_p, 0);
+	}
+	return;
+}
+#endif	// defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+
+#ifdef CONFIG_KMC_NOTIFY_UPDATE_CONTEXTID
+
+#ifdef CONFIG_SMP
+#define __KMC_MAX_CORE_COUNT            CONFIG_NR_CPUS
+#else
+#define __KMC_MAX_CORE_COUNT            1
+#endif
+#define __KMC_MAX_HBRK_CID_COUNT        8
+
+volatile unsigned int __kmc_hbrk_cid[__KMC_MAX_CORE_COUNT][__KMC_MAX_HBRK_CID_COUNT];
+
+void __kmc_notify_update_contextid(struct mm_struct *mm, u64 asid)
+{
+	int	i, j, flg = 0;
+
+	for (i = 0; i < __KMC_MAX_CORE_COUNT; i++) {
+		for (j = 0; j < __KMC_MAX_HBRK_CID_COUNT; j++) {
+			if (__kmc_hbrk_cid[i][j] == 0) {
+				break;
+			} else {
+				u64	old_asid;
+				old_asid = atomic64_read(&mm->context.id);
+				if (__kmc_hbrk_cid[i][j] == (int)old_asid) {
+					__kmc_hbrk_cid[i][j] = (int)asid;
+					flg = 1;
+				}
+			}
+		}
+	}
+	if (flg) {
+		__KMC_BRK_CODE();
+		asm(" .long   0x4c434df0");
+		asm(" nop");
+	}
+#if 0
+	if (atomic64_read(&mm->context.id) != 0) {
+		printk("contextid changed: %08llx -> %08llx\n",atomic64_read(&mm->context.id), asid);
+	}
+#endif
+
+	return;
+}
+
+#endif
diff -uNr linux-3.14.19/KMC/kmc_dt_am33.c linux-gerda/KMC/kmc_dt_am33.c
--- linux-3.14.19/KMC/kmc_dt_am33.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc_dt_am33.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,550 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	movm	[other],(sp)");
+    asm("	mov	__kmc_code_data_table,a1");
+    asm("	mov	4,d1");
+    asm("	mov	d0,a0");
+    asm("	and	0xff,a0");
+    asm("	asl2	a0");
+    asm("	add	a1,a0");
+    asm("	jmp	(a0)");
+    asm("	nop");
+    asm("	.align	2");
+    asm("__kmc_code_data_table:");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("	jmp	jmp_end");
+    asm("	.align	2");
+    asm("jmp_end:");
+    asm("	add	-1,d1");
+    asm("	beq	jmp_end1");
+    asm("	lsr     8,d0");
+    asm("	mov	d0,a0");
+    asm("	and	0xff,a0");
+    asm("	asl2	a0");
+    asm("	add	a1,a0");
+    asm("	jmp	(a0)");
+    asm("jmp_end1:");
+    asm("	movm    (sp),[other]");
+    asm("	ret    [],0");
+
+
diff -uNr linux-3.14.19/KMC/kmc_dt_arm.c linux-gerda/KMC/kmc_dt_arm.c
--- linux-3.14.19/KMC/kmc_dt_arm.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc_dt_arm.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,285 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	ldr	r3, __kmc_code_data_tableX");
+    asm("	mov	r2, #4");
+    asm("loop:");
+    asm("	and	r1, r0, #0xff");
+    asm("	add	pc, r3, r1, asl #2");
+    asm("__kmc_code_data_table:");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("	b	jmp_end");
+    asm("jmp_end:");
+    asm("	mov	r0, r0, lsr #8");
+    asm("	subs	r2, r2, #1");
+    asm("	bne	loop");
+    asm("	mov	pc,lr");
+    asm("	.align	2");
+    asm("__kmc_code_data_tableX:");
+    asm("	.word	__kmc_code_data_table");
+
+
diff -uNr linux-3.14.19/KMC/kmc_dt_mips.c linux-gerda/KMC/kmc_dt_mips.c
--- linux-3.14.19/KMC/kmc_dt_mips.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc_dt_mips.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,558 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+
+
+asm("	.text");
+asm("	.align	2");
+asm("	.global	__kmc_code_data");
+asm("__kmc_code_data:");
+asm("	la	$5, __kmc_code_data_table");
+asm("	li	$6, 4");
+asm("	rol	$4, $4, 3");
+asm("	andi	$7, $4, 0x7f8");
+asm("loop:");
+asm("	addu	$7, $7, $5");
+asm("	jr	$7");
+asm("__kmc_code_data_table:");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+asm("	addiu	$6, $6, -1");
+asm("	beq	$0,$0,jmp_end");
+
+asm("jmp_end:");
+asm("	ror	$4, $4, 8");
+asm("	andi	$7, $4, 0x7f8");
+asm("	bne	$6, $0, loop");
+asm("	jr	$31");
+
+
+
diff -uNr linux-3.14.19/KMC/kmc_dt_sh.c linux-gerda/KMC/kmc_dt_sh.c
--- linux-3.14.19/KMC/kmc_dt_sh.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/KMC/kmc_dt_sh.c	2017-06-22 09:52:27.587040001 +0900
@@ -0,0 +1,555 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * Ver2.0	08.04.14
+ *
+ */
+
+
+
+
+
+    asm("	.text");
+    asm("	.align	2");
+    asm("	.global	__kmc_code_data");
+    asm("__kmc_code_data:");
+    asm("	mova	__kmc_code_data_table,r0");
+    asm("	mov	r0,r1");
+    asm("	mov	#4,r2");
+    asm("	mov	#0xff,r3");
+    asm("	extu.b	r3,r3");
+    asm("	mov	r4,r0");
+    asm("	and	r3,r0");
+    asm("	shll2	r0");
+    asm("	add	r1,r0");
+    asm("	jmp	@r0");
+    asm("	nop");
+    asm("	.align	2");
+    asm("__kmc_code_data_table:");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("	bra	jmp_end");
+    asm("	shlr8	r4");
+    asm("jmp_end:");
+    asm("	add	#0xff,r2");
+    asm("	tst	r2,r2");
+    asm("	bt	jmp_end1");
+    asm("	mov	r4,r0");
+    asm("	and	r3,r0");
+    asm("	shll2	r0");
+    asm("	add	r1,r0");
+    asm("	jmp	@r0");
+    asm("	nop");
+    asm("jmp_end1:");
+    asm("	rts");
+    asm("	nop");
+
+
diff -uNr linux-3.14.19/Makefile linux-gerda/Makefile
--- linux-3.14.19/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/Makefile	2017-06-22 09:52:09.387040542 +0900
@@ -642,7 +642,7 @@
 KBUILD_CFLAGS   += $(call cc-option, -fno-var-tracking-assignments)
 
 ifdef CONFIG_DEBUG_INFO
-KBUILD_CFLAGS	+= -g
+KBUILD_CFLAGS	+= -gdwarf-2
 KBUILD_AFLAGS	+= -Wa,--gdwarf-2
 endif
 
@@ -783,6 +783,10 @@
 ifeq ($(KBUILD_EXTMOD),)
 core-y		+= kernel/ mm/ fs/ ipc/ security/ crypto/ block/
 
+ifeq ($(CONFIG_KMC_PATCH),y)
+core-y		+= KMC/
+endif
+
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
 		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
diff -uNr linux-3.14.19/arch/arm/Kconfig linux-gerda/arch/arm/Kconfig
--- linux-3.14.19/arch/arm/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/Kconfig	2017-06-22 09:52:12.683040444 +0900
@@ -15,7 +15,8 @@
 	select CPU_PM if (SUSPEND || CPU_IDLE)
 	select DCACHE_WORD_ACCESS if HAVE_EFFICIENT_UNALIGNED_ACCESS
 	select GENERIC_ATOMIC64 if (CPU_V7M || CPU_V6 || !CPU_32v6K || !AEABI)
-	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
+#	select GENERIC_CLOCKEVENTS_BROADCAST if SMP
+	select GENERIC_CLOCKEVENTS_BROADCAST if (SMP && !ARCH_GERDA)
 	select GENERIC_IDLE_POLL_SETUP
 	select GENERIC_IRQ_PROBE
 	select GENERIC_IRQ_SHOW
@@ -955,6 +956,8 @@
 
 source "arch/arm/mach-gemini/Kconfig"
 
+source "arch/arm/mach-gerda/Kconfig"
+
 source "arch/arm/mach-highbank/Kconfig"
 
 source "arch/arm/mach-hisi/Kconfig"
@@ -1391,6 +1394,10 @@
 	  loop buffer may deliver incorrect instructions. This
 	  workaround disables the loop buffer to avoid the erratum.
 
+config ARM_ERRATA_782773
+	bool
+	depends on CPU_V7
+
 endmenu
 
 source "arch/arm/common/Kconfig"
@@ -2165,6 +2172,12 @@
 	  0xf8000000. This assumes the zImage being placed in the first 128MB
 	  from start of memory.
 
+config BOOT_SET_ZRELADDR
+	bool "Boot loader set the decompressed kernel image address"
+	help
+	  ZRELADDR is the physical address where the decompressed kernel
+	  image will be placed. If BOOT_SET_ZRELADDR is selected,
+	  a boot loader is required to set the address in r3 register
 endmenu
 
 menu "CPU Power Management"
diff -uNr linux-3.14.19/arch/arm/Makefile linux-gerda/arch/arm/Makefile
--- linux-3.14.19/arch/arm/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/Makefile	2017-06-22 09:52:11.803040470 +0900
@@ -154,6 +154,7 @@
 machine-$(CONFIG_ARCH_EP93XX)		+= ep93xx
 machine-$(CONFIG_ARCH_EXYNOS)		+= exynos
 machine-$(CONFIG_ARCH_GEMINI)		+= gemini
+machine-$(CONFIG_ARCH_GERDA)		+= gerda
 machine-$(CONFIG_ARCH_HIGHBANK)		+= highbank
 machine-$(CONFIG_ARCH_HI3xxx)		+= hisi
 machine-$(CONFIG_ARCH_INTEGRATOR)	+= integrator
diff -uNr linux-3.14.19/arch/arm/boot/compressed/head.S linux-gerda/arch/arm/boot/compressed/head.S
--- linux-3.14.19/arch/arm/boot/compressed/head.S	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/boot/compressed/head.S	2017-06-22 09:52:11.335040484 +0900
@@ -170,7 +170,9 @@
 
 		.text
 
-#ifdef CONFIG_AUTO_ZRELADDR
+#if defined(CONFIG_BOOT_SET_ZRELADDR)
+		mov	r4, r3
+#elif defined(CONFIG_AUTO_ZRELADDR)
 		@ determine final kernel image address
 		mov	r4, pc
 		and	r4, r4, #0xf8000000
@@ -1139,6 +1141,69 @@
 		mcr	p15, 0, r10, c7, c5, 0	@ invalidate I+BTB
 		mcr	p15, 0, r10, c7, c10, 4	@ DSB
 		mcr	p15, 0, r10, c7, c5, 4	@ ISB
+#if defined(CONFIG_MACH_GERDAC) && defined(CONFIG_MN_L2CACHE_ENABLE)
+#define L2C_ADDR(reg)		(0x610c0000 + (reg) & 0xffff)
+
+#define L2CC			0x00000000	/* control */
+#define L2CC_ON			0x00000001	/* on */
+
+#define L2COQM			0x00000248	/* CO que mode */
+#define L2COQM_CM		0x00000007	/* cache command */
+#define L2COQM_CM_WBINV		0x00000002	/* - write back & invalidate */
+#define L2COQM_CW		0x00004000	/* notification mode */
+#define L2COQM_CW_FLAG		0x00000000	/* - flag */
+#define L2COQM_S		0x00060000	/* specification mode */
+#define L2COQM_S_ALL		0x00020000	/* - all */
+
+#define L2COPPQSEF		0x0000025c	/* CO que set flag PP */
+#define L2COPPQSEF_OE		0x00000001	/* failure except for que full */
+#define L2COPPQSEF_FE		0x00000002	/* failure for que full */
+
+#define L2COPE			0x00000244	/* CO primitive entry */
+#define L2COPE_CM		0x0000000f	/* cache command */
+#define L2COPE_CM_FLSH_PFBUF	0x00000009	/* - flush pref buff */
+
+#define L2COQS			0x000002c0	/* CO que status LP */
+#define L2COQS_EF		0x00000004	/* complete flag */
+
+#define L2COSYNC		0x00000240	/* CO sync */
+#define L2COSYNC_CM		0x00000001	/* execute sync data */
+
+__mn_l2cache_flush:
+		dsb
+		ldr	r1, =L2C_ADDR(L2CC)
+		ldr	r9, [r1]
+		tst	r9, #L2CC_ON
+		beq	3f
+
+		ldr	r9, =(L2COQM_S_ALL | L2COQM_CW_FLAG | L2COQM_CM_WBINV)
+		ldr	r1, =L2C_ADDR(L2COQM)
+		ldr	r2, =L2C_ADDR(L2COPPQSEF)
+1:		str	r9, [r1]	/* clean and invalidate L2 cache */
+		ldr	r3, [r2]
+		tst	r3, #(L2COPPQSEF_FE | L2COPPQSEF_OE)
+		bne	1b
+
+		ldr	r9, =L2C_ADDR(L2COQS)
+		lsr	r3, r3, #8
+		and	r3, r3, #3
+		lsl	r3, r3, #2
+		add	r9, r9, r3
+2:		ldr	r1, [r9]
+		tst	r1, #L2COQS_EF	/* wait until complete */
+		beq	2b
+		mov	r1, #L2COQS_EF
+		str	r1, [r9]
+3:		ldr	r1, =L2C_ADDR(L2COSYNC)
+		mov	r9, #L2COSYNC_CM
+		str	r9, [r1]
+		ldr	r9, [r1]
+		ldr	r1, =L2C_ADDR(L2COPE)
+		mov	r9, #L2COPE_CM_FLSH_PFBUF
+		str	r9, [r1]
+		ldr	r9, [r1]
+		dsb
+#endif /* CONFIG_MACH_GERDAC && CONFIG_MN_L2CACHE_ENABLE */
 		mov	pc, lr
 
 __armv5tej_mmu_cache_flush:
diff -uNr linux-3.14.19/arch/arm/boot/dts/Makefile linux-gerda/arch/arm/boot/dts/Makefile
--- linux-3.14.19/arch/arm/boot/dts/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/Makefile	2017-06-22 09:52:11.707040473 +0900
@@ -77,6 +77,9 @@
 	exynos5420-smdk5420.dtb \
 	exynos5440-sd5v1.dtb \
 	exynos5440-ssdk5440.dtb
+dtb-$(CONFIG_ARCH_GERDA) += gerda3-dd.dtb \
+	gerda3-dl.dtb \
+	gerdac-hwe.dtb
 dtb-$(CONFIG_ARCH_HI3xxx) += hi3620-hi4511.dtb
 dtb-$(CONFIG_ARCH_HIGHBANK) += highbank.dtb \
 	ecx-2000.dtb
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerda3-dd.dts linux-gerda/arch/arm/boot/dts/gerda3-dd.dts
--- linux-3.14.19/arch/arm/boot/dts/gerda3-dd.dts	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerda3-dd.dts	2017-06-22 09:52:11.535040478 +0900
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "gerda3.dtsi"
+
+/ {
+	compatible = "panasonic,gerda3-dd";
+
+	chosen {
+		/* for debug: debug user_debug=31 */
+		bootargs = "console=ttyS0,115200 root=/dev/mtdblock0 slram=mtd0,0x58a00000,+0x00600000";
+	};
+
+	memory@58000000 {
+		device_type = "memory";
+		reg = <0x58000000 0x00a00000>; /* SDRAM: 16 MB - 6 MB */
+	};
+
+};
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerda3-dl.dts linux-gerda/arch/arm/boot/dts/gerda3-dl.dts
--- linux-3.14.19/arch/arm/boot/dts/gerda3-dl.dts	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerda3-dl.dts	2017-06-22 09:52:11.535040478 +0900
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "gerda3.dtsi"
+
+/ {
+	compatible = "panasonic,gerda3-dl";
+
+	chosen {
+		/* for debug: debug user_debug=31 */
+		bootargs = "console=ttyS0,115200 root=/dev/mtdblock0 slram=mtd0,0x59a00000,+0x00600000";
+	};
+
+	memory@58000000 {
+		device_type = "memory";
+		reg = <0x58000000 0x01a00000>; /* SDRAM: 32 MB - 6 MB */
+	};
+
+	norflash0: mn_nor@0 {
+		compatible = "panasonic,mn-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0x20000000 0x02000000>,
+		      <0x9c040e00 0x0400>,
+		      <0x9c042700 0x0200>,
+		      <0x9c040000 0x0200>;
+		num-cs = <0>;
+		type = "s25fl256s0";
+		partition@0 {
+			label = "filesystem@0";
+			reg = <0x00000000 0x02000000>;
+		};
+	};
+
+	norflash1: mn_nor@1 {
+		status = "disabled";
+		compatible = "panasonic,mn-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0x30000000 0x04000000>,
+		      <0x9c040e00 0x0400>,
+		      <0x9c042700 0x0200>,
+		      <0x9c040000 0x0200>;
+		num-cs = <1>;
+		type = "s25fl256s0";
+		partition@0 {
+			label = "filesystem@1";
+			reg = <0x00000000 0x01800000>;
+		};
+		partition@1 {
+			label = "kernel@1";
+			reg = <0x01800000 0x00800000>;
+			read-only;
+		};
+	};
+
+	norflash2: mn_nor@2 {
+		/* status = "disabled"; */
+		compatible = "panasonic,mn-nor";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		reg = <0x40000000 0x02000000>,
+		      <0x9c040e00 0x0400>,
+		      <0x9c042700 0x0200>,
+		      <0x9c040000 0x0200>;
+		num-cs = <2>;
+		type = "s25fl256s0";
+		partition@0 {
+			label = "filesystem@2";
+			reg = <0x00000000 0x01800000>;
+		};
+		partition@1 {
+			label = "kernel@2";
+			reg = <0x01800000 0x00800000>;
+			read-only;
+		};
+	};
+};
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerda3.dtsi linux-gerda/arch/arm/boot/dts/gerda3.dtsi
--- linux-3.14.19/arch/arm/boot/dts/gerda3.dtsi	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerda3.dtsi	2017-06-22 09:52:11.511040479 +0900
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * Based on "omap4.dtsi"
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#include "skeleton.dtsi"
+
+/ {
+	compatible = "panasonic,gerda3";
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <0>;
+		};
+	};
+
+	l2: l2-cache@611c0000 {
+		compatible = "panasonic,l2-system-cache";
+		reg = <0x611c0000 0x1000>,
+		      <0x610c0000 0x2000>,
+		      <0x612c0000 0x1000>;
+	};
+
+	gic: interrupt-controller@60001000 {
+		compatible = "arm,cortex-a9-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = <0x60001000 0x1000>,
+		      <0x60000100 0x100>;
+	};
+
+	memory@54000000 {
+		device_type = "memory";
+		reg = <0x54000000 0x00800000>; /* eDRAM: 8 MB */
+	};
+
+	local_timer: timer@60000600 {
+		compatible = "arm,cortex-a9-twd-timer";
+		reg = <0x60000600 0x20>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>;
+		clocks = <&arm_periph_clk>;
+	};
+
+	uart2: serial@9c01c200 {
+		compatible = "panasonic,mn-uart";
+		fifo-size = <8>;
+		reg = <0x9c01c200 0x100>;
+		interrupts = <GIC_SPI 93 IRQ_TYPE_EDGE_RISING>;
+		clocks = <&gerda_pclk>;
+	};
+
+	timer1616_1617: timer@9c013400 {
+		compatible = "panasonic,gerda-timer";
+		reg = <0x9c013400 0x80>;
+		clocks = <&gerda_pclk>;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		arm_periph_clk: dummy200m {
+			compatible = "fixed-clock";
+			clock-frequency = <200000000>;
+			#clock-cells = <0>;
+		};
+
+		gerda_pclk: dummy100m {
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+			#clock-cells = <0>;
+		};
+	};
+};
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerdac-hwe.dts linux-gerda/arch/arm/boot/dts/gerdac-hwe.dts
--- linux-3.14.19/arch/arm/boot/dts/gerdac-hwe.dts	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerdac-hwe.dts	2017-06-22 09:52:11.523040479 +0900
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+/dts-v1/;
+
+#include "gerdac.dtsi"
+
+/ {
+	compatible = "panasonic,gerdac-hwe";
+
+	chosen {
+		/* for debug: debug user_debug=31 */
+		bootargs = "console=ttyS0,460800 root=/dev/mtdblock0 slram=mtd0,0xbf000000,+0x01000000 lpj=11116544";
+	};
+
+	memory@a0000000 {
+		device_type = "memory";
+		reg = <0xa0000000 0x1f000000>; /* SDRAM: 512MB - 16MB */
+	};
+
+	uart2: serial@9c05c000 {
+		compatible = "panasonic,mn-uart";
+		fifo-size = <8>;
+		reg = <0x9c05c000 0x100>;
+		interrupts = <GIC_SPI 104 IRQ_TYPE_EDGE_RISING>;
+		clocks = <&gerda_pclk>;
+	};
+
+	uart5: serial@9c01c300 {
+		compatible = "panasonic,mn-sioext";
+		fifo-size = <64>;
+		reg = <0x9c01c300 0x100>;
+		interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH
+			      GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "tx", "rx";
+		clocks = <&gerda_pclk>;
+	};
+};
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerdac.dts linux-gerda/arch/arm/boot/dts/gerdac.dts
--- linux-3.14.19/arch/arm/boot/dts/gerdac.dts	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerdac.dts	2017-06-22 09:52:11.703040473 +0900
@@ -0,0 +1,31 @@
+
+/dts-v1/;
+
+#include "gerdac.dtsi"
+#include "gerdac_config.dtsi"
+
+/ {
+	compatible = "panasonic,gerdac-hwe";
+
+	uart4: serial@9c01c200 {
+		compatible = "panasonic,mn-uart";
+		fifo-size = <8>;
+		reg = <0x9c01c200 0x100>;
+		interrupts = <GIC_SPI 101 IRQ_TYPE_EDGE_RISING>;
+		clocks = <&gerda_pclk>;
+	};
+
+	uart5: serial@9c01c300 {
+		compatible = "panasonic,mn-sioext";
+		fifo-size = <64>;
+		timeout = <1>;
+		reg = <0x9c01c300 0x100>;
+		interrupts = <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH
+			      GIC_SPI 103 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-names = "tx", "rx";
+		clocks = <&gerda_pclk>;
+		auto-flow-control;
+		force-auto-flow-control;
+		cts-gpio-number=<81>;
+	};
+};
diff -uNr linux-3.14.19/arch/arm/boot/dts/gerdac.dtsi linux-gerda/arch/arm/boot/dts/gerdac.dtsi
--- linux-3.14.19/arch/arm/boot/dts/gerdac.dtsi	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/boot/dts/gerdac.dtsi	2017-06-22 09:52:11.711040473 +0900
@@ -0,0 +1,82 @@
+/*
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * Based on "omap4.dtsi"
+ */
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+#include "skeleton.dtsi"
+
+/ {
+	compatible = "panasonic,gerdac";
+	interrupt-parent = <&gic>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a9";
+			reg = <1>;
+		};
+	};
+
+	l2: l2-cache@610c0000 {
+		compatible = "panasonic,l2-system-cache";
+		reg = <0x610c0000 0x1000>,
+		      <0x610c0000 0x2000>,
+		      <0x610c0000 0x1000>;
+	};
+
+	gic: interrupt-controller@60001000 {
+		compatible = "arm,cortex-a9-gic";
+		interrupt-controller;
+		#interrupt-cells = <3>;
+		reg = <0x60001000 0x1000>,
+		      <0x60000100 0x100>;
+	};
+
+	local_timer: timer@60000600 {
+		compatible = "arm,cortex-a9-twd-timer";
+		reg = <0x60000600 0x20>;
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) | IRQ_TYPE_LEVEL_HIGH)>;
+		clocks = <&arm_periph_clk>;
+	};
+
+	timer1616_1617: timer@9c053400 {
+		compatible = "panasonic,gerda-timer";
+		reg = <0x9c053400 0x80>;
+		clocks = <&gerda_pclk>;
+	};
+
+	clocks {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		arm_periph_clk: aclk {
+			compatible = "fixed-clock";
+			clock-frequency = <50000000>;
+			#clock-cells = <0>;
+		};
+
+		gerda_pclk: pclk {
+			compatible = "fixed-clock";
+			clock-frequency = <100000000>;
+			#clock-cells = <0>;
+		};
+	};
+
+	gerda_fb: framebuffer@A2600000 {
+		compatible = "simple-framebuffer";
+		reg = <0xA2600000 (800 * 480 * 2)>;
+		width = <800>;
+		height = <480>;
+		stride = <(800 * 2)>;
+		format = "r5g6b5";
+	};
+};
diff -uNr linux-3.14.19/arch/arm/configs/gerda3_defconfig linux-gerda/arch/arm/configs/gerda3_defconfig
--- linux-3.14.19/arch/arm/configs/gerda3_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/configs/gerda3_defconfig	2017-06-22 09:52:13.395040423 +0900
@@ -0,0 +1,91 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_LOG_BUF_SHIFT=18
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODVERSIONS=y
+# CONFIG_LBDAF is not set
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_MSDOS_PARTITION is not set
+# CONFIG_EFI_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_GERDA=y
+CONFIG_MACH_GERDA3=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_HZ_250=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_COMPACTION is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_ATAGS is not set
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_BINFMT_SCRIPT is not set
+# CONFIG_SUSPEND is not set
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_MTD=y
+# CONFIG_MTD_OF_PARTS is not set
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_SLRAM=y
+CONFIG_PROC_DEVICETREE=y
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTY_COUNT=0
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_MN=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_HWMON is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+# CONFIG_IOMMU_SUPPORT is not set
+# CONFIG_DNOTIFY is not set
+# CONFIG_INOTIFY_USER is not set
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+CONFIG_DEBUG_KERNEL=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+CONFIG_KEYS=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
diff -uNr linux-3.14.19/arch/arm/configs/gerdac_normal_defconfig linux-gerda/arch/arm/configs/gerdac_normal_defconfig
--- linux-3.14.19/arch/arm/configs/gerdac_normal_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/configs/gerdac_normal_defconfig	2017-06-22 09:52:13.395040423 +0900
@@ -0,0 +1,195 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_RD_GZIP is not set
+CONFIG_RD_LZO=y
+CONFIG_EXPERT=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_GERDA=y
+CONFIG_SHARED_GIC=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_HZ_250=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_COMPACTION is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_ATAGS is not set
+CONFIG_BOOT_SET_ZRELADDR=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_CFG80211=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_MN_NOR=y
+CONFIG_MTD_SLRAM=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_RAID_ATTRS=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTY_COUNT=0
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_MN=y
+CONFIG_SERIAL_SIOEXT_MN=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MN=y
+CONFIG_I2C_MN_CH3=y
+CONFIG_I2C_MN_CH3_400KHZ=y
+# CONFIG_HWMON is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_FB=y
+CONFIG_FB_SIMPLE=y
+CONFIG_USB=y
+# CONFIG_USB_PANASONIC_SINGLE_HOST is not set
+CONFIG_USB_PANASONIC_GPIO_FOR_VBUS=y
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=m
+CONFIG_USB_PANASONIC=m
+CONFIG_USB_CARPLAY=m
+CONFIG_USB_IAP2=m
+CONFIG_USB_ZERO=m
+CONFIG_MMC=y
+CONFIG_MMC_GERDAC=y
+CONFIG_MMC_USE_SDIOSLOT=y
+# CONFIG_ARM_ARCH_TIMER_EVTSTREAM is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_FANOTIFY=y
+CONFIG_FUSE_FS=y
+CONFIG_CUSE=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_ROOT_NFS=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
+CONFIG_MTD_UBI=y
+CONFIG_UBIFS_FS=y
diff -uNr linux-3.14.19/arch/arm/configs/gerdac_vup_defconfig linux-gerda/arch/arm/configs/gerdac_vup_defconfig
--- linux-3.14.19/arch/arm/configs/gerdac_vup_defconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/configs/gerdac_vup_defconfig	2017-06-22 09:52:13.383040423 +0900
@@ -0,0 +1,187 @@
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_KERNEL_LZO=y
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_FHANDLE=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_IRQ_TIME_ACCOUNTING=y
+CONFIG_BSD_PROCESS_ACCT=y
+CONFIG_BSD_PROCESS_ACCT_V3=y
+CONFIG_LOG_BUF_SHIFT=18
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_PID_NS is not set
+CONFIG_BLK_DEV_INITRD=y
+# CONFIG_RD_GZIP is not set
+CONFIG_RD_LZO=y
+CONFIG_EXPERT=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+# CONFIG_BLK_DEV_BSG is not set
+CONFIG_PARTITION_ADVANCED=y
+# CONFIG_EFI_PARTITION is not set
+CONFIG_CMDLINE_PARTITION=y
+# CONFIG_IOSCHED_CFQ is not set
+CONFIG_ARCH_GERDA=y
+CONFIG_SHARED_GIC=y
+# CONFIG_SWP_EMULATE is not set
+CONFIG_SMP=y
+CONFIG_HAVE_ARM_ARCH_TIMER=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_HZ_250=y
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_COMPACTION is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=65536
+# CONFIG_CROSS_MEMORY_ATTACH is not set
+# CONFIG_ATAGS is not set
+CONFIG_BOOT_SET_ZRELADDR=y
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_MULTIPLE_DRIVERS=y
+CONFIG_VFP=y
+CONFIG_NEON=y
+CONFIG_KERNEL_MODE_NEON=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+# CONFIG_SUSPEND is not set
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_NET_KEY_MIGRATE=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+CONFIG_IPV6=y
+CONFIG_IPV6_ROUTER_PREF=y
+CONFIG_IPV6_ROUTE_INFO=y
+CONFIG_IPV6_OPTIMISTIC_DAD=y
+CONFIG_INET6_AH=m
+CONFIG_INET6_ESP=m
+CONFIG_INET6_IPCOMP=m
+CONFIG_IPV6_MIP6=m
+CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION=m
+CONFIG_IPV6_SIT_6RD=y
+CONFIG_IPV6_GRE=m
+CONFIG_IPV6_MULTIPLE_TABLES=y
+CONFIG_IPV6_SUBTREES=y
+CONFIG_NETFILTER=y
+CONFIG_CFG80211=y
+CONFIG_CFG80211_WEXT=y
+CONFIG_MAC80211=y
+CONFIG_RFKILL=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_STANDALONE is not set
+CONFIG_MTD=y
+CONFIG_MTD_CMDLINE_PARTS=y
+CONFIG_MTD_BLOCK=y
+CONFIG_MTD_MN_NOR=y
+CONFIG_MTD_SLRAM=y
+CONFIG_PROC_DEVICETREE=y
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_RAID_ATTRS=y
+CONFIG_SCSI=y
+CONFIG_BLK_DEV_SD=y
+CONFIG_SCSI_MULTI_LUN=y
+CONFIG_SCSI_SCAN_ASYNC=y
+CONFIG_NETDEVICES=y
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_CADENCE is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_CIRRUS is not set
+# CONFIG_NET_VENDOR_FARADAY is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+CONFIG_SMSC911X=y
+# CONFIG_NET_VENDOR_STMICRO is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_USB_USBNET=y
+# CONFIG_USB_NET_AX8817X is not set
+# CONFIG_USB_NET_AX88179_178A is not set
+# CONFIG_USB_NET_CDCETHER is not set
+# CONFIG_USB_NET_NET1080 is not set
+# CONFIG_USB_NET_CDC_SUBSET is not set
+# CONFIG_USB_NET_ZAURUS is not set
+# CONFIG_RTL_CARDS is not set
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_DEVPTS_MULTIPLE_INSTANCES=y
+CONFIG_LEGACY_PTY_COUNT=0
+# CONFIG_DEVKMEM is not set
+CONFIG_SERIAL_8250=y
+# CONFIG_SERIAL_8250_DEPRECATED_OPTIONS is not set
+CONFIG_SERIAL_8250_CONSOLE=y
+CONFIG_SERIAL_8250_MN=y
+CONFIG_SERIAL_SIOEXT_MN=y
+# CONFIG_HW_RANDOM is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_MN=y
+CONFIG_I2C_MN_CH3=y
+CONFIG_I2C_MN_CH3_400KHZ=y
+# CONFIG_HWMON is not set
+CONFIG_SOUND=y
+CONFIG_SND=y
+CONFIG_SND_SEQUENCER=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_SEQUENCER_OSS=y
+CONFIG_SND_USB_AUDIO=y
+CONFIG_USB=y
+# CONFIG_USB_PANASONIC_SINGLE_HOST is not set
+CONFIG_USB_PANASONIC_GPIO_FOR_VBUS=y
+CONFIG_USB_EHCI_HCD=m
+CONFIG_USB_EHCI_ROOT_HUB_TT=y
+CONFIG_USB_STORAGE=y
+CONFIG_USB_GADGET=m
+CONFIG_USB_PANASONIC=m
+CONFIG_USB_CARPLAY=m
+CONFIG_USB_ZERO=m
+CONFIG_MMC=y
+CONFIG_MMC_GERDAC=y
+CONFIG_MMC_USE_SDIOSLOT=y
+# CONFIG_ARM_ARCH_TIMER_EVTSTREAM is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_EXT2_FS=y
+CONFIG_EXT4_FS=y
+CONFIG_FANOTIFY=y
+CONFIG_VFAT_FS=y
+CONFIG_TMPFS=y
+CONFIG_TMPFS_POSIX_ACL=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_XZ=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V4=y
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_CODEPAGE_932=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_NLS_UTF8=y
+CONFIG_PRINTK_TIME=y
+CONFIG_BOOT_PRINTK_DELAY=y
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+# CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_UNUSED_SYMBOLS=y
+CONFIG_DEBUG_FS=y
+CONFIG_LOCKUP_DETECTOR=y
+# CONFIG_SCHED_DEBUG is not set
+# CONFIG_FTRACE is not set
+CONFIG_DEBUG_USER=y
+# CONFIG_XZ_DEC_ARM is not set
+# CONFIG_XZ_DEC_ARMTHUMB is not set
diff -uNr linux-3.14.19/arch/arm/include/asm/cache.h linux-gerda/arch/arm/include/asm/cache.h
--- linux-3.14.19/arch/arm/include/asm/cache.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/include/asm/cache.h	2017-06-22 09:52:12.055040463 +0900
@@ -7,6 +7,11 @@
 #define L1_CACHE_SHIFT		CONFIG_ARM_L1_CACHE_SHIFT
 #define L1_CACHE_BYTES		(1 << L1_CACHE_SHIFT)
 
+#ifdef CONFIG_MN_HAS_L2CA
+#define L2_CACHE_SHIFT		7
+#define L2_CACHE_BYTES		(1 << L2_CACHE_SHIFT)
+#define cache_line_size()	L2_CACHE_BYTES
+#endif /* CONFIG_MN_HAS_L2CA */
 /*
  * Memory returned by kmalloc() may be used for DMA, so we must make
  * sure that all such allocations are cache aligned. Otherwise,
@@ -14,7 +19,11 @@
  * cache before the transfer is done, causing old data to be seen by
  * the CPU.
  */
+#if defined(L2_CACHE_BYTES) && (L1_CACHE_BYTES < L2_CACHE_BYTES)
+#define ARCH_DMA_MINALIGN	L2_CACHE_BYTES
+#else
 #define ARCH_DMA_MINALIGN	L1_CACHE_BYTES
+#endif
 
 /*
  * With EABI on ARMv5 and above we must have 64-bit aligned slab pointers.
diff -uNr linux-3.14.19/arch/arm/include/asm/pgalloc.h linux-gerda/arch/arm/include/asm/pgalloc.h
--- linux-3.14.19/arch/arm/include/asm/pgalloc.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/include/asm/pgalloc.h	2017-06-22 09:52:12.063040462 +0900
@@ -132,10 +132,17 @@
 				  pmdval_t prot)
 {
 	pmdval_t pmdval = (pte + PTE_HWTABLE_OFF) | prot;
+#ifdef CONFIG_ARM_ERRATA_782773
+	set_pmd(&pmdp[0], __pmd(pmdval));
+#ifndef CONFIG_ARM_LPAE
+	set_pmd(&pmdp[1], __pmd(pmdval + 256 * sizeof(pte_t)));
+#endif
+#else /* CONFIG_ARM_ERRATA_782773 */
 	pmdp[0] = __pmd(pmdval);
 #ifndef CONFIG_ARM_LPAE
 	pmdp[1] = __pmd(pmdval + 256 * sizeof(pte_t));
 #endif
+#endif /* CONFIG_ARM_ERRATA_782773 */
 	flush_pmd_entry(pmdp);
 }
 
diff -uNr linux-3.14.19/arch/arm/include/asm/pgtable-2level.h linux-gerda/arch/arm/include/asm/pgtable-2level.h
--- linux-3.14.19/arch/arm/include/asm/pgtable-2level.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/include/asm/pgtable-2level.h	2017-06-22 09:52:11.943040466 +0900
@@ -164,19 +164,37 @@
 #define pmd_large(pmd)		(pmd_val(pmd) & 2)
 #define pmd_bad(pmd)		(pmd_val(pmd) & 2)
 
+#ifdef CONFIG_ARM_ERRATA_782773
+#define copy_pmd(pmdpd,pmdps)			\
+	do {					\
+		set_pmd(&pmdpd[0], pmdps[0]);	\
+		set_pmd(&pmdpd[1], pmdps[1]);	\
+		flush_pmd_entry(pmdpd);		\
+	} while (0)
+#else /* CONFIG_ARM_ERRATA_782773 */
 #define copy_pmd(pmdpd,pmdps)		\
 	do {				\
 		pmdpd[0] = pmdps[0];	\
 		pmdpd[1] = pmdps[1];	\
 		flush_pmd_entry(pmdpd);	\
 	} while (0)
+#endif /* CONFIG_ARM_ERRATA_782773 */
 
+#ifdef CONFIG_ARM_ERRATA_782773
+#define pmd_clear(pmdp)				\
+	do {					\
+		set_pmd(&pmdp[0], __pmd(0));	\
+		set_pmd(&pmdp[1], __pmd(0));	\
+		clean_pmd_entry(pmdp);	    	\
+	} while (0)
+#else /* CONFIG_ARM_ERRATA_782773 */
 #define pmd_clear(pmdp)			\
 	do {				\
 		pmdp[0] = __pmd(0);	\
 		pmdp[1] = __pmd(0);	\
 		clean_pmd_entry(pmdp);	\
 	} while (0)
+#endif /* CONFIG_ARM_ERRATA_782773 */
 
 /* we don't need complex calculations here as the pmd is folded into the pgd */
 #define pmd_addr_end(addr,end) (end)
diff -uNr linux-3.14.19/arch/arm/include/asm/pgtable.h linux-gerda/arch/arm/include/asm/pgtable.h
--- linux-3.14.19/arch/arm/include/asm/pgtable.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/include/asm/pgtable.h	2017-06-22 09:52:12.047040463 +0900
@@ -245,6 +245,26 @@
 	set_pte_ext(ptep, pteval, ext);
 }
 
+#ifdef CONFIG_ARM_ERRATA_782773
+static inline void set_pmd(pmd_t *pmdp, pmd_t pmdval)
+{
+	unsigned long flags;
+
+	asm volatile(
+	"	mrs	%0, cpsr		@ local_irq_save\n"
+	"	cpsid	i\n"
+#ifdef CONFIG_ARM_ERRATA_764369
+	"	dsb\n"
+#endif
+	"	mcr	p15, 0, %1, c7, c14, 1	@ clean & inv pmdp\n"
+	"	dsb\n"
+	"	str	%2, [%1]		@ *pmdp = pmdval\n"
+	"	dsb\n"
+	"	msr	cpsr_c, %0		@ local_irq_restore\n"
+	: "=&r" (flags) : "r" (pmdp), "r" (pmdval) : "memory", "cc");
+}
+#endif
+
 #define PTE_BIT_FUNC(fn,op) \
 static inline pte_t pte_##fn(pte_t pte) { pte_val(pte) op; return pte; }
 
diff -uNr linux-3.14.19/arch/arm/include/asm/rt3.h linux-gerda/arch/arm/include/asm/rt3.h
--- linux-3.14.19/arch/arm/include/asm/rt3.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/include/asm/rt3.h	2017-06-22 09:52:12.047040463 +0900
@@ -0,0 +1,482 @@
+/*
+ * rt3.h: rt3 trace log related definitions.
+ *
+ * Copyright (C) Panasonic Corporation
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef	_RT3_H_
+#define	_RT3_H_
+
+#include <linux/compiler.h>
+#ifndef __ASSEMBLY__
+#include <linux/irqflags.h>
+#include <linux/hardirq.h>
+#include <linux/sched.h>
+#include <linux/io.h>
+#endif
+
+#ifdef CONFIG_RT3_TRACE
+
+#define RT3_TRACE_BUFF_SIZE_IN_WORD \
+	((CONFIG_RT3_TRACE_BUFF_SIZE * 1024) / sizeof(u32))
+
+#define RT3_TRACE_DISABLE			0x00000010
+#define RT3_TRACE_ENABLE			0x00000011
+#define RT3_TRACE_USERLOG			0x00000012
+#define RT3_TRACE_USERLOG_EXT		0x00000022
+#define RT3_SYS_TRACE_RT3INFO		0x00000017
+#define RT3_SYS_TRACE_GETISR		0x00000019
+#define RT3_SYS_TRACE_GETBUF		0x00000018
+#define RT3_SYS_TRACE_GETNAME		0x00000021
+#define RT3_SYS_TRACE_INIT			0x00000023
+#define RT3_SYS_TRACE_GETPRI		0x00000024
+
+
+#define RT3_EVE_DISPATCH			0x87000000
+#define RT3_EVE_IRQ_ENTRY			0x01000000
+#define RT3_EVE_IRQ_EXIT			0x81000000
+
+#ifdef CONFIG_RT3_LOG_ISR
+#define RT3_EVE_ISR_ENTRY			0x02000000
+#define RT3_EVE_ISR_EXIT			0x82000000
+#endif
+
+#define RT3_EVE_LOG_ENABLE			0x0b000000
+#define RT3_EVE_LOG_DISABLE			0x9b000000
+#define RT3_EVE_USERLOG				0x09000000
+#define RT3_EVE_USERLOG8_24			0x99000000
+#define RT3_TRACE_SOFTIRQ_PID		0x8000	/* pseudo pid for softirq */
+#define RT3_TRACE_LOCAL_TIMER		0x8004
+#define RT3_TRACE_DO_IPI			0x8008
+#define RT3_TIME_STAMP				100000000
+#define RT3_TRACE_TIMESTAMP_SHIFT	4
+
+
+#ifndef /*************************/ __ASSEMBLY__ /*************************/
+
+typedef struct obs_fname_info {
+	ulong	pid;
+	char	name[32];
+} OBS_FNAME_INFO;
+extern u32 gerda_timer_read_rt3(void);
+
+
+typedef struct	obs_tsk_info {
+	u32		tid;
+	u32		tskstat;
+	u32		tskpri;
+	u32		tskwait;
+	u32		wobjid;
+	u32		task;
+	u32		mode;
+} OBS_TSK_INFO;
+
+typedef struct rt3_info_t {
+	u32		linux_smp;
+	u32		softirq_pid;
+	u32		buff;
+	u32		buffsize;
+	u32		ptr;
+	u32		ovrflw;
+	u32		enabled;
+	u32		timer_cycle;
+} rt3_info;
+
+typedef struct rt3_getlog_t {
+	u32		ptr;
+	u32		logid;
+	u32		val;
+	u32		ts;
+	u32		val2;
+} rt3_getlog;
+
+extern u32 rt3_trace(int log_id, int info, int *exinfo);
+
+#define _TRC_usr_log(info) \
+	rt3_trace(RT3_TRACE_USERLOG, info, NULL)
+
+#define _TRC_usr_log_ext(info1, info2) \
+	rt3_trace(RT3_TRACE_USERLOG_EXT, (int)(info1), (int *)(info2))
+
+#ifdef CONFIG_RT3_TRACE_DO_ENABLE
+#define rt3_trace_is_enabled()	1	/* always enabled */
+#define rt3_trace_enable()		do { } while (0)
+#define rt3_trace_disable()		do { } while (0)
+#define _TRC_sta_log()
+#define _TRC_stp_log()
+#else	/* CONFIG_RT3_TRACE_DO_ENABLE */
+extern volatile int rt3_linux_trace_enabled;
+#define _TRC_sta_log() \
+	rt3_trace(RT3_TRACE_ENABLE, 0, NULL)
+
+#define _TRC_stp_log() \
+	rt3_trace(RT3_TRACE_DISABLE, 0, NULL)
+
+#define rt3_trace_is_enabled()	rt3_linux_trace_enabled
+#define rt3_trace_enable() \
+	do { rt3_linux_trace_enabled = 1; } while (0)
+#define rt3_trace_disable() \
+	do { rt3_linux_trace_enabled = 0; } while (0)
+#endif	/* CONFIG_RT3_TRACE_DO_ENABLE */
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+extern u32 rt3_linux_trace_buff[];
+extern volatile u32 *rt3_linux_trace_buff_ptr;
+extern volatile int rt3_linux_trace_buff_ovrflw;
+extern void rt3_log_event(u32 data);
+#else /* CONFIG_RT3_TRACE_LOG_ON_MEM */
+#define rt3_log_event(data)					\
+do {													\
+	*((volatile u32 *)0x60205000) = (u32)(data);		\
+} while (0)
+#endif /* CONFIG_RT3_TRACE_LOG_ON_MEM */
+
+/*
+ * rt3_log_xxx_event() functions must be used
+ * in interrupt disabled context for the consistency of the time-stamp.
+ */
+
+
+/**
+ * @brief rt3_time_get
+ *
+ * It calls the rt3 log event to implement its function.
+ * @return time 16bit downcounter
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static unsigned int rt3_time_get(void)
+{
+	static unsigned int time;
+	time = 0x00FFFF00 & (gerda_timer_read_rt3()  << (8-RT3_TRACE_TIMESTAMP_SHIFT));
+	return time;
+}
+
+/**
+ * @brief rt3_log_dispatch_event
+ *
+ * It calls the rt3_log_dispatch_event to implement its function.
+ *
+ * @param  ppid   [in]  pid_t      Prev task id.
+ * @param  npid   [in]  pid_t      New task id.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_dispatch_event(pid_t ppid, pid_t npid)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_DISPATCH |
+		rt3_time_get());
+		rt3_log_event(0xffff & ppid);
+	}
+	raw_local_irq_restore(flags);
+}
+
+/**
+ * @brief rt3_log_irq_entry_event
+ *
+ * It calls the handle_IRQ to implement its function.
+ *
+ * @param  ims   [in]  int      Intterrupt mask level.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_irq_entry_event(int ims)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_IRQ_ENTRY |
+		rt3_time_get() | (0xff & ims));
+	}
+	raw_local_irq_restore(flags);
+}
+
+/**
+ * @brief rt3_log_irq_exit_event
+ *
+ * It calls the handle_IRQ to implement its function.
+ *
+ * @param  ims   [in]  int      Intterrupt mask level.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_irq_exit_event(int ims)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_IRQ_EXIT |
+		rt3_time_get() | (0xff & ims));
+	}
+	raw_local_irq_restore(flags);
+}
+
+#ifdef CONFIG_RT3_LOG_ISR
+/**
+ * @brief rt3_log_isr_entry_event
+ *
+ * It calls the handle_irq_event_percpu to implement its function.
+ *
+ * @param  isrid_intno   [in]  int   Intterrupt mask level.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+static inline void rt3_log_isr_entry_event(int isrid_intno)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_ISR_ENTRY |
+			rt3_time_get() | 0x00);
+		rt3_log_event(isrid_intno);
+	}
+	raw_local_irq_restore(flags);
+}
+
+/**
+ * @brief rt3_log_isr_exit_event
+ *
+ * It calls the handle_irq_event_percpu to implement its function.
+ *
+ * @param  ims   [in]  int      Intterrupt mask level.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_isr_exit_event(int isrid_intno)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_ISR_EXIT |
+			rt3_time_get() | 0x00);
+		rt3_log_event(isrid_intno);
+	}
+	raw_local_irq_restore(flags);
+}
+#endif /* CONFIG_RT3_LOG_ISR */
+
+
+#ifdef CONFIG_RT3_LOG_EXIT_TRACE_LOG
+struct rt3_trace_exit_struct {
+	pid_t pid;
+	char comm[TASK_COMM_LEN];
+	long code;
+};
+
+extern struct rt3_trace_exit_struct rt3_exit_log_table[CONFIG_RT3_LOG_EXIT_TRACE_LOG_NUM];
+extern volatile int rt3_exit_log_cnt;
+extern volatile int rt3_exit_log_index;
+
+/**
+ * @brief rt3_log_process_exit_event
+ *
+ * It calls the handle_irq_event_percpu to implement its function.
+ *
+ * @param  tsk   [out]  *task_struct      task contorol block.
+ * @param  code   [in]  long             error code.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_process_exit_event(struct task_struct *tsk, long code)
+{
+	unsigned long flags;
+
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_exit_log_table[rt3_exit_log_index].pid = tsk->pid;
+		memcpy(rt3_exit_log_table[rt3_exit_log_index].comm, tsk->comm, TASK_COMM_LEN);
+		rt3_exit_log_table[rt3_exit_log_index].code = code;
+
+		if (rt3_exit_log_index < (CONFIG_RT3_LOG_EXIT_TRACE_LOG_NUM - 1)) {
+			rt3_exit_log_index++;
+		} else {
+			rt3_exit_log_index = 0;
+		}
+
+		if (rt3_exit_log_cnt < (CONFIG_RT3_LOG_EXIT_TRACE_LOG_NUM))
+			rt3_exit_log_cnt++;
+	}
+	raw_local_irq_restore(flags);
+
+}
+#endif /* CONFIG_RT3_EXIT_TRACE_LOG */
+
+/**
+ * @brief rt3_log_user_event
+ *
+ * It calls the _TRC_usr_log to implement its function.
+ *
+ * @param  info  [in]  int   logdata.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_user_event(int info)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_USERLOG |
+			rt3_time_get() | (info&0xff));
+	}
+	raw_local_irq_restore(flags);
+}
+
+/**
+ * @brief rt3_log_user8_24_event
+ *
+ * It calls the _TRC_usr_log_ext to implement its function.
+ *
+ * @param  info1  [in]  int   logdata1.
+ * @param  info2  [in]  int   logdata2.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static inline void rt3_log_user8_24_event(int info1, int info2)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_USERLOG8_24 |
+			rt3_time_get() | (0xff & info1));
+		rt3_log_event(0xff & (info2 >> 24));
+		rt3_log_event(0xffffff & info2);
+	}
+	raw_local_irq_restore(flags);
+}
+
+
+#ifndef CONFIG_RT3_TRACE_DO_ENABLE
+/**
+ * @brief rt3_log_enable_event
+ *
+ * It calls the rt3_log_enable_event to implement its function.
+ *
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+static inline void rt3_log_enable_event(void)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(!rt3_trace_is_enabled())) {
+		rt3_trace_enable();
+		rt3_log_event(RT3_EVE_LOG_ENABLE |
+			rt3_time_get());
+	}
+	raw_local_irq_restore(flags);
+}
+
+/**
+ * @brief rt3_log_enable_event
+ *
+ * It calls the rt3_log_disable_event to implement its function.
+ *
+ * @param  info1  [in]  int   logdata1.
+ * @param  info2  [in]  int   logdata2.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+static inline void rt3_log_disable_event(pid_t pid)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+	if (likely(rt3_trace_is_enabled())) {
+		rt3_log_event(RT3_EVE_LOG_DISABLE |
+			rt3_time_get());
+		rt3_log_event(0xffff & pid);
+		rt3_trace_disable();
+	}
+	raw_local_irq_restore(flags);
+}
+#endif /* !CONFIG_RT3_TRACE_DO_ENABLE */
+/**
+ * @brief rt3_trace_switch_to
+ *
+ * It calls the context_switch to implement its function.
+ *
+ * @param  prev  [in]  task_struct   prev task.
+ * @param  next  [in]  task_struct   next task.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+static inline void rt3_trace_switch_to(struct task_struct *prev, struct task_struct *next)
+{
+	rt3_log_dispatch_event(prev->pid, next->pid);
+}
+
+#endif /************************* __ASSEMBLY__ *************************/
+
+#else /* !CONFIG_RT3_TRACE */
+
+#ifndef /*************************/ __ASSEMBLY__ /*************************/
+
+#define rt3_trace_is_enabled()		0	/* always disabled */
+#define rt3_trace_enable()		do {} while (0)
+#define rt3_trace_disable()		do {} while (0)
+#define _TRC_sta_log()			do {} while (0)
+#define _TRC_stp_log()			do {} while (0)
+#define _TRC_usr_log(...)		do {} while (0)
+#define _TRC_usr_log_ext(...)		do {} while (0)
+
+#endif /************************* __ASSEMBLY__ *************************/
+
+#endif /* CONFIG_RT3_TRACE */
+
+#endif /* __RT3_H__ */
diff -uNr linux-3.14.19/arch/arm/kernel/Makefile linux-gerda/arch/arm/kernel/Makefile
--- linux-3.14.19/arch/arm/kernel/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/Makefile	2017-06-22 09:52:12.683040444 +0900
@@ -74,6 +74,9 @@
 CFLAGS_swp_emulate.o		:= -Wa,-march=armv7-a
 obj-$(CONFIG_HAVE_HW_BREAKPOINT)	+= hw_breakpoint.o
 
+obj-$(CONFIG_RT3_TRACE) += rt3.o
+obj-$(CONFIG_MN_EXPORT_RIM_DBGINFO) += riminfo.o
+
 obj-$(CONFIG_CPU_XSCALE)	+= xscale-cp0.o
 obj-$(CONFIG_CPU_XSC3)		+= xscale-cp0.o
 obj-$(CONFIG_CPU_MOHAWK)	+= xscale-cp0.o
diff -uNr linux-3.14.19/arch/arm/kernel/asm-offsets.c linux-gerda/arch/arm/kernel/asm-offsets.c
--- linux-3.14.19/arch/arm/kernel/asm-offsets.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/asm-offsets.c	2017-06-22 09:52:12.683040444 +0900
@@ -27,6 +27,11 @@
 #include <asm/hardware/cache-l2x0.h>
 #include <linux/kbuild.h>
 
+#ifdef CONFIG_MN_EXPORT_RIM_DBGINFO
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#endif
+
 /*
  * Make sure that the compiler and target are compatible.
  */
@@ -199,5 +204,28 @@
 #endif
   DEFINE(KVM_VTTBR,		offsetof(struct kvm, arch.vttbr));
 #endif
+
+#ifdef CONFIG_MN_EXPORT_RIM_DBGINFO
+  OFFSET(TASK_STATE, task_struct, state);
+  OFFSET(TASK_STACK, task_struct, stack);
+  OFFSET(TASK_TASKS, task_struct, tasks);
+  OFFSET(TASK_MM, task_struct, mm);
+  OFFSET(TASK_PID, task_struct, pid);
+  OFFSET(TASK_COMM, task_struct, comm);
+  OFFSET(TASK_RTPRIO, task_struct, rt_priority);
+  OFFSET(TASK_THREAD_GROUP, task_struct, thread_group);
+  BLANK();
+
+  OFFSET(MM_PGD, mm_struct, pgd);
+  BLANK();
+
+  DEFINE(SIZE_IRQDESC, sizeof(struct irq_desc));
+  OFFSET(IRQDESC_ACTION, irq_desc, action);
+  OFFSET(IRQACTION_NAME, irqaction, name);
+  OFFSET(IRQACTION_NEXT, irqaction, next);
+
+  BLANK();
+#endif /* CONFIG_MN_EXPORT_RIM_DBGINFO */
+
   return 0; 
 }
diff -uNr linux-3.14.19/arch/arm/kernel/entry-common.S linux-gerda/arch/arm/kernel/entry-common.S
--- linux-3.14.19/arch/arm/kernel/entry-common.S	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/entry-common.S	2017-06-22 09:52:12.683040444 +0900
@@ -90,6 +90,9 @@
 	adrne	lr, BSYM(1f)
 	movne	pc, r5
 1:	get_thread_info tsk
+#ifdef CONFIG_KMC_NO_USER_PATCH
+        bl      __kmc_mlock
+#endif
 	b	ret_slow_syscall
 ENDPROC(ret_from_fork)
 
diff -uNr linux-3.14.19/arch/arm/kernel/irq.c linux-gerda/arch/arm/kernel/irq.c
--- linux-3.14.19/arch/arm/kernel/irq.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/irq.c	2017-06-22 09:52:12.683040444 +0900
@@ -42,6 +42,11 @@
 #include <asm/mach/irq.h>
 #include <asm/mach/time.h>
 
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_TRACE */
+
+
 unsigned long irq_err_count;
 
 int arch_show_interrupts(struct seq_file *p, int prec)
@@ -65,9 +70,16 @@
 void handle_IRQ(unsigned int irq, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs = set_irq_regs(regs);
+#ifdef CONFIG_RT3_TRACE
+	int pri = 0x10;
+#endif
 
 	irq_enter();
 
+#ifdef CONFIG_RT3_TRACE
+	rt3_log_irq_entry_event(pri);
+#endif
+
 	/*
 	 * Some hardware gives randomly wrong interrupts.  Rather
 	 * than crashing, do something sensible.
@@ -80,6 +92,10 @@
 		generic_handle_irq(irq);
 	}
 
+#ifdef CONFIG_RT3_TRACE
+	rt3_log_irq_exit_event(pri);
+#endif
+
 	irq_exit();
 	set_irq_regs(old_regs);
 }
diff -uNr linux-3.14.19/arch/arm/kernel/riminfo.S linux-gerda/arch/arm/kernel/riminfo.S
--- linux-3.14.19/arch/arm/kernel/riminfo.S	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/kernel/riminfo.S	2017-06-22 09:52:12.699040444 +0900
@@ -0,0 +1,72 @@
+/*
+ * riminfo.S: RIM information
+ *
+ * Copyright (C) Panasonic  Co., Ltd.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/asm-offsets.h>
+
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_TRACE */
+
+
+.macro RIMINFO symbol, value
+.global \symbol
+.equiv  \symbol, \value
+.endm
+
+	.text
+
+#ifdef CONFIG_SMP
+	RIMINFO RIM_KERNEL_LINUX_SMP,		0
+#else /* CONFIG_SMP */
+	RIMINFO RIM_KERNEL_LINUX_SMP,		0
+#endif /* CONFIG_SMP */
+
+#ifdef CONFIG_RT3_TRACE
+	RIMINFO RIM_VAL_TRACE_FREQ,		RT3_TIME_STAMP >> RT3_TRACE_TIMESTAMP_SHIFT
+#endif /* CONFIG_RT3_TRACE */
+
+	RIMINFO RIM_OFFSET_TASK_STATE,		TASK_STATE
+	RIMINFO RIM_OFFSET_TASK_THREADINFO,	TASK_THREADINFO
+	RIMINFO RIM_OFFSET_TASK_RT,		TASK_RT
+	RIMINFO RIM_OFFSET_TASK_TASKS,		TASK_TASKS
+	RIMINFO RIM_OFFSET_TASK_MM,		TASK_MM
+	RIMINFO RIM_OFFSET_TASK_PID,		TASK_PID
+	RIMINFO RIM_OFFSET_TASK_RTPRO,		TASK_RTPRIO
+	RIMINFO RIM_OFFSET_TASK_COMM,		TASK_COMM
+	RIMINFO RIM_OFFSET_TASK_THREAD,		TASK_THREAD
+	RIMINFO RIM_OFFSET_TASK_THREAD_GROUP	TASK_THREAD_GROUP
+	RIMINFO RIM_OFFSET_RTENTITY_RUNLIST,	RTENTITY_RUNLIST
+
+	RIMINFO RIM_OFFSET_THREAD_SP,		THREAD_SP
+	RIMINFO RIM_OFFSET_MM_PGD,		MM_PGD
+
+#ifdef CONFIG_SMP
+	RIMINFO RIM_WIDTH_PER_CPU_OFFSET,	0x04	/* */
+#endif /* CONFIG_SMP */
+
+	RIMINFO RIM_OFFSET_KNLSTK_PC,		0x04	/* */
+	RIMINFO RIM_OFFSET_KNLSTK_USP,		0x30	/* */
+
+	RIMINFO RIM_SIZE_IRQDESC,		SIZE_IRQDESC
+	RIMINFO RIM_OFFSET_IRQDESC_ACTION,	IRQDESC_ACTION
+	RIMINFO RIM_WIDTH_ACTION,		0x04	/* */
+	RIMINFO RIM_OFFSET_IRQACTION_NAME,	IRQACTION_NAME
+	RIMINFO RIM_WIDTH_IRQACTION_NAME,	0x04	/* */
+	RIMINFO RIM_OFFSET_IRQACTION_NEXT,	IRQACTION_NEXT
+	RIMINFO RIM_WIDTH_IRQACTION_NEXT,	0x04	/* */
+
+	RIMINFO RIM_LINUX_SOFTIRQ_PID,		RT3_TRACE_SOFTIRQ_PID
diff -uNr linux-3.14.19/arch/arm/kernel/rt3.c linux-gerda/arch/arm/kernel/rt3.c
--- linux-3.14.19/arch/arm/kernel/rt3.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/kernel/rt3.c	2017-06-22 09:52:12.687040444 +0900
@@ -0,0 +1,514 @@
+/*
+ * rt3.c: rt3 trace log related routines.
+ *
+ * Copyright (C) Panasonic Corporation
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+
+#include <asm/irq.h>
+#include <asm/uaccess.h>
+#include <linux/module.h>
+#include <linux/compiler.h>
+#include <linux/sched.h>
+
+#include <asm/rt3.h>
+
+#include <linux/irq.h>
+
+#ifndef CONFIG_RT3_TRACE_DO_ENABLE
+volatile int rt3_linux_trace_enabled = 0;
+#endif
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+u32 rt3_linux_trace_buff[RT3_TRACE_BUFF_SIZE_IN_WORD];
+u32 rt3_linux_buff_size = sizeof(rt3_linux_trace_buff);
+volatile u32 *rt3_linux_trace_buff_ptr = rt3_linux_trace_buff;
+volatile int rt3_linux_trace_buff_ovrflw = 0;
+#endif
+
+#ifdef CONFIG_RT3_LOG_EXIT_TRACE_LOG
+struct rt3_trace_exit_struct rt3_exit_log_table[CONFIG_RT3_LOG_EXIT_TRACE_LOG_NUM];
+volatile int rt3_exit_log_cnt = 0;
+volatile int rt3_exit_log_index = 0;
+
+#endif /* CONFIG_RT3_EXIT_TRACE_LOG */
+
+#define	LOGID(a)	(((u32)(a) >> 24) & 0x000000ff)
+#define	STAMP(a)	(((u32)(a) >>  8) & 0x0000ffff)
+#define	VALUE(a)	(((u32)(a) >>  0) & 0x000000ff)
+#define	VALUE2(a)	(((u32)(a) >>  0) & 0x00ffffff)
+
+/* for rt3ctrl */
+
+/**
+ * @brief exit_task_name_by_pid
+ *
+ * It calls the rt3_trace_get_tskname to implement its function.
+ *
+ * @param  pid  [in]  pid_t   pid.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static char *exit_task_name_by_pid(pid_t pid)
+{
+#ifdef CONFIG_RT3_LOG_EXIT_TRACE_LOG
+	int i;
+	for (i = 0; i < rt3_exit_log_cnt; i++) {
+		if (rt3_exit_log_table[i].pid == pid) {
+			return rt3_exit_log_table[i].comm;
+		}
+	}
+#endif
+	return NULL;
+}
+
+/**
+ * @brief rt3_get_tskpri
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @param  exinf  [out]  OBS_TSK_INFO   task struct.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static int
+rt3_get_tskpri(OBS_TSK_INFO *exinf)
+{
+	pid_t			pid;
+	struct task_struct	*task;
+	unsigned long		flags;
+	int				err;
+	
+	err = get_user(pid, &(exinf->tid));
+	if (pid == 0 || err !=0)
+		return -1;
+
+	raw_local_irq_save(flags);
+
+	task = find_task_by_vpid(pid);
+	if (task != NULL) {
+		exinf->tskpri = task->rt_priority;
+	} else {
+		exinf->tskpri = 0;
+	}
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+/**
+ * @brief rt3_trace_get_tskname
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @param  exinf  [out]  OBS_TSK_INFO   task struct.
+ * @return 0   success
+ *         <0  failure
+ * @attention
+ * This function is reentrant.
+ *
+ */
+static int
+rt3_trace_get_tskname(OBS_FNAME_INFO *exinf)
+{
+	pid_t			pid;
+	struct task_struct	*task;
+
+	char			buf[16+1];
+	int			i;
+	unsigned long 		flags;
+	int				err;
+
+	err = get_user(pid, &(exinf->pid));
+	if (err != 0)
+		return -EFAULT;
+	if (pid == 0)
+		return -EINVAL;
+
+	raw_local_irq_save(flags);
+
+	task = find_task_by_vpid(pid);
+	if (task != NULL) {
+		memcpy(buf, task->comm, 16);
+		for (i = 0; i < 16; i++) {
+			if ((buf[i] < 0x20) || (buf[i] > 0x7e))
+				break;
+		}
+		buf[i] = '\0';
+		if (copy_to_user(exinf->name, buf, 16) != 0) {
+			err = -EFAULT;
+		}
+	} else if (exit_task_name_by_pid(pid) != NULL) {
+		memcpy(buf, exit_task_name_by_pid(pid), 16);
+		for (i = 0; i < 16; i++) {
+			if ((buf[i] < 0x20) || (buf[i] > 0x7e))
+				break;
+		}
+		buf[i] = '\0';
+		if (copy_to_user(exinf->name, buf, 16) != 0) {
+			err = -EFAULT;
+		}
+	}
+
+	raw_local_irq_restore(flags);
+	return err;
+}
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+/**
+ * @brief rt3_trace_init_buffer
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static void
+rt3_trace_init_buffer(void)
+{
+	unsigned long flags;
+	raw_local_irq_save(flags);
+
+	rt3_linux_trace_buff_ptr	= rt3_linux_trace_buff;
+	rt3_linux_trace_buff_ovrflw	= 0;
+
+	raw_local_irq_restore(flags);
+	return;
+}
+#endif
+
+/**
+ * @brief rt3_trace_get_rt3info
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @param  exinf  [in]  rt3_info   task struct.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static int
+rt3_trace_get_rt3info(rt3_info *exinf)
+{
+	unsigned long flags;
+	ulong timer_cycle = (RT3_TIME_STAMP >> RT3_TRACE_TIMESTAMP_SHIFT);
+	raw_local_irq_save(flags);
+	put_user(0,					&(exinf->linux_smp));
+	put_user((u32)RT3_TRACE_SOFTIRQ_PID,		&(exinf->softirq_pid));
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+	put_user((u32)rt3_linux_trace_buff,		&(exinf->buff));
+	put_user((u32)rt3_linux_buff_size,		&(exinf->buffsize));
+	put_user((u32)rt3_linux_trace_buff_ptr,		&(exinf->ptr));
+	put_user((u32)rt3_linux_trace_buff_ovrflw,	&(exinf->ovrflw));
+#endif
+#ifndef CONFIG_RT3_TRACE_DO_ENABLE
+	put_user((u32)rt3_linux_trace_enabled,		&(exinf->enabled));
+#else
+	put_user(1,					&(exinf->enabled));
+#endif
+	put_user((u32)timer_cycle,			&(exinf->timer_cycle));
+
+	raw_local_irq_restore(flags);
+	return 0;
+}
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+
+/**
+ * @brief rt3_trace_get_buf
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @param  exinf  [out]  exinf  logwrite pointer.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+static int
+rt3_trace_get_buf(rt3_getlog *exinf)
+{
+	u32		*ptr, c, cprev = 0, cprev2[2] = {0, 0};
+	u32		tmp;
+	u32		logflame = 0;
+
+	unsigned long flags;
+	raw_local_irq_save(flags);
+
+	get_user(tmp, &(exinf->ptr));
+	ptr = (u32 *)tmp;
+
+	if (rt3_linux_trace_buff_ovrflw == 0) {
+		if (ptr == rt3_linux_trace_buff) {			/* Buffer Empty */
+			put_user(0, &(exinf->ptr));			/* End of buffer */
+			goto out_with_unlock;
+		}
+		if (ptr == 0) {						/* Set buffer top */
+			ptr = (u32 *)rt3_linux_trace_buff_ptr;
+		}
+		while (1) {
+			ptr--;
+			c = *ptr;
+			if (LOGID(c) != 0x00)
+				break;
+			cprev2[logflame++] = c;
+			cprev = c;
+			if (ptr == rt3_linux_trace_buff) {		/* Bottom ? */
+				put_user(0, &(exinf->ptr));		/* End of buffer */
+				goto out_with_unlock;
+			}
+		}
+	} else { /* In case of rt3_linux_trace_buff_ovrflw == 1 */
+		if (ptr == rt3_linux_trace_buff_ptr) {			/* Already Bottom ? */
+			put_user(0, &(exinf->ptr));			/* End of buffer */
+			goto out_with_unlock;
+		}
+		if (ptr == 0) {						/* Set buffer top */
+			ptr = (u32 *)rt3_linux_trace_buff_ptr;
+		}
+		while (1) {
+			ptr--;
+			if (ptr < rt3_linux_trace_buff) {		/* Boundary of buffer */
+				ptr += RT3_TRACE_BUFF_SIZE_IN_WORD;
+			}
+			c = *ptr;
+			if (LOGID(c) != 0x00)
+				break;
+			cprev2[logflame++] = c;
+			cprev = c;
+			if (ptr == rt3_linux_trace_buff_ptr) {
+				put_user(0, &(exinf->ptr));		/* End of buffer */
+				goto out_with_unlock;
+			}
+		}
+	}
+
+	put_user((u32)ptr,           &(exinf->ptr));
+	put_user((u32)LOGID(c),      &(exinf->logid));	/* 1st word  8bit logid */
+	put_user((u32)STAMP(c),      &(exinf->ts));	/* 1st word 16bit tstamp */
+	put_user((u32)VALUE(c),      &(exinf->val));	/* 1st word  8bit value */
+
+	if (LOGID(c) == 0x99) {
+		cprev = (cprev2[1] << 24) + cprev2[0];
+		put_user((u32)cprev, &(exinf->val2));	/* 2nd word 24bit value */
+	} else {
+		put_user((u32)VALUE2(cprev), &(exinf->val2));	/* 2nd word 24bit value */
+	}
+
+out_with_unlock:
+	raw_local_irq_restore(flags);
+
+	return 0;
+}
+#endif
+
+/**
+ * @brief rt3_trace_get_isrname
+ *
+ * It calls the rt3_trace to implement its function.
+ *
+ * @param  isr       [in]  int   isr id.
+ * @param  isrname   [out]  char* interrupt handler name.
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+int
+rt3_trace_get_isrname(int isr, char *isrname)
+{
+	struct irqaction	*action;
+	struct irq_desc *desc;
+	char				buf[48+1], *dst;
+	unsigned long		flags;
+	int					i;
+
+
+	buf[0]	= '\0';
+	dst		= buf;
+
+	desc = irq_to_desc(isr);
+	if (desc == NULL)
+		return -1;
+
+	raw_local_irq_save(flags);
+
+	action = desc->action;
+
+	while (action != NULL) {
+		strncpy(dst, action->name, 16);
+		for (i = 0; i < 16; i++) {
+			if ((dst[i] < 0x20) || (dst[i] > 0x7e))
+				break;
+		}
+		dst  = dst + i;
+		*dst = '\0';
+		if ((dst - buf) > 32)
+			break;
+
+		action = action->next;
+		if (action == NULL)
+			break;
+
+		strcat(dst, "->");
+		dst += 2;
+		if ((dst - buf) > 32)
+			break;
+	}
+
+	buf[31] = '\0';
+	copy_to_user(isrname, buf, 32);
+
+	raw_local_irq_restore(flags);
+
+	return 0;
+}
+
+/**
+ * @brief rt3_trace
+ *
+ * It calls the rt3ctrl to implement its function.
+ *
+ * @param  log_id       [in]  int id;
+ * @param  info         [in]  int info1
+ * @param  *exinfo      [out]  int info2
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+
+u32 rt3_trace(int log_id, int info, int *exinfo)
+{
+	
+	u32 err = 0;
+	switch (log_id) {
+
+#ifndef CONFIG_RT3_TRACE_DO_ENABLE
+	case RT3_TRACE_DISABLE:
+		rt3_log_disable_event(current->pid);
+		break;
+
+	case RT3_TRACE_ENABLE:
+		rt3_log_enable_event();
+		break;
+#else
+	case RT3_TRACE_DISABLE:
+	case RT3_TRACE_ENABLE:
+		err = -1;
+		break;
+
+#endif /* !CONFIG_RT3_TRACE_DO_ENABLE */
+	case RT3_TRACE_USERLOG:
+		rt3_log_user_event(info);
+		break;
+
+	case RT3_TRACE_USERLOG_EXT:
+		rt3_log_user8_24_event(info, (int)exinfo);
+		break;
+
+	case RT3_SYS_TRACE_RT3INFO:
+		err = rt3_trace_get_rt3info((rt3_info *)exinfo);
+		break;
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+	case RT3_SYS_TRACE_GETBUF:
+		err = rt3_trace_get_buf((rt3_getlog *)exinfo);
+		break;
+
+	case RT3_SYS_TRACE_INIT:
+		rt3_trace_init_buffer();
+		break;
+#else
+	case RT3_SYS_TRACE_GETBUF:
+	case RT3_SYS_TRACE_INIT:
+		err = -1;
+		break;
+#endif/* !CONFIG_RT3_TRACE_LOG_ON_MEM */
+	case RT3_SYS_TRACE_GETNAME:
+		err = rt3_trace_get_tskname((OBS_FNAME_INFO *)exinfo);
+		break;
+
+#ifdef CONFIG_RT3_LOG_ISR
+	case RT3_SYS_TRACE_GETISR:
+		err = rt3_trace_get_isrname(info, (char *)exinfo);
+		break;
+#else
+	case RT3_SYS_TRACE_GETISR:
+		err = -1;
+		break;
+#endif/* !CONFIG_RT3_LOG_ISR */
+
+	case RT3_SYS_TRACE_GETPRI:
+		err = rt3_get_tskpri((OBS_TSK_INFO *)exinfo);
+		break;
+
+	default:
+		break;
+		
+	}
+
+	return err;
+}
+
+EXPORT_SYMBOL(rt3_trace);
+
+#ifdef CONFIG_RT3_TRACE_LOG_ON_MEM
+/**
+ * @brief rt3_log_event
+ *
+ * It calls the rt3log to implement its function.
+ *
+ * @param  data       [in]  u32;
+ * @return none
+ *
+ * @attention
+ * This function is reentrant.
+ *
+ */
+void rt3_log_event(u32 data)
+{
+	*rt3_linux_trace_buff_ptr = data;
+	if (rt3_linux_trace_buff_ptr
+	    < (rt3_linux_trace_buff + RT3_TRACE_BUFF_SIZE_IN_WORD - 1)) {
+		rt3_linux_trace_buff_ptr++;
+	} else {
+		rt3_linux_trace_buff_ovrflw = 1;
+		rt3_linux_trace_buff_ptr = rt3_linux_trace_buff;
+	}
+}
+#endif /* CONFIG_RT3_TRACE_LOG_ON_MEM */
diff -uNr linux-3.14.19/arch/arm/kernel/smp.c linux-gerda/arch/arm/kernel/smp.c
--- linux-3.14.19/arch/arm/kernel/smp.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/smp.c	2017-06-22 09:52:12.683040444 +0900
@@ -47,6 +47,11 @@
 #include <asm/mach/arch.h>
 #include <asm/mpu.h>
 
+#ifdef CONFIG_RT3_LOG_ISR
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_LOG_ISR */
+
+
 /*
  * as from 2.5, kernels no longer have an init_tasks structure
  * so we need some other way of telling a new secondary core
@@ -559,6 +564,10 @@
 	if (ipinr < NR_IPI)
 		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
 
+#ifdef CONFIG_RT3_LOG_ISR
+	rt3_log_isr_entry_event(RT3_TRACE_DO_IPI);
+#endif
+
 	switch (ipinr) {
 	case IPI_WAKEUP:
 		break;
@@ -612,6 +621,9 @@
 		       cpu, ipinr);
 		break;
 	}
+#ifdef CONFIG_RT3_LOG_ISR
+	rt3_log_isr_exit_event(RT3_TRACE_DO_IPI);
+#endif
 	set_irq_regs(old_regs);
 }
 
diff -uNr linux-3.14.19/arch/arm/kernel/smp_twd.c linux-gerda/arch/arm/kernel/smp_twd.c
--- linux-3.14.19/arch/arm/kernel/smp_twd.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/kernel/smp_twd.c	2017-06-22 09:52:12.687040444 +0900
@@ -26,6 +26,10 @@
 #include <asm/smp_plat.h>
 #include <asm/smp_twd.h>
 
+#ifdef CONFIG_RT3_LOG_ISR
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_LOG_ISR */
+
 /* set up by the platform code */
 static void __iomem *twd_base;
 
@@ -233,7 +237,13 @@
 	struct clock_event_device *evt = dev_id;
 
 	if (twd_timer_ack()) {
+#ifdef CONFIG_RT3_LOG_ISR
+		rt3_log_isr_entry_event(RT3_TRACE_LOCAL_TIMER);
+#endif
 		evt->event_handler(evt);
+#ifdef CONFIG_RT3_LOG_ISR
+		rt3_log_isr_exit_event(RT3_TRACE_LOCAL_TIMER);
+#endif
 		return IRQ_HANDLED;
 	}
 
@@ -388,8 +398,10 @@
 {
 	int err;
 
+#ifndef CONFIG_ARCH_GERDA
 	if (!is_smp() || !setup_max_cpus)
 		return;
+#endif
 
 	twd_ppi = irq_of_parse_and_map(np, 0);
 	if (!twd_ppi) {
diff -uNr linux-3.14.19/arch/arm/mach-gerda/Kconfig linux-gerda/arch/arm/mach-gerda/Kconfig
--- linux-3.14.19/arch/arm/mach-gerda/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/Kconfig	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,116 @@
+config ARCH_GERDA
+	bool "Panasonic Gerda SoCs" if ARCH_MULTI_V7
+	select ARM_ERRATA_754322
+	select ARM_ERRATA_764369
+	select ARM_ERRATA_775420
+	select ARM_ERRATA_782773
+#	select ARCH_REQUIRE_GPIOLIB
+	select CLKSRC_OF
+	select COMMON_CLK
+	select GENERIC_CLOCKEVENTS
+#	select GENERIC_IRQ_CHIP
+#	select PINCTRL
+	select ARM_GIC
+	select HAVE_SMP
+#	select HAVE_ARM_ARCH_TIMER
+#	select ARM_GLOBAL_TIMER
+	select HAVE_ARM_TWD
+	select GERDA_TIMER
+	select MN_HAS_L2CA
+	select ARCH_WANT_OPTIONAL_GPIOLIB
+
+if ARCH_GERDA
+choice
+	prompt "Panasonic Gerda SoC Selection"
+	default MACH_GERDAC
+
+config MACH_GERDA3
+	bool "Panasonic Gerda-3 SOCs support"
+
+config MACH_GERDAC
+	bool "Panasonic Gerda-C SOCs support"
+
+endchoice
+
+config GERDA_TIMER
+	select CLKSRC_OF
+	select CLKSRC_MMIO
+	bool
+
+config ARCH_HAS_CACHE_LINE_SIZE
+	bool
+	default n
+
+config MN_HAS_L2CA
+	bool
+	default n
+	select ARCH_HAS_CACHE_LINE_SIZE
+	select OUTER_CACHE
+	select OUTER_CACHE_SYNC
+
+config MN_L2CACHE_ENABLE
+	bool "Use L2CA (L2 Cache)"
+	depends on MN_HAS_L2CA
+	default y
+
+config SHARED_GIC
+	bool "Shared GIC resource"
+	default n
+	help
+	  This option should be enabled when the GIC is shared with
+	  Linux and the other OS.
+	  Suspend options are dependent on this option.
+	  When this option is enabled, you cannot use CONFIG_SUSPEND.
+
+menu "RT3 trace options"
+config MN_EXPORT_RIM_DBGINFO
+#	bool "Export RIM debugging information"
+	bool
+	default y
+	help
+	  This option exports the information for RIM debugging.
+
+config RT3_TRACE
+	bool "Use real time task trace (real-time task trace)"
+	default y
+	help
+	  This option enables rt3 trace.
+
+config RT3_TRACE_DO_ENABLE
+	bool "Enable real time task trace at start time"
+	depends on RT3_TRACE
+	default y
+	help
+	  This option enables real time trace at start time.
+
+config RT3_TRACE_LOG_ON_MEM
+	bool "Trace log on mem"
+	depends on RT3_TRACE
+	default y
+	help
+	  This option enables trace log on memory.
+
+config RT3_TRACE_BUFF_SIZE
+	int "Trace log buffer size in KB (64 - 8192)"
+	depends on RT3_TRACE_LOG_ON_MEM
+	default 64
+	range 64 8192
+
+config RT3_LOG_ISR
+	bool "Log interrupt service routine"
+	depends on RT3_TRACE
+	default n
+
+config RT3_LOG_EXIT_TRACE_LOG
+	bool "Log exit process"
+	depends on RT3_TRACE
+	default n
+
+config RT3_LOG_EXIT_TRACE_LOG_NUM
+	int "Trace process exit log number (32 - 32768)"
+	depends on RT3_LOG_EXIT_TRACE_LOG
+	default 256
+	range 32 32768
+endmenu
+
+endif
diff -uNr linux-3.14.19/arch/arm/mach-gerda/Makefile linux-gerda/arch/arm/mach-gerda/Makefile
--- linux-3.14.19/arch/arm/mach-gerda/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/Makefile	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,4 @@
+obj-$(CONFIG_MACH_GERDA3) += gerda3.o
+obj-$(CONFIG_MACH_GERDAC) += gerdac.o
+obj-$(CONFIG_GERDA_TIMER) += timer.o
+obj-$(CONFIG_SMSC911X) += smsc911x.o
diff -uNr linux-3.14.19/arch/arm/mach-gerda/gerda3.c linux-gerda/arch/arm/mach-gerda/gerda3.c
--- linux-3.14.19/arch/arm/mach-gerda/gerda3.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/gerda3.c	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,138 @@
+/*
+ * Device Tree support for Gerda-3 SoCs
+ *
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/reboot.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/system_misc.h>
+#include <asm/memory.h>
+#include <asm/page.h>
+
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/i2c/i2c-mn.h>
+#include "i2c-mn-unit.h"
+#endif
+
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+#if defined(CONFIG_MN_I2C_CH0)
+/* I2C channel 0 */
+static struct i2c_mn_pdata i2c_mn_pdata_0 = {
+	.base = I2C_MN_CH_BASE_PERI0(0),
+	.irq  = I2C_MN_CH_IRQ_PERI0(0),
+	.rate = CONFIG_MN_I2C_CH0_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_0 = {
+	.name = "i2c-mn",
+	.id   = 0,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_0,
+	}
+};
+#endif /* CONFIG_MN_I2C_CH0 */
+
+#if defined(CONFIG_MN_I2C_CH1)
+/* I2C channel 1 */
+static struct i2c_mn_pdata i2c_mn_pdata_1 = {
+	.base = I2C_MN_CH_BASE_PERI0(1),
+	.irq  = I2C_MN_CH_IRQ_PERI0(1),
+	.rate = CONFIG_MN_I2C_CH1_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_1 = {
+	.name = "i2c-mn",
+	.id   = 1,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_1,
+	}
+};
+#endif /* CONFIG_MN_I2C_CH1 */
+
+static struct platform_device *unit_i2c_devices[] __initdata = {
+#if defined(CONFIG_MN_I2C_CH0)
+	&i2c_mn_pdev_0,
+#endif /* CONFIG_MN_I2C_CH0 */
+#if defined(CONFIG_MN_I2C_CH1)
+	&i2c_mn_pdev_1,
+#endif /* CONFIG_MN_I2C_CH1 */
+};
+#endif /* CONFIG_I2C_MN || CONFIG_I2C_MN_MODULE */
+
+#define GERDA_UNCACHED_AREA_VIRT	0xfe000000U
+#define GERDA_UNCACHED_AREA_PHYS	PHYS_OFFSET
+#define GERDA_UNCACHED_AREA_SIZE	PAGE_SIZE
+
+#ifdef CONFIG_MN_HAS_L2CA
+extern void *l2ca_uncached_addr;
+#endif
+
+static void __init gerda3_map_io(void);
+static void __init gerda3_init_machine(void);
+
+static struct map_desc gerda3_io_desc[] __initdata = {
+	{
+		.virtual	= GERDA_UNCACHED_AREA_VIRT,
+		.pfn		= 0UL, /* __phys_to_pfn(GERDA_UNCACHED_AREA_PHYS) */
+		.length		= GERDA_UNCACHED_AREA_SIZE,
+		.type		= MT_UNCACHED,
+	},
+};
+
+/**
+ * Gerda-3 Kernel address mapping
+ */
+static void __init gerda3_map_io(void)
+{
+	/* Set the uncached area's pfn value.
+	   This value is not determined in the static. */
+	gerda3_io_desc[0].pfn =  __phys_to_pfn(GERDA_UNCACHED_AREA_PHYS);
+
+	iotable_init(gerda3_io_desc, ARRAY_SIZE(gerda3_io_desc));
+
+#ifdef CONFIG_MN_HAS_L2CA
+	l2ca_uncached_addr = (void *)GERDA_UNCACHED_AREA_VIRT;
+#endif /* CONFIG_MN_HAS_L2CA */
+}
+
+/**
+ * Gerda-3 Kernel initialize
+ */
+static void __init gerda3_init_machine(void)
+{
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+	platform_add_devices(
+		unit_i2c_devices, ARRAY_SIZE(unit_i2c_devices));
+#endif
+
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char * const gerda3_board_dt_compat[] = {
+	"panasonic,gerda3-dd",
+	"panasonic,gerda3-dl",
+	NULL,
+};
+
+DT_MACHINE_START(GERDA3_DT, "Panasonic GERDA 3 DL (Device Tree)")
+	.dt_compat	= gerda3_board_dt_compat,
+	.map_io		= gerda3_map_io,
+	.init_machine	= gerda3_init_machine,
+MACHINE_END
diff -uNr linux-3.14.19/arch/arm/mach-gerda/gerdac.c linux-gerda/arch/arm/mach-gerda/gerdac.c
--- linux-3.14.19/arch/arm/mach-gerda/gerdac.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/gerdac.c	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,201 @@
+/*
+ * Device Tree support for Gerda-C SoCs
+ *
+ * Copyright (C) 2014 Panasonic Corporation
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/clocksource.h>
+#include <linux/delay.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
+#include <linux/reboot.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/system_misc.h>
+#include <asm/memory.h>
+#include <asm/page.h>
+
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+#include <linux/i2c.h>
+#include <linux/i2c-dev.h>
+#include <linux/i2c/i2c-mn.h>
+#include "i2c-mn-unit.h"
+#endif
+#define GERDAC_GPIO_PERI1_REG_BASE		0x9C056000UL
+#define GERDAC_GPIO_PERI1_REG_END		(GERDAC_GPIO_PERI1_REG_BASE + 0x9F)
+
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+#if defined(CONFIG_I2C_MN_CH0)
+/* I2C channel 0 */
+static struct i2c_mn_pdata i2c_mn_pdata_0 = {
+	.base = I2C_MN_CH_BASE_PERI0(0),
+	.irq  = I2C_MN_CH_IRQ_PERI0(0),
+	.rate = CONFIG_I2C_MN_CH0_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_0 = {
+	.name = "i2c-mn",
+	.id   = 0,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_0,
+	}
+};
+#endif /* CONFIG_I2C_MN_CH0 */
+
+#if defined(CONFIG_I2C_MN_CH1)
+/* I2C channel 1 */
+static struct i2c_mn_pdata i2c_mn_pdata_1 = {
+	.base = I2C_MN_CH_BASE_PERI0(1),
+	.irq  = I2C_MN_CH_IRQ_PERI0(1),
+	.rate = CONFIG_I2C_MN_CH1_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_1 = {
+	.name = "i2c-mn",
+	.id   = 1,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_1,
+	}
+};
+#endif /* CONFIG_I2C_MN_CH1 */
+
+#if defined(CONFIG_I2C_MN_CH2)
+/* I2C channel 2 */
+static struct i2c_mn_pdata i2c_mn_pdata_2 = {
+	.base = I2C_MN_CH_BASE_PERI1(0),
+	.irq  = I2C_MN_CH_IRQ_PERI1(0),
+	.rate = CONFIG_I2C_MN_CH2_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_2 = {
+	.name = "i2c-mn",
+	.id   = 2,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_2,
+	}
+};
+#endif /* CONFIG_I2C_MN_CH2 */
+
+#if defined(CONFIG_I2C_MN_CH3)
+/* I2C channel 3 */
+static struct i2c_mn_pdata i2c_mn_pdata_3 = {
+	.base = I2C_MN_CH_BASE_PERI1(1),
+	.irq  = I2C_MN_CH_IRQ_PERI1(1),
+	.rate = CONFIG_I2C_MN_CH3_RATE,
+};
+
+static struct platform_device i2c_mn_pdev_3 = {
+	.name = "i2c-mn",
+	.id   = 3,
+	.dev = {
+		.platform_data = &i2c_mn_pdata_3,
+	}
+};
+#endif /* CONFIG_I2C_MN_CH3 */
+
+static struct platform_device *unit_i2c_devices[] __initdata = {
+#if defined(CONFIG_I2C_MN_CH0)
+	&i2c_mn_pdev_0,
+#endif /* CONFIG_I2C_MN_CH0 */
+#if defined(CONFIG_I2C_MN_CH1)
+	&i2c_mn_pdev_1,
+#endif /* CONFIG_I2C_MN_CH1 */
+#if defined(CONFIG_I2C_MN_CH2)
+	&i2c_mn_pdev_2,
+#endif /* CONFIG_I2C_MN_CH2 */
+#if defined(CONFIG_I2C_MN_CH3)
+	&i2c_mn_pdev_3,
+#endif /* CONFIG_I2C_MN_CH3 */
+};
+#endif /* CONFIG_I2C_MN || CONFIG_I2C_MN_MODULE */
+
+#define GERDA_UNCACHED_AREA_VIRT	0xfe000000U
+#define GERDA_UNCACHED_AREA_PHYS	PHYS_OFFSET
+#define GERDA_UNCACHED_AREA_SIZE	PAGE_SIZE
+
+#ifdef CONFIG_MN_HAS_L2CA
+extern void *l2ca_uncached_addr;
+#endif
+
+static void __init gerdac_map_io(void);
+static void __init gerdac_init_machine(void);
+
+static struct map_desc gerdac_io_desc[] __initdata = {
+	{
+		.virtual	= GERDA_UNCACHED_AREA_VIRT,
+		.pfn		= 0UL, /* __phys_to_pfn(GERDA_UNCACHED_AREA_PHYS) */
+		.length		= GERDA_UNCACHED_AREA_SIZE,
+		.type		= MT_UNCACHED,
+	},
+};
+
+static struct resource gerdac_gpio_resources[] = {
+	[0] = {
+		.start	= GERDAC_GPIO_PERI1_REG_BASE,
+		.end	= GERDAC_GPIO_PERI1_REG_END,
+		.name	= "gerdac-gpio-regs",
+		.flags	= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device gerdac_gpio_device = {
+	.name		= "gerdac-gpio",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(gerdac_gpio_resources),
+	.resource	= gerdac_gpio_resources,
+/*TODO
+	.dev		= {
+		.platform_data = &smsc911x_config,
+	}
+*/
+};
+
+/**
+ * Gerda-C Kernel address mapping
+ */
+static void __init gerdac_map_io(void)
+{
+	/* Set the uncached area's pfn value.
+	   This value is not determined in the static. */
+	gerdac_io_desc[0].pfn =  __phys_to_pfn(GERDA_UNCACHED_AREA_PHYS);
+
+	iotable_init(gerdac_io_desc, ARRAY_SIZE(gerdac_io_desc));
+
+#ifdef CONFIG_MN_HAS_L2CA
+	l2ca_uncached_addr = (void *)GERDA_UNCACHED_AREA_VIRT;
+#endif /* CONFIG_MN_HAS_L2CA */
+}
+
+/**
+ * Gerda-C Kernel initialize
+ */
+static void __init gerdac_init_machine(void)
+{
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+	platform_add_devices(
+		unit_i2c_devices, ARRAY_SIZE(unit_i2c_devices));
+#endif
+	platform_device_register(&gerdac_gpio_device);
+
+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);
+}
+
+static const char * const gerdac_board_dt_compat[] = {
+	"panasonic,gerdac-hwe",
+	NULL,
+};
+
+DT_MACHINE_START(GERDAC_DT, "Panasonic GERDA-C (Device Tree)")
+	.dt_compat	= gerdac_board_dt_compat,
+	.map_io		= gerdac_map_io,
+	.init_machine	= gerdac_init_machine,
+MACHINE_END
diff -uNr linux-3.14.19/arch/arm/mach-gerda/i2c-mn-unit.h linux-gerda/arch/arm/mach-gerda/i2c-mn-unit.h
--- linux-3.14.19/arch/arm/mach-gerda/i2c-mn-unit.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/i2c-mn-unit.h	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,47 @@
+/* i2c-mn-unit.h: support for the I2C on gerda-c
+ *
+ *  Copyright (C) 2014 Panasonic Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#ifndef _ASM_UNIT_I2C_MN_UNIT_H
+#define _ASM_UNIT_I2C_MN_UNIT_H
+
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+
+#if defined(CONFIG_MACH_GERDAC)
+/*----- I2C Register Address -----*/
+#define I2C_MN_REG_BASE_PERI0		0x9C019000UL
+#define I2C_MN_REG_BASE_PERI1		0x9C059000UL
+
+#define I2C_MN_OFFSET(n)		(0x100UL * (n))
+
+#define I2C_MN_CH_BASE_PERI0(n) (I2C_MN_REG_BASE_PERI0 + I2C_MN_OFFSET(n))
+#define I2C_MN_CH_BASE_PERI1(n) (I2C_MN_REG_BASE_PERI1 + I2C_MN_OFFSET(n))
+
+/*----- I2C IRQ No. -----*/
+#define I2C_MN_IRQ_OFFSET_PERI0 141
+#define I2C_MN_IRQ_OFFSET_PERI1 143
+
+#define I2C_MN_CH_IRQ_PERI0(n) (I2C_MN_IRQ_OFFSET_PERI0 + (n))
+#define I2C_MN_CH_IRQ_PERI1(n) (I2C_MN_IRQ_OFFSET_PERI1 + (n))
+
+#elif defined(CONFIG_MACH_GERDA3)
+/*----- I2C Register Address -----*/
+#define I2C_MN_REG_BASE_PERI0		0x9C019000UL
+
+#define I2C_MN_OFFSET(n)		(0x100UL * (n))
+
+#define I2C_MN_CH_BASE_PERI0(n) (I2C_MN_REG_BASE_PERI0 + I2C_MN_OFFSET(n))
+
+/*----- I2C IRQ No. -----*/
+#define I2C_MN_IRQ_OFFSET_PERI0 128
+
+#define I2C_MN_CH_IRQ_PERI0(n) (I2C_MN_IRQ_OFFSET_PERI0 + (n))
+#endif /* CONFIG_MACH_GERDA3 */
+
+#endif /* (CONFIG_I2C_MN) || (CONFIG_I2C_MN_MODULE) */
+
+#endif /* _ASM_UNIT_I2C_MN_UNIT_H */
diff -uNr linux-3.14.19/arch/arm/mach-gerda/smsc911x.c linux-gerda/arch/arm/mach-gerda/smsc911x.c
--- linux-3.14.19/arch/arm/mach-gerda/smsc911x.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/smsc911x.c	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,64 @@
+/* Specification for the SMSC911x NIC
+ *
+ * Copyright (C) 2006 Matsushita Electric Industrial Co., Ltd.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/smsc911x.h>
+
+#define SMSC911X_IRQ		(124)	/* External interrupt 4 */
+
+/* FLASH2 control register base */
+#define FLM2_BASE		(0x9c041804)
+#define FLM2_BASE_END		(FLM2_BASE + 0x14c)
+
+static struct smsc911x_platform_config smsc911x_config = {
+	.irq_polarity	= SMSC911X_IRQ_POLARITY_ACTIVE_HIGH,
+	.irq_type	= SMSC911X_IRQ_TYPE_PUSH_PULL,
+	.flags		= SMSC911X_USE_16BIT,
+};
+
+static struct resource smsc911x_resources[] = {
+	[0] = {
+		.start	= FLM2_BASE,
+		.end	= FLM2_BASE_END,
+		.name	= "smsc911x-memory",
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= SMSC911X_IRQ,
+		.end	= SMSC911X_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device smsc911x_device = {
+	.name		= "smsc911x",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(smsc911x_resources),
+	.resource	= smsc911x_resources,
+	.dev		= {
+		.platform_data = &smsc911x_config,
+	}
+};
+
+/*
+ * add platform devices
+ */
+static int __init unit_device_init(void)
+{
+	platform_device_register(&smsc911x_device);
+	return 0;
+}
+
+device_initcall(unit_device_init);
diff -uNr linux-3.14.19/arch/arm/mach-gerda/timer.c linux-gerda/arch/arm/mach-gerda/timer.c
--- linux-3.14.19/arch/arm/mach-gerda/timer.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mach-gerda/timer.c	2017-06-22 09:52:11.239040487 +0900
@@ -0,0 +1,154 @@
+/*
+ * Panasonic SoC timer
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/bitops.h>
+#include <linux/clk.h>
+#include <linux/clockchips.h>
+#include <linux/interrupt.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/spinlock.h>
+#include <linux/sched_clock.h>
+
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif
+
+#define TM16nMD(n)	(0x00 + (0x40 * (n)))
+#define TM16nMD_CK		0x00000007U
+#define TM16nMD_CK_PCLK		0x00000000U
+#define TM16nMD_CK_PCLK_8	0x00000001U
+#define TM16nMD_CK_UFLOW	0x00000002U
+#define TM16nMD_LDE		0x00000040U
+#define TM16nMD_CNE		0x00000080U
+#define TM16nMD_UD		0x00000300U
+#define TM16nMD_UD_UP		0x00000000U
+#define TM16nMD_UD_DOWN		0x00000100U
+
+#define TM16nMDAB(n)	(0x04 + (0x40 * (n)))
+#define TM16nCA(n)	(0x08 + (0x40 * (n)))
+#define TM16nCB(n)	(0x0c + (0x40 * (n)))
+#define TM16nBC(n)	(0x10 + (0x40 * (n)))
+#define TM16nPSCNT(n)	(0x14 + (0x40 * (n)))
+#define TM16nMSK(n)	(0x20 + (0x40 * (n)))
+#define TM16nMSK_CMP_B		0x00000001U
+#define TM16nMSK_CMP_A		0x00000002U
+#define TM16nMSK_UDFLOW		0x00000004U
+
+#define TM16nSTS(n)	(0x24 + (0x40 * (n)))
+#define TM16nCLR(n)	(0x28 + (0x40 * (n)))
+
+static void __iomem *timer_base;
+
+static u32 gerda_timer_read(void);
+static u64 gerda_timer_sched_clock(void);
+static cycle_t gerda_timer_clocksource_read(struct clocksource *c);
+static void __init gerda_timer_init(struct device_node *np);
+
+/**
+ * Read Free-running timer value
+ *
+ * @return timer value (32-bit down count)
+ */
+static u32 gerda_timer_read(void)
+{
+	u16 upper0, upper1, lower;
+	do {
+		upper0 = (u16)readl((unsigned char *)timer_base + TM16nBC(1));
+		lower  = (u16)readl((unsigned char *)timer_base + TM16nBC(0));
+		upper1 = (u16)readl((unsigned char *)timer_base + TM16nBC(1));
+	} while (upper0 != upper1);
+
+	return ((u32)upper0 << 16) | lower;
+}
+
+/**
+ * Get timer value for sched_clock
+ *
+ * @return  timer value (32-bit up count)
+ *
+ * @attention lower 32-bit of a return value is only used
+ */
+static u64 notrace gerda_timer_sched_clock(void)
+{
+	return (u64)~gerda_timer_read();
+}
+
+/**
+ * Get timer value for clocksource
+ *
+ * @param c  clocksource struct
+ * @return  timer value (32-bit up count)
+ *
+ * @attention lower 32-bit of a return value is only used
+ */
+static cycle_t gerda_timer_clocksource_read(struct clocksource *c)
+{
+	return (cycle_t)~gerda_timer_read();
+}
+
+#ifdef CONFIG_RT3_TRACE
+/**
+ * Read Free-running timer value for rt3
+ *
+ * @return timer value (32-bit down count)
+ */
+u32 gerda_timer_read_rt3(void)
+{
+	return gerda_timer_read();
+}
+#endif
+
+/**
+ * Initialize timer
+ *
+ * @param np  devicetree node
+ */
+static void __init gerda_timer_init(struct device_node *np)
+{
+	struct clk *clk;
+	u32 t0, t1;
+
+	timer_base = of_iomap(np, 0);
+	if (timer_base == NULL)
+		panic("%s: unable to map resource\n", np->name);
+
+	clk = of_clk_get(np, 0);
+	if (IS_ERR(clk))
+		panic("%s: unable to get clk\n", np->name);
+	clk_prepare_enable(clk);
+
+	/* Setup timer as free-running clocksource */
+	/* Initialize lower timer */
+	t0 = TM16nMD_LDE | TM16nMD_CK_PCLK | TM16nMD_UD_DOWN;
+	writel(t0, (unsigned char *)timer_base + TM16nMD(0));
+	/* Unmask the underflow of a lower timer */
+	writel(TM16nMSK_UDFLOW, (unsigned char *)timer_base + TM16nMSK(0));
+
+	/* Initialize upper timer */
+	t1 = TM16nMD_LDE | TM16nMD_CK_UFLOW | TM16nMD_UD_DOWN;
+	writel(t1, (unsigned char *)timer_base + TM16nMD(1));
+
+	/* Enable upper timer */
+	t1 &= ~TM16nMD_LDE;
+	t1 |= TM16nMD_CNE;
+	writel(t1, (unsigned char *)timer_base + TM16nMD(1));
+	/* Enable lower timer */
+	t0 &= ~TM16nMD_LDE;
+	t0 |= TM16nMD_CNE;
+	writel(t0, (unsigned char *)timer_base + TM16nMD(0));
+
+	clocksource_mmio_init(NULL, "gerda_clocksource",
+			      clk_get_rate(clk), 300, 32,
+			      gerda_timer_clocksource_read);
+	sched_clock_register(gerda_timer_sched_clock, 32, clk_get_rate(clk));
+}
+
+CLOCKSOURCE_OF_DECLARE(gerda_timer, "panasonic,gerda-timer", gerda_timer_init);
diff -uNr linux-3.14.19/arch/arm/mm/Makefile linux-gerda/arch/arm/mm/Makefile
--- linux-3.14.19/arch/arm/mm/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/Makefile	2017-06-22 09:52:13.807040411 +0900
@@ -99,3 +99,4 @@
 obj-$(CONFIG_CACHE_L2X0)	+= cache-l2x0.o
 obj-$(CONFIG_CACHE_XSC3L2)	+= cache-xsc3l2.o
 obj-$(CONFIG_CACHE_TAUROS2)	+= cache-tauros2.o
+obj-$(CONFIG_MN_HAS_L2CA)	+= cache-mn-l2.o
diff -uNr linux-3.14.19/arch/arm/mm/cache-mn-l2.c linux-gerda/arch/arm/mm/cache-mn-l2.c
--- linux-3.14.19/arch/arm/mm/cache-mn-l2.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mm/cache-mn-l2.c	2017-06-22 09:52:13.807040411 +0900
@@ -0,0 +1,575 @@
+/*
+ * linux/arch/arm/mach-uniphier/include/mach/l2ca.c
+ *
+ * Copyright (C) 2011 Panasonic Corporation
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ */
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+
+#include <asm/cacheflush.h>
+#include "cache-mn-l2.h"
+
+#define L2_CACHE_ADRS_MASK	(~((unsigned long)L2_CACHE_BYTES - 1UL))
+
+#define	L2PCMD_INV		L2COPE_CM_INV
+#define	L2PCMD_WB		L2COPE_CM_WB
+#define	L2PCMD_WBINV		L2COPE_CM_WBINV
+#define	L2PCMD_SYNC		L2COPE_CM_SYNC
+#define	L2PCMD_PBFLUSH		L2COPE_CM_FLSH_PFBUF
+
+#define	L2QCMD_INV		L2COQM_CM_INV
+#define	L2QCMD_WB		L2COQM_CM_WB
+#define	L2QCMD_WBINV		L2COQM_CM_WBINV
+#define	L2QCMD_L2CPREFETCH	L2COQM_CM_PF_L2C
+#define	L2QCMD_TOUCH		L2COQM_CM_TOUCH
+#define	L2QCMD_TOUCH_ZERO	L2COQM_CM_TOUCH_ZERO
+#define	L2QCMD_TOUCH_DIRTY	L2COQM_CM_TOUCH_DIRTY
+
+#define	MAXSZPURGE_L2C		0x00100000
+
+#define L2QCMD_THRESHOLD	0x00100000UL	/* 1MB */
+#define L2QCMD_THRESHOLD_MASK	(~(L2QCMD_THRESHOLD - 1UL))
+
+static void *l2ca_reg[3];
+void *l2ca_uncached_addr;
+
+#define L2C_ADDR(reg)	((unsigned char *)l2ca_reg[((reg) >> 16U) & 0xffffU] + ((reg) & 0xffffU))
+
+static void l2ca_sync(void);
+static void l2ca_flush_all(void);
+static void l2ca_inv_all(void);
+static void l2ca_clean_range(unsigned long start, unsigned long end);
+static void l2ca_flush_range(unsigned long start, unsigned long end);
+static void l2ca_inv_range(unsigned long start, unsigned long end);
+static int l2ca_init(void);
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+static void _set_l2cache_qcmd_size(unsigned long start, unsigned long size, unsigned int cmd);
+static void __set_l2cache_qcmd_mask(unsigned long start, unsigned long mask, unsigned int cmd);
+static void _set_l2cache_qcmd_mask(unsigned long start, unsigned long size, unsigned int cmd);
+static void l2ca_qcmd(unsigned long start, unsigned long size, unsigned int cmd);
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+
+/**
+ * Write to L2 cache control register
+ *
+ * @param val  Write value
+ * @param reg  Register definition
+ */
+static inline void l2ca_writel(unsigned int val, unsigned int reg)
+{
+	__raw_writel(val, L2C_ADDR(reg));
+}
+
+/**
+ * Read from L2 cache control register
+ *
+ * @param reg   Register definition
+ * @return Register value
+ */
+static inline unsigned int l2ca_readl(unsigned int reg)
+{
+	return __raw_readl(L2C_ADDR(reg));
+}
+
+#define	sync_opt_ex_bus()	\
+	do { u32 tmp; tmp = __raw_readl(l2ca_uncached_addr); } while (0)
+
+#if MAXSZPURGE_L2C >= L2COQSZ_SIZE
+#error MAXSZPURGE_L2C must be smaller than L2COQSZ_SIZE
+#endif
+
+#ifdef CONFIG_MACH_GERDAC
+#define L2COQM_VALUE(cmd)	(L2COQM_CW_FLAG | ((cmd) & (L2COQM_CM | L2COQM_S)))
+
+/**
+ * Wait till all queue commands are completed
+ *
+ * @param l2coppqsef  L2COPPQSEF value
+ */
+static inline void l2ca_wait_command_complete(unsigned int l2coppqsef)
+{
+	unsigned int l2co_qnum = (l2coppqsef & L2COPPQSEF_QN) >> 8;
+	while ((l2ca_readl(L2COQS(l2co_qnum)) & L2COQS_EF) == 0UL)
+		;
+	l2ca_writel(L2COQS_EF, L2COQS(l2co_qnum));
+}
+
+/**
+ * L2 cache synchronization
+ */
+static void l2ca_sync(void)
+{
+	unsigned int dummy;
+
+	dsb();
+
+	/* L2Cache synchronization */
+	l2ca_writel(L2COSYNC_CM, L2COSYNC);
+	/* Dummy read for synchronization */
+	dummy = l2ca_readl(L2COSYNC);
+
+	/* Ivalidate the pre-fetch buffer */
+	l2ca_writel(L2PCMD_PBFLUSH, L2COPE);
+	/* Dummy read for synchronization */
+	dummy = l2ca_readl(L2COPE);
+}
+#else /* !CONFIG_MACH_GERDAC */
+#define L2COQM_VALUE(cmd)	(L2COQM_CE | L2COQM_CW_FLAG | ((cmd) & (L2COQM_CM | L2COQM_S)))
+
+/**
+ * Wait till all queue commands are completed
+ *
+ * @param l2coppqsef  L2COPPQSEF value
+ */
+static inline void l2ca_wait_command_complete(unsigned int l2coppqsef)
+{
+	while ((l2ca_readl(L2COLPQS) & L2COLPQS_QST) != 0UL)
+		;
+	l2ca_writel(L2COLPQS_EF, L2COLPQS);
+}
+
+/**
+ * L2 cache synchronization
+ */
+static void l2ca_sync(void)
+{
+	unsigned long flags, l2cope;
+	unsigned int dummy;
+
+	l2cope = (unsigned long)L2C_ADDR(L2COPE);
+
+	dsb();
+	/* Set L2Cache primitive command */
+	l2ca_writel(L2PCMD_PBFLUSH, L2COPE);
+	/* Dummy read for synchronization */
+	dummy = l2ca_readl(L2COPE);
+
+	dsb();
+	local_irq_save(flags);
+	__asm__ __volatile__(
+		"dmb\n"
+		"str	%1, [%2]\n"
+		"ldr	%0, [%2]\n"
+		"dmb\n"
+		: "=&r"(dummy)
+		: "r"(L2PCMD_SYNC), "r"(l2cope)
+		: "memory"
+		);
+	local_irq_restore(flags);
+}
+#endif /* !CONFIG_MACH_GERDAC */
+
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+/**
+ * Set a L2 cache queue command using size registers
+ *
+ * @param start  Start address
+ * @param size   Size
+ * @param cmd    Queue command
+ */
+static void _set_l2cache_qcmd_size(unsigned long start, unsigned long size, unsigned int cmd)
+{
+	unsigned long flags;
+	unsigned long l2co_start, l2co_end, l2co_size;
+	unsigned int l2coppqsef_val, tmp_size = 0U;
+
+	pr_debug("qcmd_size: ===== 0x%08lx-0x%08lx (cmd=%d, size=0x%08lx) =====\n",
+		 start, start + size, cmd, size);
+
+	l2co_start = start & L2_CACHE_ADRS_MASK;
+	l2co_end   = (start + size + (L2_CACHE_BYTES - 1)) & L2_CACHE_ADRS_MASK;
+	l2co_size  = l2co_end - l2co_start;
+
+	preempt_disable();
+	/*sync_opt_ex_bus();*/
+	__asm__ __volatile__("dsb" : : : "memory");
+
+	if (unlikely(l2co_size == 0UL) &&
+	    likely((cmd & L2COQM_S) == L2COQM_S_ADDRESS)) {
+		goto skip_qcmd;
+	}
+
+do_qcmd:
+	local_save_flags(flags);
+
+	do {
+		local_irq_restore(flags);
+
+		/* Enter an local atomic section */
+		local_irq_disable();
+
+		/* Get a right to use L2-cache operation */
+		l2ca_writel(L2COQM_VALUE(cmd), L2COQM);
+
+		if (likely((cmd & L2COQM_S) == L2COQM_S_ADDRESS)) {
+			/* Set address */
+			l2ca_writel((unsigned int)l2co_start, L2COQAD);
+			/* Set size */
+			if (unlikely(l2co_size > L2COQSZ_SIZE)) {
+				tmp_size = L2COQSZ_SIZE & L2_CACHE_ADRS_MASK;
+			} else {
+				tmp_size = (unsigned int)l2co_size;
+			}
+			l2ca_writel(tmp_size, L2COQSZ);
+		}
+
+		l2coppqsef_val = l2ca_readl(L2COPPQSEF);
+	} while ((l2coppqsef_val & (L2COPPQSEF_FE | L2COPPQSEF_OE)) != 0U);
+
+	local_irq_restore(flags);
+
+	l2ca_wait_command_complete(l2coppqsef_val);
+
+	if (likely((cmd & L2COQM_S) == L2COQM_S_ADDRESS)) {
+		l2co_start += tmp_size;
+		l2co_size -= tmp_size;
+		if (unlikely(l2co_size > 0UL)) {
+			goto do_qcmd;
+		}
+	}
+
+skip_qcmd:
+	l2ca_sync();
+	sync_opt_ex_bus();
+	preempt_enable();
+}
+
+/**
+ * Set a L2 cache queue command using mask registers
+ *
+ * @param start  Start address
+ * @param mask   Bit mask
+ * @param cmd    Queue command
+ */
+static void __set_l2cache_qcmd_mask(unsigned long start, unsigned long mask, unsigned int cmd)
+{
+	unsigned long flags;
+	unsigned int l2coppqsef_val;
+
+	preempt_disable();
+	local_save_flags(flags);
+
+	do {
+		local_irq_restore(flags);
+
+		/* Enter an local atomic section */
+		local_irq_disable();
+
+		/* Get a right to use L2-cache operation */
+		l2ca_writel(L2COQM_VALUE(cmd), L2COQM);
+
+		/* Set address */
+		l2ca_writel(start, L2COQAD);
+
+		/* Set mask */
+		l2ca_writel(mask, L2COQMASK);
+
+		l2coppqsef_val = l2ca_readl(L2COPPQSEF);
+	} while ((l2coppqsef_val & (L2COPPQSEF_FE | L2COPPQSEF_OE)) != 0U);
+
+	local_irq_restore(flags);
+
+	l2ca_wait_command_complete(l2coppqsef_val);
+
+	l2ca_sync();
+	preempt_enable();
+}
+
+/**
+ * Set a L2 cache queue command using mask registers
+ *
+ * @param start  Start address
+ * @param size   Size
+ * @param cmd    Queue command
+ */
+static void _set_l2cache_qcmd_mask(unsigned long start, unsigned long size, unsigned int cmd)
+{
+	unsigned long end = start + size;
+	unsigned long mid;
+	unsigned long mask;
+	int bit;
+
+	if ((cmd & L2COQM_CM) == L2COQM_CM_INV) {
+		cmd = L2COQM_CM_WBINV; /* for errata */
+	} else {
+		cmd &= L2COQM_CM;
+	}
+
+	if (start >= end)
+		return;
+
+	pr_debug("qcmd_mask: ===== 0x%08lx-0x%08lx (cmd=%d, size=0x%08lx) =====\n",
+		 start, end, cmd, size);
+
+	/*sync_opt_ex_bus();*/
+	dsb();
+
+	/*
+	 * Find the last different bit between "start" and "end".
+	 */
+	bit = fls((int)(start ^ end)) - 1;
+	mid = end & (~0UL << bit);
+
+	while (start < mid) {
+		bit = ffs((int)(start ^ mid)) - 1;
+		mask = ~0UL << bit;
+		pr_debug("qcmd_mask(1): 0x%08lx-0x%08lx (mask=0x%08lx)\n",
+			 start, start + ~mask + 1, mask);
+		__set_l2cache_qcmd_mask(start, mask, cmd);
+		start += ~mask + 1UL;
+	}
+
+	BUG_ON(start != mid);
+
+	while (start < end) {
+		bit = fls((int)(start ^ end)) - 1;
+		mask = ~0UL << bit;
+		pr_debug("qcmd_mask(2): 0x%08lx-0x%08lx (mask=0x%08lx)\n",
+			 start, start + ~mask + 1, mask);
+		__set_l2cache_qcmd_mask(start, mask, cmd);
+		start += ~mask + 1UL;
+	}
+
+	BUG_ON(start != end);
+
+	sync_opt_ex_bus();
+}
+
+/**
+ * Set a L2 cache queue command
+ *
+ * @param start  Start address
+ * @param size   Size
+ * @param cmd    Queue command
+ */
+static void l2ca_qcmd(unsigned long start, unsigned long size, unsigned int cmd)
+{
+	unsigned long tmp;
+
+	if (start >= (start + size))
+		return;
+
+	if ((start & ~L2QCMD_THRESHOLD_MASK) != 0UL) {
+		tmp = (start + ~L2QCMD_THRESHOLD_MASK) & L2QCMD_THRESHOLD_MASK;
+		if ((tmp > (start + size)) || (tmp < L2QCMD_THRESHOLD))
+			tmp = start + size;
+
+		_set_l2cache_qcmd_size(start, tmp - start, cmd);
+
+		size -= (tmp - start);
+		start = tmp;
+
+		if (size == 0UL)
+			return;
+	}
+
+	if (((start + size) & ~L2QCMD_THRESHOLD_MASK) != 0UL) {
+		tmp = (start + size) & L2QCMD_THRESHOLD_MASK;
+
+		if (tmp < start)
+			tmp = start;
+
+		_set_l2cache_qcmd_size(tmp, (start + size) - tmp, cmd);
+
+		size -= ((start + size) - tmp);
+
+		if (size == 0UL)
+			return;
+	}
+
+	_set_l2cache_qcmd_mask(start, size, cmd);
+}
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+
+/**
+ * L2 cache flush all
+ */
+static void l2ca_flush_all(void)
+{
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+	 _set_l2cache_qcmd_size(0UL, 0UL, L2QCMD_WBINV | L2COQM_S_ALL);
+#else /* CONFIG_MN_L2CACHE_ENABLE */
+	l2ca_sync();
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+}
+
+/**
+ * L2 cache invalidate all
+ */
+static void l2ca_inv_all(void)
+{
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+	_set_l2cache_qcmd_size(0UL, 0UL, L2QCMD_INV | L2COQM_S_ALL);
+#else /* CONFIG_MN_L2CACHE_ENABLE */
+	l2ca_sync();
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+}
+
+/**
+ * L2 cache clean range
+ *
+ * @param start  Start address
+ * @param end    End address
+ */
+static void l2ca_clean_range(unsigned long start, unsigned long end)
+{
+	if (end > start) {
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+		l2ca_qcmd(start, end - start, L2QCMD_WB | L2COQM_S_ADDRESS);
+#else /* CONFIG_MN_L2CACHE_ENABLE */
+		l2ca_sync();
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+	}
+}
+
+/**
+ * L2 cache flush range
+ *
+ * @param start  Start address
+ * @param end    End address
+ */
+static void l2ca_flush_range(unsigned long start, unsigned long end)
+{
+	if (end > start) {
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+		l2ca_qcmd(start, end - start, L2QCMD_WBINV | L2COQM_S_ADDRESS);
+#else /* CONFIG_MN_L2CACHE_ENABLE */
+		l2ca_sync();
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+	}
+}
+
+/**
+ * L2 cache invalidate range
+ *
+ * @param start  Start address
+ * @param end    End address
+ */
+static void l2ca_inv_range(unsigned long start, unsigned long end)
+{
+	if (end > start) {
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+		if ((start & ~L2_CACHE_ADRS_MASK) != 0UL) {
+			start = start & L2_CACHE_ADRS_MASK;
+			_set_l2cache_qcmd_size(start, L2_CACHE_BYTES,
+						L2QCMD_WBINV | L2COQM_S_ADDRESS);
+			start += L2_CACHE_BYTES;
+			if ((end <= start) || (start == 0UL)) {
+				l2ca_sync();
+				return;
+			}
+		}
+		if ((end & ~L2_CACHE_ADRS_MASK) != 0UL) {
+			end = end & L2_CACHE_ADRS_MASK;
+			_set_l2cache_qcmd_size(end, L2_CACHE_BYTES,
+						L2QCMD_WBINV | L2COQM_S_ADDRESS);
+			if (end <= start) {
+				l2ca_sync();
+				return;
+			}
+		}
+		l2ca_qcmd(start, end - start, L2QCMD_INV | L2COQM_S_ADDRESS);
+#else /* CONFIG_MN_L2CACHE_ENABLE */
+		l2ca_sync();
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+	}
+}
+
+static const struct of_device_id l2ca_ids[] __initconst = {
+	{ .compatible = "panasonic,l2-system-cache", },
+	{},
+};
+
+/**
+ * L2 cache initialize
+ *
+ * @retval 0		Success
+ * @retval -ENODEV	Device not found
+ * @retval -ENOENT	Setting is not sufficient
+ * @retval -ENOMEM	Out of Memory
+ */
+static int __init l2ca_init(void)
+{
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+	unsigned int tmp;
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+	struct device_node *np;
+	int ret;
+
+	np = of_find_matching_node(NULL, l2ca_ids);
+	if (np == NULL) {
+		printk(KERN_ERR "l2ca_init: Not found Level2 cache node.\n");
+		return -ENODEV;
+	}
+
+	if (l2ca_uncached_addr == NULL) {
+		printk(KERN_ERR "l2ca_init: uncached address is not set.\n");
+		return -ENOENT;
+	}
+
+	l2ca_reg[0] = of_iomap(np, 0);
+	l2ca_reg[1] = of_iomap(np, 1);
+	l2ca_reg[2] = of_iomap(np, 2);
+	if ((l2ca_reg[0] == NULL) || (l2ca_reg[1] == NULL) || (l2ca_reg[2] == NULL)) {
+		printk(KERN_ERR "l2ca_init: ioremap failed: %p %p %p.\n",
+		       l2ca_reg[0], l2ca_reg[1], l2ca_reg[2]);
+		ret = -ENOMEM;
+		goto init_error;
+	}
+
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+	if ((l2ca_readl(L2CC) & L2CC_ON) != 0U) {
+		goto l2ca_enable_end;
+	}
+
+	l2ca_inv_all();
+
+	tmp = l2ca_readl(L2CC);
+	tmp &= L2CC_MASK;
+	tmp |= L2CC_SETTING;
+	l2ca_writel(tmp, L2CC);
+	tmp = l2ca_readl(L2CC);	/* dummy read */
+
+l2ca_enable_end:
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+	outer_cache.inv_all = l2ca_inv_all;
+	outer_cache.flush_all = l2ca_flush_all;
+	outer_cache.sync = l2ca_sync;
+	outer_cache.inv_range = l2ca_inv_range;
+	outer_cache.clean_range = l2ca_clean_range;
+	outer_cache.flush_range = l2ca_flush_range;
+
+#ifdef CONFIG_MN_L2CACHE_ENABLE
+	printk(KERN_INFO "Level2 cache controller enabled\n");
+#endif /* CONFIG_MN_L2CACHE_ENABLE */
+
+	return 0;
+
+init_error:
+	if (l2ca_reg[0] != NULL) {
+		iounmap(l2ca_reg[0]);
+	}
+	if (l2ca_reg[1] != NULL) {
+		iounmap(l2ca_reg[1]);
+	}
+	if (l2ca_reg[2] != NULL) {
+		iounmap(l2ca_reg[2]);
+	}
+	return ret;
+}
+#ifdef CONFIG_MN_HAS_L2CA
+early_initcall(l2ca_init);
+#endif /* CONFIG_MN_HAS_L2CA */
diff -uNr linux-3.14.19/arch/arm/mm/cache-mn-l2.h linux-gerda/arch/arm/mm/cache-mn-l2.h
--- linux-3.14.19/arch/arm/mm/cache-mn-l2.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/arch/arm/mm/cache-mn-l2.h	2017-06-22 09:52:13.807040411 +0900
@@ -0,0 +1,113 @@
+/*
+ * l2ca-regs.h: L2CA specification
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+#ifndef CACHE_MN_L2_H_
+#define CACHE_MN_L2_H_
+
+#define	L2C_DEF(type, offs)	(((type) << 16U) | (offs))
+
+/* L2C Register 0 */
+#define L2CID	        	L2C_DEF(0U, 0x0100U)	/* ID */
+#define L2CID_REVISION		0x0000007fU	/* revision */
+
+#define L2CINFO			L2C_DEF(0U, 0x0104U)	/* information */
+
+/* L2C Register 1 */
+#define L2CC			L2C_DEF(1U, 0x0000U)	/* control */
+#define L2CC_ON			0x00000001U	/* on */
+#define L2CC_EX			0x00002000U	/* exclusive cache */
+#define L2CC_WA			0x00010000U	/* write allocate for WB */
+#define L2CC_PRD		0x00020000U	/* hardware prefecth */
+#define L2CC_WTG		0x00040000U	/* write gathering for WT */
+#define L2CC_ACT		0x00080000U	/* ID separate active way */
+#define L2CC_ACT_UNIFIED	0x00000000U	/* - ID unified */
+#define L2CC_ACT_SEPARATE	0x00080000U	/* - ID separate */
+#define L2CC_BST		0x00100000U	/* burst read for UCWG */
+#define L2CC_UG			0x00200000U	/* write gathering for UCWG */
+#define L2CC_CPPRD		0x02000000U	/* hardware prefetch for SCP */
+#define L2CC_CPBST		0x10000000U	/* burst read for SCP */
+
+#define L2CC_MASK		0xffffffffU
+#define L2CC_SETTING		L2CC_ON
+
+#define L2CLPDAWCR		L2C_DEF(1U, 0x0030U)	/* active way data LP */
+#define L2CLPIAWCR		L2C_DEF(1U, 0x0034U)	/* active way inst LP */
+#define L2CDAWCR(n)		(L2C_DEF(1U, 0x0c00U) + (n) * 4U)	/* active way data */
+#define L2CIAWCR(n)		(L2C_DEF(1U, 0x1400U) + (n) * 4U)	/* active way inst */
+
+#define L2CSCPAWCR		L2C_DEF(1U, 0x0c80U)	/* SCP active way control */
+#define L2CLCKW			L2C_DEF(1U, 0x0008U)	/* Lock way control */
+
+/* L2C Register 2 */
+#define L2COSYNC		L2C_DEF(2U, 0x0240U)	/* CO sync */
+#define L2COSYNC_CM		0x00000001U	/* execute sync data */
+
+#define L2COPE			L2C_DEF(2U, 0x0244U)	/* CO primitive entry */
+#define L2COPE_CM		0x0000000fU	/* cache command */
+#define L2COPE_CM_INV		0x00000000U	/* - invalidate */
+#define L2COPE_CM_WB		0x00000001U	/* - write back */
+#define L2COPE_CM_WBINV		0x00000002U	/* - write back & invalidate */
+#define L2COPE_CM_SYNC		0x00000008U	/* - sync */
+#define L2COPE_CM_FLSH_PFBUF	0x00000009U	/* - flush pref buff */
+#define L2COPE_SL		0x00000060U	/* subline mode */
+#define L2COPE_ENTRY		0x07ffff80U	/* entry for cache operation */
+#define L2COPE_WAY		0xf8000060U	/* way for cache operation */
+
+#define L2COQM			L2C_DEF(2U, 0x0248U)	/* CO que mode */
+#define L2COQM_CM		0x00000007U	/* cache command */
+#define L2COQM_CM_INV		0x00000000U	/* - invalidate */
+#define L2COQM_CM_WB		0x00000001U	/* - write back */
+#define L2COQM_CM_WBINV		0x00000002U	/* - write back & invalidate */
+#define L2COQM_CM_PF_L2C	0x00000003U	/* - prefecth to L2C */
+#define L2COQM_CM_PF_PFBUF	0x00000004U	/* - prefecth to prefetch buff */
+#define L2COQM_CM_TOUCH		0x00000005U	/* - touch */
+#define L2COQM_CM_TOUCH_ZERO	0x00000006U	/* - touch zero */
+#define L2COQM_CM_TOUCH_DIRTY	0x00000007U	/* - touch dirty */
+#define L2COQM_CW		0x00004000U	/* notification mode */
+#define L2COQM_CW_FLAG		0x00000000U	/* - flag */
+#define L2COQM_CW_FLAG_INT	0x00004000U	/* - flag & interrupt */
+#define L2COQM_CE		0x00008000U	/* notification enable */
+#define L2COQM_S		0x00060000U	/* specification mode */
+#define L2COQM_S_ADDRESS	0x00000000U	/* - address (range/line) */
+#define L2COQM_S_ALL		0x00020000U	/* - all */
+#define L2COQM_S_WAY		0x00040000U	/* - way */
+#define L2COQM_TID		0x00600000U	/* destination */
+#define L2COQM_TID_DAWCR	0x00000000U	/* - LRU/data active way (when CM=3,5,6,7) */
+#define L2COQM_TID_IAWCR	0x00200000U	/* - LRU/inst active way (when CM=3,5,6,7) */
+#define L2COQM_TID_WAY		0x00400000U	/* - specified way (when CM=3,5,6,7) */
+#define L2COQM_TID_DPFBUF	0x00000000U	/* - data pref buff (when CM=4) */
+#define L2COQM_TID_IPFBUF	0x00200000U	/* - inst pref buff (when CM=4) */
+
+#define L2COQAD			L2C_DEF(2U, 0x024cU)	/* CO que addresss */
+
+#define L2COQSZ			L2C_DEF(2U, 0x0250U)	/* CO que size */
+#define L2COQSZ_SIZE		0x003fffffU	/* size */
+
+#define L2COQMASK		L2C_DEF(2U, 0x0254U)	/* CO que mask */
+
+#define L2COQWN			L2C_DEF(2U, 0x0258U)	/* CO que way num */
+
+#define L2COPPQSEF		L2C_DEF(2U, 0x025cU)	/* CO que set flag PP */
+#define L2COPPQSEF_OE		0x00000001U	/* failure except for que full */
+#define L2COPPQSEF_FE		0x00000002U	/* failure for que full */
+#define L2COPPQSEF_QN		0x00000300U	/* number of set queue */
+
+#define L2COLPQS		L2C_DEF(2U, 0x0260U)	/* CO que status LP */
+#define L2COLPQS_QST		0x00000001U	/* que status flag */
+#define L2COLPQS_EST		0x00000002U	/* que error flag */
+#define L2COLPQS_EF		0x00000004U	/* complete flag */
+
+#define L2COQCEARM		L2C_DEF(2U, 0x0280U)	/* CO que cmd complete flag */
+
+#define L2COQCSARM		L2C_DEF(2U, 0x02a0U)	/* CO que cmd status */
+
+#define L2COQS(n)		L2C_DEF(2U, 0x02c0U + (n) * 4U)	/* CO que status */
+#define L2COQS_QST		0x00000001U
+#define L2COQS_EST		0x00000002U
+#define L2COQS_EF		0x00000004U
+
+#endif /* CACHE_MN_L2_H_ */
diff -uNr linux-3.14.19/arch/arm/mm/cache-v7.S linux-gerda/arch/arm/mm/cache-v7.S
--- linux-3.14.19/arch/arm/mm/cache-v7.S	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/cache-v7.S	2017-06-22 09:52:13.811040410 +0900
@@ -15,6 +15,9 @@
 #include <asm/assembler.h>
 #include <asm/errno.h>
 #include <asm/unwind.h>
+#ifdef CONFIG_MN_HAS_L2CA
+#include <asm/cache.h>
+#endif /* CONFIG_MN_HAS_L2CA */
 
 #include "proc-macros.S"
 
@@ -350,6 +353,24 @@
  *	- end     - virtual end address of region
  */
 v7_dma_inv_range:
+#ifdef CONFIG_MN_HAS_L2CA
+	stmfd	sp!, {r0-r3, lr}
+	mov	r2, #L2_CACHE_BYTES
+	sub	r3, r2, #1
+	tst	r0, r3
+	bicne	r0, r0, r3
+	addne	r1, r0, r2
+	blne	v7_dma_flush_range
+	ldmfd	sp!, {r0-r3, lr}
+	stmfd	sp!, {r0-r3, lr}
+	mov	r2, #L2_CACHE_BYTES
+	sub	r3, r2, #1
+	tst	r1, r3
+	bicne	r0, r1, r3
+	addne	r1, r0, r2
+	blne	v7_dma_flush_range
+	ldmfd	sp!, {r0-r3, lr}
+#endif /* CONFIG_MN_HAS_L2CA */
 	dcache_line_size r2, r3
 	sub	r3, r2, #1
 	tst	r0, r3
@@ -379,7 +400,14 @@
  */
 v7_dma_clean_range:
 	dcache_line_size r2, r3
+#ifdef CONFIG_MN_HAS_L2CA
+	mov	r3, #L2_CACHE_BYTES
+	sub	r3, r3, #1
+	add	r1, r1, r3
+	bic	r1, r1, r3
+#else /* CONFIG_MN_HAS_L2CA */
 	sub	r3, r2, #1
+#endif /* CONFIG_MN_HAS_L2CA */
 	bic	r0, r0, r3
 #ifdef CONFIG_ARM_ERRATA_764369
 	ALT_SMP(W(dsb))
@@ -401,7 +429,14 @@
  */
 ENTRY(v7_dma_flush_range)
 	dcache_line_size r2, r3
+#ifdef CONFIG_MN_HAS_L2CA
+	mov	r3, #L2_CACHE_BYTES
+	sub	r3, r3, #1
+	add	r1, r1, r3
+	bic	r1, r1, r3
+#else /* CONFIG_MN_HAS_L2CA */
 	sub	r3, r2, #1
+#endif /* CONFIG_MN_HAS_L2CA */
 	bic	r0, r0, r3
 #ifdef CONFIG_ARM_ERRATA_764369
 	ALT_SMP(W(dsb))
diff -uNr linux-3.14.19/arch/arm/mm/context.c linux-gerda/arch/arm/mm/context.c
--- linux-3.14.19/arch/arm/mm/context.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/context.c	2017-06-22 09:52:13.819040410 +0900
@@ -42,6 +42,10 @@
 #define ASID_FIRST_VERSION	(1ULL << ASID_BITS)
 #define NUM_USER_ASIDS		ASID_FIRST_VERSION
 
+#ifdef CONFIG_KMC_NOTIFY_UPDATE_CONTEXTID
+#include <linux/kmc.h>
+#endif
+
 static DEFINE_RAW_SPINLOCK(cpu_asid_lock);
 static atomic64_t asid_generation = ATOMIC64_INIT(ASID_FIRST_VERSION);
 static DECLARE_BITMAP(asid_map, NUM_USER_ASIDS);
@@ -243,6 +247,9 @@
 	asid = atomic64_read(&mm->context.id);
 	if ((asid ^ atomic64_read(&asid_generation)) >> ASID_BITS) {
 		asid = new_context(mm, cpu);
+#ifdef CONFIG_KMC_NOTIFY_UPDATE_CONTEXTID
+		__kmc_notify_update_contextid(mm, asid);
+#endif
 		atomic64_set(&mm->context.id, asid);
 	}
 
diff -uNr linux-3.14.19/arch/arm/mm/idmap.c linux-gerda/arch/arm/mm/idmap.c
--- linux-3.14.19/arch/arm/mm/idmap.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/idmap.c	2017-06-22 09:52:13.819040410 +0900
@@ -50,9 +50,17 @@
 	pmd_t *pmd = pmd_offset(pud, addr);
 
 	addr = (addr & PMD_MASK) | prot;
+#ifdef CONFIG_ARM_ERRATA_782773
+	set_pmd(&pmd[0], __pmd(addr));
+#else
 	pmd[0] = __pmd(addr);
+#endif
 	addr += SECTION_SIZE;
+#ifdef CONFIG_ARM_ERRATA_782773
+	set_pmd(&pmd[1], __pmd(addr));
+#else
 	pmd[1] = __pmd(addr);
+#endif
 	flush_pmd_entry(pmd);
 }
 #endif	/* CONFIG_ARM_LPAE */
diff -uNr linux-3.14.19/arch/arm/mm/ioremap.c linux-gerda/arch/arm/mm/ioremap.c
--- linux-3.14.19/arch/arm/mm/ioremap.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/ioremap.c	2017-06-22 09:52:13.815040410 +0900
@@ -201,9 +201,17 @@
 	pud = pud_offset(pgd, addr);
 	pmd = pmd_offset(pud, addr);
 	do {
+#ifdef CONFIG_ARM_ERRATA_782773
+		set_pmd(&pmd[0], __pmd(__pfn_to_phys(pfn) | type->prot_sect));
+#else
 		pmd[0] = __pmd(__pfn_to_phys(pfn) | type->prot_sect);
+#endif
 		pfn += SZ_1M >> PAGE_SHIFT;
+#ifdef CONFIG_ARM_ERRATA_782773
+		set_pmd(&pmd[1], __pmd(__pfn_to_phys(pfn) | type->prot_sect));
+#else
 		pmd[1] = __pmd(__pfn_to_phys(pfn) | type->prot_sect);
+#endif
 		pfn += SZ_1M >> PAGE_SHIFT;
 		flush_pmd_entry(pmd);
 
@@ -240,8 +248,13 @@
 		super_pmd_val |= ((pfn >> (32 - PAGE_SHIFT)) & 0xf) << 20;
 
 		for (i = 0; i < 8; i++) {
+#ifdef CONFIG_ARM_ERRATA_782773
+			set_pmd(&pmd[0], __pmd(super_pmd_val));
+			set_pmd(&pmd[1], __pmd(super_pmd_val));
+#else
 			pmd[0] = __pmd(super_pmd_val);
 			pmd[1] = __pmd(super_pmd_val);
+#endif
 			flush_pmd_entry(pmd);
 
 			addr += PMD_SIZE;
diff -uNr linux-3.14.19/arch/arm/mm/mmu.c linux-gerda/arch/arm/mm/mmu.c
--- linux-3.14.19/arch/arm/mm/mmu.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/mmu.c	2017-06-22 09:52:13.811040410 +0900
@@ -707,7 +707,11 @@
 		pmd++;
 #endif
 	do {
+#ifdef CONFIG_ARM_ERRATA_782773
+		set_pmd(pmd, __pmd(phys | type->prot_sect));
+#else
 		*pmd = __pmd(phys | type->prot_sect);
+#endif
 		phys += SECTION_SIZE;
 	} while (pmd++, addr += SECTION_SIZE, addr != end);
 
@@ -812,7 +816,11 @@
 		int i;
 
 		for (i = 0; i < 16; i++)
+#ifdef CONFIG_ARM_ERRATA_782773
+			set_pmd(pmd++, __pmd(phys | type->prot_sect | PMD_SECT_SUPER));
+#else
 			*pmd++ = __pmd(phys | type->prot_sect | PMD_SECT_SUPER);
+#endif
 
 		addr += SUPERSECTION_SIZE;
 		phys += SUPERSECTION_SIZE;
diff -uNr linux-3.14.19/arch/arm/mm/proc-v7-2level.S linux-gerda/arch/arm/mm/proc-v7-2level.S
--- linux-3.14.19/arch/arm/mm/proc-v7-2level.S	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/arch/arm/mm/proc-v7-2level.S	2017-06-22 09:52:13.807040411 +0900
@@ -100,9 +100,24 @@
 	tstne	r1, #L_PTE_NONE
 	moveq	r3, #0
 
+#ifdef CONFIG_ARM_ERRATA_782773
+	mrs	ip, cpsr
+	cpsid	i
+	add	r0, r0, #2048
+#ifdef CONFIG_ARM_ERRATA_764369
+	ALT_SMP(W(dsb))
+	ALT_UP(W(nop))
+#endif
+	mcr	p15, 0, r0, c7, c14, 1		@ clean & invalidate pte
+	dsb
+	str	r3, [r0]
+	dsb
+	msr	cpsr_c, ip
+#else
  ARM(	str	r3, [r0, #2048]! )
  THUMB(	add	r0, r0, #2048 )
  THUMB(	str	r3, [r0] )
+#endif
 	ALT_SMP(W(nop))
 	ALT_UP (mcr	p15, 0, r0, c7, c10, 1)		@ flush_pte
 #endif
diff -uNr linux-3.14.19/drivers/dma/Kconfig linux-gerda/drivers/dma/Kconfig
--- linux-3.14.19/drivers/dma/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/dma/Kconfig	2017-06-22 09:52:44.675039492 +0900
@@ -351,6 +351,17 @@
 	help
 	  Enable support for the MOXA ART SoC DMA controller.
 
+config MN_DMA
+	bool "Panasonic SOCs SDMA support"
+	depends on DMADEVICES && SERIAL_8250_MN_SDMA
+	default SERIAL_8250_MN_SDMA
+	select DMA_ENGINE
+	select DMA_OF
+	select DMA_VIRTUAL_CHANNELS
+	help
+	  Selecting this option will add support for the Stream DMA Controller
+	  hardware found on the Panasonic SOCs.
+
 config DMA_ENGINE
 	bool
 
diff -uNr linux-3.14.19/drivers/dma/Makefile linux-gerda/drivers/dma/Makefile
--- linux-3.14.19/drivers/dma/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/dma/Makefile	2017-06-22 09:52:44.763039490 +0900
@@ -44,3 +44,4 @@
 obj-$(CONFIG_TI_CPPI41) += cppi41.o
 obj-$(CONFIG_K3_DMA) += k3dma.o
 obj-$(CONFIG_MOXART_DMA) += moxart-dma.o
+obj-$(CONFIG_MN_DMA) += mn-dma.o
diff -uNr linux-3.14.19/drivers/dma/mn-dma.c linux-gerda/drivers/dma/mn-dma.c
--- linux-3.14.19/drivers/dma/mn-dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/dma/mn-dma.c	2017-06-22 09:52:44.767039490 +0900
@@ -0,0 +1,803 @@
+/*
+ * Panasonic SoCs DMA Engine support.
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/dmaengine.h>
+#include <linux/dma-mapping.h>
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/of_device.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_dma.h>
+#include <linux/bitops.h>
+#include <linux/serial_8250.h>
+#include <linux/time.h>
+
+#include <asm/cacheflush.h>
+
+#include <asm/rt3.h>
+
+#include "dmaengine.h"
+#include "virt-dma.h"
+
+#define CDGSD_STRT		(0x00)
+#define CDGSD_PERFCNFG		(0x08)
+#define CDGSD_CAUSE		(0x10)
+#define CDGSD_STAT		(0x20)
+#define CDGSD_PARTRESET		(0x50)
+#define	CDGSD_MONNUM		(0x58)
+#define CDGSD_MONDAT		(0x5c)
+#define CDGSD_CHnCTRL1(n)	(0x100+(0x40*(n))+0x00)
+#define CDGSD_CHnCTRL2(n)	(0x100+(0x40*(n))+0x04)
+#define CDGSD_CHnCAUSECTRL(n)	(0x100+(0x40*(n))+0x0C)
+#define CDGSD_CHnSRCAMODE(n)	(0x100+(0x40*(n))+0x20)
+#define CDGSD_CHnDSTAMODE(n)	(0x100+(0x40*(n))+0x24)
+#define CDGSD_CHnSRCSTRTADRS(n)	(0x100+(0x40*(n))+0x28)
+#define CDGSD_CHnDSTSTRTADRS(n)	(0x100+(0x40*(n))+0x2C)
+#define CDGSD_CHnSIZE(n)	(0x100+(0x40*(n))+0x30)
+#define CDGSD_CHnSTAT(n)	(0x100+(0x40*(n))+0x10)
+#define CDGSD_CHnIR(n)		(0x100+(0x40*(n))+0x14)
+#define CDGSD_CHnIE(n)		(0x100+(0x40*(n))+0x18)
+#define CDGSD_CHnID(n)		(0x100+(0x40*(n))+0x1C)
+#define CDGSD_STRT_STOP_BIT	(0x80000000UL)
+#define CDGSD_STRT_PAGE_BIT	(0x01000000UL)
+#define CDGSD_STRT_REQ_MASK	(0x00000033UL)
+#define CDGSD_CHnIR_ERIR1_BIT	(0x00020000UL)
+#define CDGSD_CHnIR_CHIR13_BIT	(0x00002000UL)
+#define CDGSD_CHnIR_CHIR4_BIT	(0x00000010UL)
+#define CDGSD_CHnIR_CHIR1_BIT	(0x00000002UL)
+#define CDGSD_CHnIE_ERIE1_BIT	(0x00020000UL)
+#define CDGSD_CHnIE_CHIE13_BIT	(0x00002000UL)
+#define CDGSD_CHnIE_CHIE4_BIT	(0x00000010UL)
+#define CDGSD_CHnIE_CHIE1_BIT	(0x00000002UL)
+#define CDGSD_CHnID_ERID1_BIT	(0x00020000UL)
+#define CDGSD_CHnID_CHID13_BIT	(0x00002000UL)
+#define CDGSD_CHnID_CHID4_BIT	(0x00000010UL)
+#define CDGSD_CHnID_CHID1_BIT	(0x00000002UL)
+#define CDGSD_PARTRESET_WFLG	(0x80000000UL)
+#define CDGSD_CHnSTAT_CHSTAT4	(0x00000010UL)
+
+#if defined(CONFIG_MACH_GERDA3)
+#define CDGSD_PARTRESET_SSIF	13
+#define IRQ_BASE		141
+#elif defined(CONFIG_MACH_GERDAC)
+#define CDGSD_PARTRESET_SSIF	17
+#define IRQ_BASE		169
+#endif
+
+#define CDGSD_CHnSRCAMODE_TYPE	2
+#define MN_DMA_MAX_CHANNEL	17
+
+#define MN_DMA_DATA_TYPE_S8	(0x00)
+#define MN_DMA_DATA_TYPE_S16	(0x01)
+#define MN_DMA_DATA_TYPE_S32	(0x02)
+
+#undef CHECK_TERMINATE_TIME
+
+struct mn_dma_sg {
+	dma_addr_t addr;
+	uint32_t len;
+};
+
+struct mn_dma_desc {
+	enum dma_transfer_direction	dma_dir;
+	dma_addr_t			dev_addr;
+	unsigned int			sglen;
+	unsigned int			dma_cycles;
+	struct virt_dma_desc		vd;
+	uint8_t				es;
+	struct mn_dma_sg		sg[0];
+};
+
+struct mn_dma_chan {
+	struct virt_dma_chan		vc;
+
+	void __iomem			*base;
+	struct mn_dma_desc		*desc;
+
+	struct dma_slave_config		cfg;
+
+	bool				allocated;
+	bool				error;
+	int				ch_num;
+	int				irq_no;
+	unsigned int			line_reqno;
+	unsigned int			sgidx;
+	struct completion		*pdone;
+};
+
+struct mn_dma_dmadev {
+	struct dma_device		dma_slave;
+	struct mn_dma_chan		slave_chans[MN_DMA_MAX_CHANNEL];
+	unsigned int			dma_channels;
+	struct completion		done;
+};
+
+struct mn_dma_filter_data {
+	struct mn_dma_dmadev		*mdc;
+	struct of_phandle_args		*dma_spec;
+};
+
+static const unsigned int es_bytes[] = {
+	[MN_DMA_DATA_TYPE_S8] = 1,
+	[MN_DMA_DATA_TYPE_S16] = 2,
+	[MN_DMA_DATA_TYPE_S32] = 4,
+};
+
+static struct device *chan2dev(struct dma_chan *chan)
+{
+	return &chan->dev->device;
+}
+
+static inline struct mn_dma_chan *to_mn_dma_chan(struct dma_chan *c)
+{
+	return container_of(c, struct mn_dma_chan, vc.chan);
+}
+
+static inline struct mn_dma_desc *to_mn_dma_desc(
+	struct dma_async_tx_descriptor *t)
+{
+	return container_of(t, struct mn_dma_desc, vd.tx);
+}
+
+static void mn_dma_desc_free(struct virt_dma_desc *vd)
+{
+	kfree(container_of(vd, struct mn_dma_desc, vd));
+}
+
+static int mn_dma_terminate_all(struct dma_chan *chan)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	struct virt_dma_desc	*pvdd;
+	unsigned long flags;
+	LIST_HEAD(head);
+#ifdef CHECK_TERMINATE_TIME
+	struct timeval	stv, etv;
+#endif
+	u32 ojif;
+	u32 ctrl;
+	u32 ch_bit;
+
+	dev_dbg(chan2dev(chan), "%s: ch=%p\n", __func__, ch);
+
+	spin_lock_irqsave(&ch->vc.lock, flags);
+
+	writel(0x00000000, ch->base + CDGSD_CHnIE(ch->ch_num));
+
+	if (ch->desc) {
+		pvdd = &ch->desc->vd;
+		mn_dma_desc_free(&ch->desc->vd);
+		ch->desc = NULL;
+	}
+
+	ch_bit = 0;
+	ch_bit |= 1<<ch->ch_num;
+	ctrl = 0;
+	ctrl |= CDGSD_STRT_STOP_BIT;
+	ctrl &= ~CDGSD_STRT_PAGE_BIT;
+	ctrl |= (ch_bit & CDGSD_STRT_REQ_MASK);
+	ch->line_reqno++;
+
+#ifdef CHECK_TERMINATE_TIME
+	do_gettimeofday(&stv);
+#endif
+
+	writel(ctrl, ch->base + CDGSD_STRT);
+	ctrl = readl(ch->base + CDGSD_STRT);
+	dev_dbg(chan2dev(chan), "%s: ch=%p\n", __func__, ch);
+
+	vchan_get_all_descriptors(&ch->vc, &head);
+	spin_unlock_irqrestore(&ch->vc.lock, flags);
+	vchan_dma_desc_free_list(&ch->vc, &head);
+	ojif = jiffies;
+	while(readl(ch->base+CDGSD_CHnSTAT(ch->ch_num)) &
+	      CDGSD_CHnSTAT_CHSTAT4) {
+		if ((ojif + 1) < jiffies) {
+			dev_warn(chan2dev(chan), "%s:o(%d),n(%d)c(%d)\n", __func__, (int)ojif, (int)jiffies, ch->line_reqno);
+			break;
+		}
+	}
+
+#ifdef CHECK_TERMINATE_TIME
+	do_gettimeofday(&etv);
+
+	{
+		u32	tv_usec = etv.tv_usec - stv.tv_usec;
+
+		if (tv_usec >= 4) {
+			chan->terminate_tv.tv_usec = tv_usec;
+			chan->terminate_tv.tv_sec = etv.tv_sec - stv.tv_sec;
+			/* _TRC_usr_log_ext(0xEF, tv_usec); */
+			/* printk("%s:s(%d),e(%d)\n", __func__, (int)stv.tv_usec, (int)etv.tv_usec); */
+		}
+	}
+#endif
+
+	return 0;
+}
+
+static int mn_dma_slave_config(struct dma_chan *chan,
+			       struct dma_slave_config *cfg)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	u32 src_mode, dst_mode;
+
+	ch->cfg = *cfg;
+	src_mode = readl(ch->base + CDGSD_CHnSRCAMODE(ch->ch_num));
+	dst_mode = readl(ch->base + CDGSD_CHnDSTAMODE(ch->ch_num));
+
+	if (ch->cfg.direction == DMA_MEM_TO_DEV) {
+		src_mode &= ~0x00000030;
+		src_mode |=  0x00000000;
+		dst_mode &= ~0x00000030;
+		dst_mode |=  0x00000020;
+	} else {
+		src_mode &= ~0x00000030;
+		src_mode |=  0x00000020;
+		dst_mode &= ~0x00000030;
+		dst_mode |=  0x00000000;
+	}
+
+	writel(src_mode, ch->base + CDGSD_CHnSRCAMODE(ch->ch_num));
+	writel(dst_mode, ch->base + CDGSD_CHnDSTAMODE(ch->ch_num));
+
+	return 0;
+}
+
+static int mn_dma_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
+			  unsigned long arg)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case DMA_PAUSE:
+	case DMA_RESUME:
+		return -EINVAL;
+	case DMA_TERMINATE_ALL:
+		mn_dma_terminate_all(chan);
+		break;
+	case DMA_SLAVE_CONFIG:
+		ret = mn_dma_slave_config(chan, (struct dma_slave_config *)arg);
+		break;
+	default:
+		ret = -ENOSYS;
+	}
+
+	return ret;
+}
+
+static struct dma_async_tx_descriptor *mn_dma_prep_slave_sg(
+	struct dma_chan *chan, struct scatterlist *sgl,
+	unsigned int sg_len, enum dma_transfer_direction dir,
+	unsigned long tx_flags, void *context)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	struct mn_dma_desc *d;
+	enum dma_slave_buswidth dev_width;
+	dma_addr_t dev_addr;
+	struct scatterlist *sgent;
+	unsigned int es;
+	unsigned int i;
+
+	if (!is_slave_direction(dir)) {
+		dev_err(chan2dev(chan), "%s: invalid DMA direction\n",
+			__func__);
+		return NULL;
+	}
+
+	if (dir == DMA_DEV_TO_MEM) {
+		dev_addr = ch->cfg.src_addr;
+		dev_width = ch->cfg.src_addr_width;
+	} else {
+		dev_addr = ch->cfg.dst_addr;
+		dev_width = ch->cfg.dst_addr_width;
+	}
+
+	switch (dev_width) {
+	case DMA_SLAVE_BUSWIDTH_1_BYTE:
+		es = MN_DMA_DATA_TYPE_S8;
+		break;
+	default:
+		dev_err(chan2dev(chan), "%s: unsupported data width (%u)\n",
+			__func__, dev_width);
+		return NULL;
+	}
+
+	d = kzalloc(sizeof(*d) + sg_len * sizeof(d->sg[0]), GFP_ATOMIC);
+	if (!d)
+		return NULL;
+
+	d->dma_dir = dir;
+	d->dev_addr = dev_addr;
+	d->es = es;
+
+	for_each_sg(sgl, sgent, sg_len, i) {
+		d->sg[i].addr = sg_dma_address(sgent);
+		d->sg[i].len = sg_dma_len(sgent);
+	}
+
+	d->sglen = sg_len;
+
+	ch->error = 0;
+
+	return vchan_tx_prep(&ch->vc, &d->vd, tx_flags);
+}
+
+static struct dma_chan *mn_dma_of_xlate(struct of_phandle_args *dma_spec,
+					struct of_dma *ofdma)
+{
+	struct mn_dma_dmadev *mdc = ofdma->of_dma_data;
+	struct dma_chan *chan, *ret_chan;
+
+	chan = &mdc->slave_chans[dma_spec->args[0]].vc.chan;
+	ret_chan = dma_get_slave_channel(chan);
+	if (ret_chan == NULL) {
+		dev_err(chan2dev(chan), "dma_get_slave_channel error\n");
+		return NULL;
+	}
+
+	return chan;
+}
+
+static int mn_dma_alloc_chan_resources(struct dma_chan *chan)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+
+	dev_dbg(chan2dev(chan), "%s: allocating channel #%u\n",
+		__func__, ch->ch_num);
+	ch->allocated = 1;
+
+	return 0;
+}
+
+static void mn_dma_free_chan_resources(struct dma_chan *chan)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+
+	vchan_free_chan_resources(&ch->vc);
+
+	dev_dbg(chan2dev(chan), "%s: freeing channel #%u\n",
+		__func__, ch->ch_num);
+	ch->allocated = 0;
+}
+
+static void mn_dma_set_params(struct mn_dma_chan *ch, dma_addr_t src_addr,
+				  dma_addr_t dst_addr)
+{
+	u32	ctrl_s, ctrl_d;
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: ch(%d) src(%p) dst(%p)\n",
+		 __func__, ch->ch_num, (void *)src_addr, (void *)dst_addr);
+	writel(src_addr, ch->base + CDGSD_CHnSRCSTRTADRS(ch->ch_num));
+	ctrl_s = readl(ch->base + CDGSD_CHnSRCSTRTADRS(ch->ch_num));
+	writel(dst_addr, ch->base + CDGSD_CHnDSTSTRTADRS(ch->ch_num));
+	ctrl_d = readl(ch->base + CDGSD_CHnDSTSTRTADRS(ch->ch_num));
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: ch(%d) src(%p) dst(%p)\n",
+		 __func__, ch->ch_num, (void *)ctrl_s, (void *)ctrl_d);
+}
+
+static void mn_dma_set_transfer_params(struct mn_dma_chan *ch, unsigned int len)
+{
+	struct mn_dma_desc *d = ch->desc;
+	u32	ctrl;
+
+	d->dma_cycles = len;
+	writel(d->dma_cycles, ch->base + CDGSD_CHnSIZE(ch->ch_num));
+	if (ch->desc->dma_dir == DMA_DEV_TO_MEM) {
+		ch->cfg.setsize(ch->cfg.size_param, d->dma_cycles);	/* UAnSIZL set */
+	}
+
+	ctrl = (CDGSD_CHnIR_ERIR1_BIT | CDGSD_CHnIR_CHIR13_BIT |
+		CDGSD_CHnIR_CHIR4_BIT | CDGSD_CHnIR_CHIR1_BIT);
+
+	writel(ctrl, ch->base + CDGSD_CHnIR(ch->ch_num));
+
+	ctrl = (CDGSD_CHnIE_ERIE1_BIT | CDGSD_CHnIE_CHIE13_BIT |
+		CDGSD_CHnIE_CHIE1_BIT);
+
+	writel(ctrl, ch->base + CDGSD_CHnIE(ch->ch_num));
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: set %u DMA cycles (len=%u) CHnIE(%p)\n",
+		 __func__, d->dma_cycles, len, (void *)ctrl);
+}
+
+static void mn_dma_start_dma(struct mn_dma_chan *ch)
+{
+	u32 ctrl;
+	u32 ch_bit;
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: start dma ch(%d)\n",
+		 __func__, ch->ch_num);
+	ch_bit = 0;
+	ch_bit |= 1 << ch->ch_num;
+	ctrl = 0;
+	ctrl &= ~CDGSD_STRT_STOP_BIT;	/* start:bit[31]=0,stop:bit[31]=1 */
+	ctrl &= ~CDGSD_STRT_PAGE_BIT;	/* page0:bit[27:24]=0,page1:bit[27:24]=1 */
+	ctrl |= ch_bit & CDGSD_STRT_REQ_MASK;	/* uart0:bit[1:0],uart1:bit[5:4] */
+
+	writel(ctrl, ch->base + CDGSD_STRT);
+}
+
+static void mn_dma_start_sg(struct mn_dma_chan *ch, unsigned int idx)
+{
+	struct mn_dma_desc *d = ch->desc;
+	struct mn_dma_sg *sg = ch->desc->sg + idx;
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: addr(%p),len(%d)\n",
+		__func__, (void *)sg->addr, sg->len);
+	if (ch->desc->dma_dir == DMA_MEM_TO_DEV) {
+		mn_dma_set_params(ch, sg->addr, (d->dev_addr & 0x00000000));
+	} else if (ch->desc->dma_dir == DMA_DEV_TO_MEM) {
+		mn_dma_set_params(ch, (d->dev_addr & 0x00000000), sg->addr);
+	}
+
+	mn_dma_set_transfer_params(ch, sg->len);
+
+	mn_dma_start_dma(ch);
+}
+
+static void mn_dma_start_desc(struct dma_chan *chan)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	struct virt_dma_desc *vd;
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: enter\n", __func__);
+	vd = vchan_next_desc(&ch->vc);
+
+	if (!vd) {
+		ch->desc = NULL;
+		return;
+	}
+
+	list_del(&vd->node);
+
+	ch->desc = to_mn_dma_desc(&vd->tx);
+	ch->sgidx = 0;
+
+	mn_dma_start_sg(ch, 0);
+}
+
+static void mn_dma_issue_pending(struct dma_chan *chan)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	unsigned long flags;
+	unsigned int	ctrl;
+
+	spin_lock_irqsave(&ch->vc.lock, flags);
+	if (vchan_issue_pending(&ch->vc) && !ch->desc) {
+
+		ctrl = CDGSD_PARTRESET_WFLG;
+		ctrl |= 1<<ch->ch_num;	/* channel reset on */
+		ctrl |= 1<<(ch->ch_num + CDGSD_PARTRESET_SSIF);
+					/* channel SSIF on */
+		writel(ctrl, ch->base + CDGSD_PARTRESET);
+		if (ch->cfg.direction == DMA_DEV_TO_MEM)
+			reinit_completion(ch->pdone);
+
+		mn_dma_start_desc(chan);
+	}
+	spin_unlock_irqrestore(&ch->vc.lock, flags);
+}
+
+static size_t mn_dma_desc_size(struct mn_dma_desc *d,
+				   unsigned int completed_sgs)
+{
+	unsigned int i;
+	size_t size;
+
+	for (size = i = completed_sgs; i < d->sglen; i++)
+		size += d->sg[i].len;
+
+	return size;
+}
+
+static size_t mn_dma_desc_size_in_flight(struct mn_dma_chan *ch)
+{
+	size_t size;
+	unsigned int completed_cycles, cycles;
+
+	size = mn_dma_desc_size(ch->desc, ch->sgidx);
+	if (ch->cfg.getsize != NULL)
+		cycles = ch->cfg.getsize(ch->cfg.size_param);
+	else
+		cycles = readl(ch->base + CDGSD_CHnSIZE(ch->ch_num));
+	completed_cycles = (ch->desc->dma_cycles - cycles);
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: completed(%d,%d)size(%d)\n", __func__, completed_cycles, cycles, size);
+	size -= completed_cycles;
+
+	return size;
+}
+
+static enum dma_status mn_dma_tx_status(struct dma_chan *chan,
+					dma_cookie_t cookie,
+					struct dma_tx_state *txstate)
+{
+	struct mn_dma_chan *ch = to_mn_dma_chan(chan);
+	struct virt_dma_desc *vd;
+	struct mn_dma_desc *d;
+	enum dma_status ret;
+	unsigned long flags;
+
+	/*
+	 * dma_cookie_status() assigns initial residue value.
+	 */
+	ret = dma_cookie_status(chan, cookie, txstate);
+
+	spin_lock_irqsave(&ch->vc.lock, flags);
+	vd = vchan_find_desc(&ch->vc, cookie);
+	if (vd) {
+		d = to_mn_dma_desc(&vd->tx);
+		txstate->residue = mn_dma_desc_size(d, 0);
+	} else if (ch->desc && ch->desc->vd.tx.cookie == cookie) {
+		txstate->residue = mn_dma_desc_size_in_flight(ch);
+	}
+	spin_unlock_irqrestore(&ch->vc.lock, flags);
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s: size(%d)ret(%d)\n",
+		 __func__, txstate->residue, ret);
+
+	if (ch->error)
+		return DMA_ERROR;
+
+	return ret;
+}
+
+/**
+ * Interrupt handler for DMA driver
+ *
+ * @param irq       Platform device
+ * @param devid     DMA device
+ * @retval IRQ_HANDLED	Success
+ */
+static irqreturn_t mn_dma_interrupt(int irq, void *devid)
+{
+	struct mn_dma_dmadev *mc = devid;
+	struct mn_dma_chan *ch = &mc->slave_chans[0];
+	unsigned int i;
+	unsigned long flags;
+	u32 ctrl;
+
+	dev_dbg(chan2dev(&ch->vc.chan), "%s(%d,%p)\n", __func__, irq, devid);
+
+	for (i = 0; i < MN_DMA_MAX_CHANNEL; i++, ch++) {
+		if (!ch->allocated)
+			continue;
+		if (i != irq - IRQ_BASE)
+			continue;
+
+		ctrl = readl(ch->base + CDGSD_CHnID(ch->ch_num));
+
+#if 0
+		if (ch->cfg.direction == DMA_DEV_TO_MEM) {
+			if (ctrl == 2)
+				_TRC_usr_log_ext(0xEB, ctrl);
+			else
+				_TRC_usr_log_ext(0xEF, ctrl);
+		}
+#endif
+		dev_dbg(chan2dev(&ch->vc.chan),
+			"%s: ch=%p ch->base=%p ctrl=%x\n",
+			__func__, ch, ch->base, ctrl);
+
+		if ((ctrl & CDGSD_CHnID_CHID13_BIT) != 0 &&
+		    (ch->cfg.direction == DMA_DEV_TO_MEM)) {
+			dev_dbg(chan2dev(&ch->vc.chan),
+				 "%s: ch=%p ch->base=%p ctrl=%x\n",
+				 __func__, ch, ch->base, ctrl);
+			complete(ch->pdone);
+		}
+		if (((ctrl & CDGSD_CHnID_CHID1_BIT) != 0) &&
+		    ((ctrl & CDGSD_CHnID_ERID1_BIT) == 0)) {
+			if (ch->desc) {
+				spin_lock_irqsave(&ch->vc.lock, flags);
+				if (++ch->sgidx < ch->desc->sglen) {
+					if (ch->cfg.direction == DMA_DEV_TO_MEM)
+						dev_err(chan2dev(&ch->vc.chan),
+							"%s:_SG ch=%p base=%p sgi=%d sgl=%d ctrl=%x\n",
+							__func__, ch, ch->base, ch->sgidx, ch->desc->sglen, ctrl);
+					mn_dma_start_sg(ch, ch->sgidx);
+				} else {
+					if (ch->cfg.direction == DMA_DEV_TO_MEM)
+						dev_err(chan2dev(&ch->vc.chan),
+							"%s:_DS ch=%p base=%p sgi=%d sgl=%d ctrl=%x\n",
+							__func__, ch, ch->base, ch->sgidx, ch->desc->sglen, ctrl);
+					complete(ch->pdone);
+					vchan_cookie_complete(&ch->desc->vd);
+					mn_dma_start_desc(&ch->vc.chan);
+				}
+				spin_unlock_irqrestore(&ch->vc.lock, flags);
+			}
+		}
+
+		if (ctrl & CDGSD_CHnID_ERID1_BIT) {
+			if (ch->cfg.direction == DMA_DEV_TO_MEM)
+				dev_err(chan2dev(&ch->vc.chan),
+					"%s:ERID ch=%p base=%p sgi=%d sgl=%d ctrl=%x\n",
+					__func__, ch, ch->base, ch->sgidx, ch->desc->sglen, ctrl);
+			/* ctrl &= ~CDGSD_CHnIR_ERIR1_BIT; */
+			ch->error = 1;
+		}
+
+		writel(ctrl, ch->base + CDGSD_CHnIR(ch->ch_num));
+	}
+
+	return IRQ_HANDLED;
+}
+
+static const struct of_device_id mn_dma_match[] = {
+	{ .compatible = "panasonic,mn-dma" },
+	{ .compatible = "panasonic,mn-sdma" },
+	{ }
+};
+
+/**
+ * Probe DMA driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ * @retval -ENOMEM  Failed to kzalloc
+ * @retval -EINVAL  The resource definition is incorrectly
+ * @retval -EBUSY   Failed to request_irq
+ */
+static int mn_dma_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct device_node *node = dev->of_node;
+	struct resource *res;
+	static void __iomem *dma_base_addr;
+	int ret, i;
+	unsigned int irq = 0;
+	struct mn_dma_chan *ch;
+	struct mn_dma_dmadev *mdc;
+	const struct of_device_id *of_id;
+
+	dev_dbg(dev, "%s enter\n", __func__);
+	mdc = devm_kzalloc(dev, sizeof(*mdc), GFP_KERNEL);
+	if (!mdc) {
+		dev_err(dev, "can't allocate DMA container\n");
+		return -ENOMEM;
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dma_base_addr = devm_ioremap_resource(dev, res);
+	if (IS_ERR(dma_base_addr))
+		return PTR_ERR(dma_base_addr);
+
+	dma_cap_zero(mdc->dma_slave.cap_mask);
+	dma_cap_set(DMA_SLAVE, mdc->dma_slave.cap_mask);
+	dma_cap_set(DMA_PRIVATE, mdc->dma_slave.cap_mask);
+
+	mdc->dma_slave.device_prep_slave_sg		= mn_dma_prep_slave_sg;
+	mdc->dma_slave.device_alloc_chan_resources	= mn_dma_alloc_chan_resources;
+	mdc->dma_slave.device_free_chan_resources	= mn_dma_free_chan_resources;
+	mdc->dma_slave.device_issue_pending		= mn_dma_issue_pending;
+	mdc->dma_slave.device_tx_status			= mn_dma_tx_status;
+	mdc->dma_slave.device_control			= mn_dma_control;
+	mdc->dma_slave.dev				= dev;
+	init_completion(&mdc->done);
+
+	INIT_LIST_HEAD(&mdc->dma_slave.channels);
+
+	ch = &mdc->slave_chans[0];
+	for (i = 0; i < MN_DMA_MAX_CHANNEL; i++, ch++) {
+		ch->ch_num = i;
+		ch->base = dma_base_addr;
+		ch->allocated = 0;
+		ch->pdone = &mdc->done;
+		ch->line_reqno = 0;
+
+		ch->vc.desc_free = mn_dma_desc_free;
+		vchan_init(&ch->vc, &mdc->dma_slave);
+
+		dev_dbg(dev, "%s: chs[%d]: ch->ch_num=%u ch->base=%p\n",
+			__func__, i, ch->ch_num, ch->base);
+	}
+
+	platform_set_drvdata(pdev, mdc);
+
+	of_id = of_match_device(mn_dma_match, &pdev->dev);
+	if (of_id) {
+		of_property_read_u32((&pdev->dev)->of_node,
+				     "dma-channels", &mdc->dma_channels);
+	}
+
+	for (i = 0; i < mdc->dma_channels; i++) {
+		irq = irq_of_parse_and_map(node, i);
+		if (irq == NO_IRQ) {
+			dev_err(dev, "no IRQ resource\n");
+			return -EINVAL;
+		}
+
+		ret = devm_request_irq(dev, irq, mn_dma_interrupt, 0,
+				       "dmaengine", mdc);
+		if (ret) {
+			dev_err(dev, "devm_request_irq failed\n");
+			return ret;
+		}
+		dev_dbg(dev, "devm_request_irq(%d)\n", irq);
+	}
+
+	ret = dma_async_device_register(&mdc->dma_slave);
+	if (ret) {
+		dev_err(dev, "dma_async_device_register failed\n");
+		return ret;
+	}
+
+	ret = of_dma_controller_register(node, mn_dma_of_xlate, mdc);
+	if (ret) {
+		dev_err(dev, "of_dma_controller_register failed\n");
+		dma_async_device_unregister(&mdc->dma_slave);
+		return ret;
+	}
+
+	dev_dbg(dev, "%s: IRQ=%u\n", __func__, irq);
+	dev_dbg(dev, "%s exit\n", __func__);
+
+	return 0;
+}
+
+/**
+ * Remove DMA driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ */
+static int mn_dma_remove(struct platform_device *pdev)
+{
+	struct mn_dma_dmadev *m = platform_get_drvdata(pdev);
+
+	dma_async_device_unregister(&m->dma_slave);
+
+	if (pdev->dev.of_node)
+		of_dma_controller_free(pdev->dev.of_node);
+
+	return 0;
+}
+
+static struct platform_driver mn_dma_driver = {
+	.probe	= mn_dma_probe,
+	.remove	= mn_dma_remove,
+	.driver = {
+		.name		= "mn-sdma-engine",
+		.owner		= THIS_MODULE,
+		.of_match_table	= mn_dma_match,
+	},
+};
+
+/**
+ * Initialize DMA driver
+ *
+ * @retval 0        Success
+ * @retval -EBUSY   Failed to platform_driver_register
+ */
+static int mn_dma_init(void)
+{
+	return platform_driver_register(&mn_dma_driver);
+}
+subsys_initcall(mn_dma_init);
+
+/**
+ * Remove DMA driver
+ *
+ */
+static void __exit mn_dma_exit(void)
+{
+	platform_driver_unregister(&mn_dma_driver);
+}
+module_exit(mn_dma_exit);
+
+MODULE_AUTHOR("Panasonic Corporation.");
+MODULE_DESCRIPTION("Panasonic DMA engine driver");
+MODULE_LICENSE("GPL v2");
diff -uNr linux-3.14.19/drivers/gpio/Kconfig linux-gerda/drivers/gpio/Kconfig
--- linux-3.14.19/drivers/gpio/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/gpio/Kconfig	2017-06-22 09:52:56.163039151 +0900
@@ -406,6 +406,11 @@
 	select GENERIC_IRQ_CHIP
 	select OF_GPIO
 
+config GPIO_GERDAC
+	tristate "GERDAC GPIO support"
+	help
+	  Say yes here to support the Gerdac SoC GPIO device
+
 comment "I2C GPIO expanders:"
 
 config GPIO_ARIZONA
diff -uNr linux-3.14.19/drivers/gpio/Makefile linux-gerda/drivers/gpio/Makefile
--- linux-3.14.19/drivers/gpio/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/gpio/Makefile	2017-06-22 09:52:56.159039151 +0900
@@ -99,3 +99,4 @@
 obj-$(CONFIG_GPIO_WM8994)	+= gpio-wm8994.o
 obj-$(CONFIG_GPIO_XILINX)	+= gpio-xilinx.o
 obj-$(CONFIG_GPIO_XTENSA)	+= gpio-xtensa.o
+obj-$(CONFIG_GPIO_GERDAC)	+= gpio-gerdac.o
diff -uNr linux-3.14.19/drivers/gpio/gpio-gerdac.c linux-gerda/drivers/gpio/gpio-gerdac.c
--- linux-3.14.19/drivers/gpio/gpio-gerdac.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/gpio/gpio-gerdac.c	2017-06-22 09:52:56.171039150 +0900
@@ -0,0 +1,290 @@
+/*
+ * GerdaC GPIO driver
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+#include <linux/bitops.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/io.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+/* Register Offset Definitions */
+#define GERDAC_GPIDATA_OFFSET   (0x40)	/* Data Input register  */
+#define GERDAC_GPODATA_OFFSET   (0x60)	/* Data Output register  */
+#define GERDAC_IECTRL_OFFSET    (0x0)	/* Input control register  */
+#define GERDAC_GPOOE_OFFSET    (0x80)	/* Output control register  */
+
+/* Register Access Macro */
+#define GERDAC_GPIO_REG(base,n)		((base)+(((n)/32)*4))
+#define GERDAC_GPIO_BIT(n)			BIT(n%32)
+
+/* Register Signal Number Definition */
+#define GERDAC_GPIO_NUM_BASE	0
+#define GERDAC_GPIO_NUM_MAX		194
+
+/* Read/Write access to the GPIO registers */
+#define gerdac_gpio_readreg(offset)		readl(offset)
+#define gerdac_gpio_writereg(offset, val)	writel(val, offset)
+
+/**
+ * struct gerdac_gpio_instance - Stores information about GPIO device
+ * struct gpio_chip mmchip: GPIO chip
+ * iomem: top address for regs
+ * gpio_lock: Lock used for synchronization
+ */
+struct gerdac_gpio_instance {
+	struct gpio_chip mmchip;
+	void __iomem  *regs;
+	spinlock_t gpio_lock;
+};
+
+/**
+ * gerdac_gpio_set_bit - set bit for register
+ * @reg: top address as each function of registers
+ * @gpio: GPIO signal number.
+ * @on_off: value to set.
+ *
+ * this funtion set bit to register
+ */
+static inline void gerdac_gpio_set_bit(void __iomem *reg, unsigned int gpio, int on_off)
+{
+	u32	reg_val;
+
+	reg_val = gerdac_gpio_readreg(GERDAC_GPIO_REG(reg, gpio));
+
+	if (on_off)
+		reg_val |= GERDAC_GPIO_BIT(gpio);
+	else
+		reg_val &= ~GERDAC_GPIO_BIT(gpio);
+
+	gerdac_gpio_writereg(GERDAC_GPIO_REG(reg, gpio), reg_val);
+}
+
+/**
+ * gerdac_gpio_get - Read the specified signal of the GPIO device.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * This function reads the specified signal of the GPIO device. It returns 0 if
+ * the signal clear, 1 if signal is set or negative value on error.
+ */
+static int gerdac_gpio_get(struct gpio_chip *gc, unsigned int gpio)
+{
+	struct gerdac_gpio_instance *chip =
+		container_of(gc, struct gerdac_gpio_instance, mmchip);
+	void __iomem *regs = chip->regs;
+
+	if (gerdac_gpio_readreg(GERDAC_GPIO_REG(regs + GERDAC_GPOOE_OFFSET, gpio)) & GERDAC_GPIO_BIT(gpio)) {
+		return !!(gerdac_gpio_readreg(GERDAC_GPIO_REG(regs + GERDAC_GPODATA_OFFSET, gpio)) &
+							GERDAC_GPIO_BIT(gpio));
+	} else {
+		return !!(gerdac_gpio_readreg(GERDAC_GPIO_REG(regs + GERDAC_GPIDATA_OFFSET, gpio)) &
+							GERDAC_GPIO_BIT(gpio));
+	}
+}
+
+/**
+ * gerdac_gpio_set - Write the specified signal of the GPIO device.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    Value to be written to specified signal.
+ *
+ * This function writes the specified value in to the specified signal of the
+ * GPIO device.
+ */
+static void gerdac_gpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
+{
+	unsigned long flags;
+	struct gerdac_gpio_instance *chip =
+		container_of(gc, struct gerdac_gpio_instance, mmchip);
+	void __iomem *regs = chip->regs;
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	/* Write to GPIO signal and set its direction to output */
+	gerdac_gpio_set_bit(regs + GERDAC_GPODATA_OFFSET, gpio, val);
+
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+}
+
+/**
+ * gerdac_gpio_dir_in - Set the direction of the specified GPIO signal as input.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * This function sets the direction of specified GPIO signal as input.
+ * It returns 0 if direction of GPIO signals is set as input otherwise it
+ * returns negative error value.
+ */
+static int gerdac_gpio_dir_in(struct gpio_chip *gc, unsigned int gpio)
+{
+	unsigned long flags;
+	struct gerdac_gpio_instance *chip =
+		container_of(gc, struct gerdac_gpio_instance, mmchip);
+	void __iomem *regs = chip->regs;
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	/* Set the GPIO bit in shadow register and set direction as input */
+	gerdac_gpio_set_bit(regs + GERDAC_GPOOE_OFFSET, gpio, 0);
+	gerdac_gpio_set_bit(regs + GERDAC_IECTRL_OFFSET, gpio, 1);
+	
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+
+	return 0;
+}
+
+/**
+ * gerdac_gpio_dir_out - Set the direction of the specified GPIO signal as output.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ * @val:    not used..
+ *
+ * This function sets the direction of specified GPIO signal as output. If all
+ * GPIO signals of GPIO chip is configured as input then it returns
+ * error otherwise it returns 0.
+ */
+static int gerdac_gpio_dir_out(struct gpio_chip *gc, unsigned int gpio, int val)
+{
+	unsigned long flags;
+	struct gerdac_gpio_instance *chip =
+	    container_of(gc, struct gerdac_gpio_instance, mmchip);
+	void __iomem *regs = chip->regs;
+
+	spin_lock_irqsave(&chip->gpio_lock, flags);
+
+	gerdac_gpio_set_bit(regs + GERDAC_IECTRL_OFFSET, gpio, 0);
+	gerdac_gpio_set_bit(regs + GERDAC_GPOOE_OFFSET, gpio, 1);
+
+	spin_unlock_irqrestore(&chip->gpio_lock, flags);
+
+	return 0;
+}
+
+/**
+ * gerdac_gpio_get_direction - Get the direction of the specified GPIO signal.
+ * @gc:     Pointer to gpio_chip device structure.
+ * @gpio:   GPIO signal number.
+ *
+ * This function gets the direction of specified GPIO signal.
+ * this function check only output mode.(not check input enabled)
+ */
+static int gerdac_gpio_get_direction(struct gpio_chip *gc, unsigned gpio)
+{
+	struct gerdac_gpio_instance *chip =
+		container_of(gc, struct gerdac_gpio_instance, mmchip);
+	void __iomem *regs = chip->regs;
+
+	return !(gerdac_gpio_readreg(GERDAC_GPIO_REG(regs + GERDAC_GPOOE_OFFSET, gpio)) &
+							GERDAC_GPIO_BIT(gpio));
+}
+
+/**
+ * gerdac_gpio_probe - Probe method for the GPIO device.
+ * @pdev: pointer to device
+ *
+ * This function probes the GPIO device, and adds to GPIOLIB. It initializes the
+ * driver data structure. It returns 0, if the driver is bound to the GPIO
+ * device, or a negative value if there is an error.
+ */
+static int gerdac_gpio_probe(struct platform_device *pdev)
+{
+	struct resource  *res;
+	void __iomem *gpio_reg_base;
+	struct gerdac_gpio_instance *chip;
+
+	chip = kzalloc(sizeof(*chip), GFP_KERNEL);
+	if (!chip)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res)
+		return -EINVAL;
+
+	gpio_reg_base = ioremap(res->start, resource_size(res));
+	if (!gpio_reg_base)
+		return -EINVAL;
+
+	/* By default assume full GPIO controller */
+	chip->mmchip.base = GERDAC_GPIO_NUM_BASE;
+	chip->mmchip.ngpio = GERDAC_GPIO_NUM_MAX+1;
+	chip->mmchip.label = "gerdac-gpio";
+
+	spin_lock_init(&chip->gpio_lock);
+
+	chip->mmchip.direction_input = gerdac_gpio_dir_in;
+	chip->mmchip.direction_output = gerdac_gpio_dir_out;
+	chip->mmchip.get_direction = gerdac_gpio_get_direction;
+	chip->mmchip.get = gerdac_gpio_get;
+	chip->mmchip.set = gerdac_gpio_set;
+
+	chip->regs = gpio_reg_base;
+
+	/* Call the OF gpio helper to setup and register the GPIO device */
+	gpiochip_add(&(chip->mmchip));
+
+	platform_set_drvdata(pdev, chip);
+
+	pr_info("gerdac gpio: registered, base is %p\n", chip->regs);
+
+	return 0;
+}
+
+/**
+ * gerdac_gpio_remove - remove device driver for the GPIO device.
+ * @pdev: pointer to device
+ *
+ * This function removes the GPIO device from GPIOLIB.
+ * It returns 0, if the driver is bound to the GPIO
+ * device, or a negative value if there is an error.
+ */
+static int gerdac_gpio_remove(struct platform_device *pdev)
+{
+	struct gerdac_gpio_instance *chip = platform_get_drvdata(pdev);
+	int  ret;
+
+	ret = gpiochip_remove(&(chip->mmchip));
+	if (ret < 0) {
+		dev_err(&pdev->dev,
+			"unable to remove gpiochip: %d\n", ret);
+		return ret;
+	}
+
+	kfree(chip);
+
+	return 0;
+}
+
+static struct platform_driver gerdac_gpio_driver = {
+	.probe		= gerdac_gpio_probe,
+	.remove		= gerdac_gpio_remove,
+	.driver.owner	= THIS_MODULE,
+	.driver		= {
+		.name	= "gerdac-gpio",
+	},
+};
+
+static int __init gerdac_gpio_init(void)
+{
+	return platform_driver_register(&gerdac_gpio_driver);
+}
+subsys_initcall(gerdac_gpio_init);
+
+static void __exit gerdac_gpio_exit(void)
+{
+	platform_driver_unregister(&gerdac_gpio_driver);
+}
+module_exit(gerdac_gpio_exit);
+
+MODULE_DESCRIPTION("GerdaC GPIO driver");
+MODULE_LICENSE("GPL");
+
diff -uNr linux-3.14.19/drivers/i2c/busses/Kconfig linux-gerda/drivers/i2c/busses/Kconfig
--- linux-3.14.19/drivers/i2c/busses/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/i2c/busses/Kconfig	2017-06-22 09:53:00.227039030 +0900
@@ -815,6 +815,112 @@
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-rcar.
 
+config I2C_MN
+	tristate "MN I2C Controller"
+	depends on ARCH_GERDA
+	help
+	  This driver supports the I2C controller on algorithms for Panasonic Gerda-C series.
+
+if I2C_MN
+config I2C_MN_CH0
+	bool "I2C channel 0"
+choice
+	prompt "I2C channel 0 speed"
+	default I2C_MN_CH0_100KHZ
+	depends on I2C_MN_CH0
+
+config I2C_MN_CH0_50KHZ
+	bool "50 KHz"
+	depends on MACH_GERDAC
+
+config I2C_MN_CH0_100KHZ
+	bool "100 KHz"
+
+config I2C_MN_CH0_400KHZ
+	bool "400 KHz"
+endchoice
+
+config I2C_MN_CH0_RATE
+	int
+	default 5 if I2C_MN_CH0_50KHZ
+	default 10 if I2C_MN_CH0_100KHZ
+	default 40 if I2C_MN_CH0_400KHZ
+
+config I2C_MN_CH1
+	bool "I2C channel 1"
+choice
+	prompt "I2C channel 1 speed"
+	default I2C_MN_CH1_100KHZ
+	depends on I2C_MN_CH1
+
+config I2C_MN_CH1_50KHZ
+	bool "50 KHz"
+	depends on MACH_GERDAC
+
+config I2C_MN_CH1_100KHZ
+	bool "100 KHz"
+
+config I2C_MN_CH1_400KHZ
+	bool "400 KHz"
+endchoice
+
+config I2C_MN_CH1_RATE
+	int
+	default 5 if I2C_MN_CH1_50KHZ
+	default 10 if I2C_MN_CH1_100KHZ
+	default 40 if I2C_MN_CH1_400KHZ
+
+config I2C_MN_CH2
+	bool "I2C channel 2"
+	depends on MACH_GERDAC
+choice
+	prompt "I2C channel 2 speed"
+	default I2C_MN_CH2_100KHZ
+	depends on I2C_MN_CH2
+
+config I2C_MN_CH2_50KHZ
+	bool "50 KHz"
+	depends on MACH_GERDAC
+
+config I2C_MN_CH2_100KHZ
+	bool "100 KHz"
+
+config I2C_MN_CH2_400KHZ
+	bool "400 KHz"
+endchoice
+
+config I2C_MN_CH2_RATE
+	int
+	default 5 if I2C_MN_CH2_50KHZ
+	default 10 if I2C_MN_CH2_100KHZ
+	default 40 if I2C_MN_CH2_400KHZ
+
+config I2C_MN_CH3
+	bool "I2C channel 3"
+	depends on MACH_GERDAC
+choice
+	prompt "I2C channel 3 speed"
+	default I2C_MN_CH3_100KHZ
+	depends on I2C_MN_CH3
+
+config I2C_MN_CH3_50KHZ
+	bool "50 KHz"
+	depends on MACH_GERDAC
+
+config I2C_MN_CH3_100KHZ
+	bool "100 KHz"
+
+config I2C_MN_CH3_400KHZ
+	bool "400 KHz"
+endchoice
+
+config I2C_MN_CH3_RATE
+	int
+	default 5 if I2C_MN_CH3_50KHZ
+	default 10 if I2C_MN_CH3_100KHZ
+	default 40 if I2C_MN_CH3_400KHZ
+endif
+
 comment "External I2C/SMBus adapter drivers"
 
 config I2C_DIOLAN_U2C
diff -uNr linux-3.14.19/drivers/i2c/busses/Makefile linux-gerda/drivers/i2c/busses/Makefile
--- linux-3.14.19/drivers/i2c/busses/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/i2c/busses/Makefile	2017-06-22 09:53:00.223039030 +0900
@@ -79,6 +79,7 @@
 obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
 obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
 obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
+obj-$(CONFIG_I2C_MN)		+= i2c-mn.o
 
 # External I2C/SMBus adapter drivers
 obj-$(CONFIG_I2C_DIOLAN_U2C)	+= i2c-diolan-u2c.o
diff -uNr linux-3.14.19/drivers/i2c/busses/i2c-mn-internal.h linux-gerda/drivers/i2c/busses/i2c-mn-internal.h
--- linux-3.14.19/drivers/i2c/busses/i2c-mn-internal.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/i2c/busses/i2c-mn-internal.h	2017-06-22 09:53:00.215039030 +0900
@@ -0,0 +1,303 @@
+/*
+ *  i2c-mn-internal.h i2c driver Algorithm definition for Panasonic Gerda-C series adapters
+ *
+ *  Copyright (C) 2014 Panasonic Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef I2C_MN_INTERNAL_H__INCLUDED /* [ */
+#define I2C_MN_INTERNAL_H__INCLUDED 1
+
+#include <linux/wait.h>
+
+/*----- Register Size -----*/
+#define I2C_MN_IO_SIZE			(4UL * 20UL)  /* 32bit Regs are 0x00,..0x4C (80Byte) */
+
+/*----- Register Offset -----*/
+#define I2C_MN_FI2CCR			0x00UL
+#define I2C_MN_FI2CDTTX			0x04UL
+#define I2C_MN_FI2CDTRX			0x04UL
+#define I2C_MN_FI2CCYC			0x10UL
+#define I2C_MN_FI2CLCTL			0x14UL
+#define I2C_MN_FI2CSSUT			0x18UL
+#define I2C_MN_FI2CDSUT			0x1CUL
+#define I2C_MN_FI2CINT			0x20UL
+#define I2C_MN_FI2CIE			0x24UL
+#define I2C_MN_FI2CIC			0x28UL
+#define I2C_MN_FI2CSR			0x2CUL
+#define I2C_MN_FI2CRST			0x34UL
+#define I2C_MN_FI2CBM			0x38UL
+#define I2C_MN_FI2CTBC			0x40UL
+#define I2C_MN_FI2CRBC			0x44UL
+#define I2C_MN_FI2CTBCM			0x48UL
+#define I2C_MN_FI2CRBCM			0x4CUL
+
+/*----- Register Offset Mask -----*/
+#define I2C_MN_RMSK			0x7CUL
+
+/*----- FI2CCR -----*/
+#define I2C_MN_FI2CCR_GACK		0x00000010UL
+#define I2C_MN_FI2CCR_MST		0x00000008UL
+#define I2C_MN_FI2CCR_MST_MASTER	0x00000008UL
+#define I2C_MN_FI2CCR_STA_STO		0x00000006UL
+#define I2C_MN_FI2CCR_STA_STO_NOP	0x00000000UL
+#define I2C_MN_FI2CCR_STA_STO_START	0x00000004UL
+#define I2C_MN_FI2CCR_STA_STO_STOP	0x00000002UL
+#define I2C_MN_FI2CCR_ACK		0x00000001UL
+#define I2C_MN_FI2CCR_ACK_ACK		0x00000000UL
+#define I2C_MN_FI2CCR_ACK_NACK		0x00000001UL
+
+/*----- FI2CDTTX -----*/
+#define I2C_MN_FI2CDTTX_COM		0x00000100UL
+#define I2C_MN_FI2CDTTX_COM_COMMAND	0x00000100UL
+#define I2C_MN_FI2CDTTX_COM_DATA	0x00000000UL
+#define I2C_MN_FI2CDTTX_D		0x000000FFUL
+
+/*----- FI2CDTRX -----*/
+#define I2C_MN_FI2CDTRX_D		0x000000FFUL
+
+/*----- FI2CCYC -----*/
+#define I2C_MN_FI2CCYC_D		0x000001FFUL
+
+/*----- FI2CLCTL -----*/
+#define I2C_MN_FI2CLCTL_D		0x000000FFUL
+
+/*----- FI2CSSUT -----*/
+#define I2C_MN_FI2CSSUT_D		0x000000FFUL
+
+/*----- FI2CINT -----*/
+#define I2C_MN_FI2CINT_TRI		0x00000800UL
+#define I2C_MN_FI2CINT_RRI		0x00000400UL
+#define I2C_MN_FI2CINT_TEI		0x00000200UL
+#define I2C_MN_FI2CINT_RFI		0x00000100UL
+#define I2C_MN_FI2CINT_TCI		0x00000080UL
+#define I2C_MN_FI2CINT_RCI		0x00000040UL
+#define I2C_MN_FI2CINT_TBI		0x00000020UL
+#define I2C_MN_FI2CINT_RBI		0x00000010UL
+#define I2C_MN_FI2CINT_NCI		0x00000008UL
+#define I2C_MN_FI2CINT_NAI		0x00000004UL
+#define I2C_MN_FI2CINT_ALI		0x00000002UL
+#define I2C_MN_FI2CINT_GCI		0x00000001UL
+#define I2C_MN_FI2CINT_ALL		0x00000FFFUL
+
+/*----- FI2CIE -----*/
+#define I2C_MN_FI2CIE_TRIE		0x00000800UL
+#define I2C_MN_FI2CIE_RRIE		0x00000400UL
+#define I2C_MN_FI2CIE_TEIE		0x00000200UL
+#define I2C_MN_FI2CIE_RFIE		0x00000100UL
+#define I2C_MN_FI2CIE_TCIE		0x00000080UL
+#define I2C_MN_FI2CIE_RCIE		0x00000040UL
+#define I2C_MN_FI2CIE_TBIE		0x00000020UL
+#define I2C_MN_FI2CIE_RBIE		0x00000010UL
+#define I2C_MN_FI2CIE_NCIE		0x00000008UL
+#define I2C_MN_FI2CIE_NAIE		0x00000004UL
+#define I2C_MN_FI2CIE_ALIE		0x00000002UL
+#define I2C_MN_FI2CIE_GCIE		0x00000001UL
+#define I2C_MN_FI2CIE_ALL		0x00000FFFUL
+#define I2C_MN_FI2CIE_TRIE_ENABLE	I2C_MN_FI2CIE_TRIE
+#define I2C_MN_FI2CIE_RRIE_ENABLE	I2C_MN_FI2CIE_RRIE
+#define I2C_MN_FI2CIE_TEIE_ENABLE	I2C_MN_FI2CIE_TEIE
+#define I2C_MN_FI2CIE_RFIE_ENABLE	I2C_MN_FI2CIE_RFIE
+#define I2C_MN_FI2CIE_TCIE_ENABLE	I2C_MN_FI2CIE_TCIE
+#define I2C_MN_FI2CIE_RCIE_ENABLE	I2C_MN_FI2CIE_RCIE
+#define I2C_MN_FI2CIE_TBIE_ENABLE	I2C_MN_FI2CIE_TBIE
+#define I2C_MN_FI2CIE_RBIE_ENABLE	I2C_MN_FI2CIE_RBIE
+#define I2C_MN_FI2CIE_NCIE_ENABLE	I2C_MN_FI2CIE_NCIE
+#define I2C_MN_FI2CIE_NAIE_ENABLE	I2C_MN_FI2CIE_NAIE
+#define I2C_MN_FI2CIE_ALIE_ENABLE	I2C_MN_FI2CIE_ALIE
+#define I2C_MN_FI2CIE_GCIE_ENABLE	I2C_MN_FI2CIE_GCIE
+#define I2C_MN_FI2CIE_TRIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_RRIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_TEIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_RFIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_TCIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_RCIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_TBIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_RBIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_NCIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_NAIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_ALIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_GCIE_DISABLE	0x00000000UL
+#define I2C_MN_FI2CIE_ALL_DISABLE	0x00000000UL
+
+#define I2C_MN_IE_MST_SND_INDETERMINATE	( \
+	0UL \
+	| I2C_MN_FI2CIE_TRIE_DISABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_RRIE_DISABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_TEIE_ENABLE	/* expected intterrupt	*/	\
+	| I2C_MN_FI2CIE_RFIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_TCIE_DISABLE					\
+	| I2C_MN_FI2CIE_RCIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_TBIE_DISABLE					\
+	| I2C_MN_FI2CIE_RBIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_NCIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_NAIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_ALIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_GCIE_ENABLE	/* should not occur	*/	\
+)
+
+#define I2C_MN_IE_MST_RCV_INDETERMINATE	( \
+	0UL \
+	| I2C_MN_FI2CIE_TRIE_DISABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_RRIE_DISABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_TEIE_DISABLE					\
+	| I2C_MN_FI2CIE_RFIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_TCIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_RCIE_DISABLE					\
+	| I2C_MN_FI2CIE_TBIE_ENABLE	/* should not occur	*/	\
+	| I2C_MN_FI2CIE_RBIE_ENABLE	/* expected interrupt	*/	\
+	| I2C_MN_FI2CIE_NCIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_NAIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_ALIE_ENABLE	/* abnormal state	*/	\
+	| I2C_MN_FI2CIE_GCIE_ENABLE	/* should not occur	*/	\
+)
+
+/*----- FI2CIC -----*/
+#define I2C_MN_FI2CIC_TEIC			0x00000200UL
+#define I2C_MN_FI2CIC_RFIC			0x00000100UL
+#define I2C_MN_FI2CIC_TCIC			0x00000080UL
+#define I2C_MN_FI2CIC_RCIC			0x00000040UL
+#define I2C_MN_FI2CIC_TBIC			0x00000020UL
+#define I2C_MN_FI2CIC_RBIC			0x00000010UL
+#define I2C_MN_FI2CIC_NCIC			0x00000008UL
+#define I2C_MN_FI2CIC_NAIC			0x00000004UL
+#define I2C_MN_FI2CIC_ALIC			0x00000002UL
+#define I2C_MN_FI2CIC_GCIC			0x00000001UL
+#define I2C_MN_FI2CIC_ALL			0x000003FFUL
+#define I2C_MN_FI2CIC_TEIC_CLEAR		I2C_MN_FI2CIC_TEIC
+#define I2C_MN_FI2CIC_RFIC_CLEAR		I2C_MN_FI2CIC_RFIC
+#define I2C_MN_FI2CIC_TCIC_CLEAR		I2C_MN_FI2CIC_TCIC
+#define I2C_MN_FI2CIC_RCIC_CLEAR		I2C_MN_FI2CIC_RCIC
+#define I2C_MN_FI2CIC_TBIC_CLEAR		I2C_MN_FI2CIC_TBIC
+#define I2C_MN_FI2CIC_RBIC_CLEAR		I2C_MN_FI2CIC_RBIC
+#define I2C_MN_FI2CIC_NCIC_CLEAR		I2C_MN_FI2CIC_NCIC
+#define I2C_MN_FI2CIC_NAIC_CLEAR		I2C_MN_FI2CIC_NAIC
+#define I2C_MN_FI2CIC_ALIC_CLEAR		I2C_MN_FI2CIC_ALIC
+#define I2C_MN_FI2CIC_GCIC_CLEAR		I2C_MN_FI2CIC_GCIC
+#define I2C_MN_FI2CIC_ALL_CLEAR			I2C_MN_FI2CIC_ALL
+
+/*----- FI2CSR -----*/
+#define I2C_MN_FI2CSR_MD			0x00006000UL
+#define I2C_MN_FI2CSR_DB			0x00001000UL
+#define I2C_MN_FI2CSR_DB_NOT_BUSY		0x00000000UL
+#define I2C_MN_FI2CSR_STS			0x00000800UL
+#define I2C_MN_FI2CSR_STS_NOT_DETECT_STOP	0x00000000UL
+#define I2C_MN_FI2CSR_LRB			0x00000400UL
+#define I2C_MN_FI2CSR_LRB_ACK			0x00000000UL
+#define I2C_MN_FI2CSR_ASS			0x00000200UL
+#define I2C_MN_FI2CSR_ASS_NOT_MATCH		0x00000000UL
+#define I2C_MN_FI2CSR_BB			0x00000100UL
+#define I2C_MN_FI2CSR_BB_BUSY			0x00000100UL
+#define I2C_MN_FI2CSR_BB_NOT_BUSY		0x00000000UL
+#define I2C_MN_FI2CSR_RFF			0x00000008UL
+#define I2C_MN_FI2CSR_RFF_NOT_FULL		0x00000000UL
+#define I2C_MN_FI2CSR_RNE			0x00000004UL
+#define I2C_MN_FI2CSR_RNE_EMPTY			0x00000000UL
+#define I2C_MN_FI2CSR_TNF			0x00000002UL
+#define I2C_MN_FI2CSR_TNF_NOT_FULL		0x00000002UL
+#define I2C_MN_FI2CSR_TFE			0x00000001UL
+#define I2C_MN_FI2CSR_TFE_EMPTY			0x00000001UL
+
+/*----- FI2CRST -----*/
+#define I2C_MN_FI2CRST_TBRST			0x00000004UL
+#define I2C_MN_FI2CRST_TBRST_RST		0x00000004UL
+#define I2C_MN_FI2CRST_RBRST			0x00000002UL
+#define I2C_MN_FI2CRST_RBRST_RST		0x00000002UL
+#define I2C_MN_FI2CRST_RST			0x00000001UL
+#define I2C_MN_FI2CRST_RST_RST			0x00000001UL
+
+/*----- FI2CBM -----*/
+#define I2C_MN_FI2CBM_SCLS			0x00000001UL
+#define I2C_MN_FI2CBM_SCLS_HIGH			0x00000001UL
+#define I2C_MN_FI2CBM_SDAS			0x00000004UL
+#define I2C_MN_FI2CBM_SDAS_HIGH			0x00000004UL
+
+/*----- FI2CBTBC -----*/
+#define I2C_MN_FI2CTBC_MASK			0x000000FFUL
+
+/*----- FI2CBRBC -----*/
+#define I2C_MN_FI2CRBC_MASK			0x000000FFUL
+
+/* Connected to the number of adaptersy */
+#ifdef CONFIG_MACH_GERDAC
+#define I2C_MN_ADAP_MAX			4	/* I2C adap Maximum */
+#else /* CONFIG_MACH_GERDAC */
+#define I2C_MN_ADAP_MAX			2	/* I2C adap Maximum */
+#endif
+
+/* Serial Clock Frequency */
+#define I2C_MN_IOCLK			100000000UL	/* ioclk[Hz] is PCLK */
+#ifdef CONFIG_MACH_GERDAC
+#define I2C_MN_CLK_DIV			4UL		/* Clock Divisor */
+#else /* CONFIG_MACH_GERDAC */
+#define I2C_MN_CLK_DIV			2UL		/* Clock Divisor */
+#endif
+/* Serial Clock Frequency Range [kHz] */
+#define I2C_MN_RATE_MIN			5U
+#define I2C_MN_RATE_MAX			40U
+#define I2C_MN_RATE_DEFAULT		10U
+
+/* Serial Clock Frequency (SCF) [kHz] */
+#define I2C_MN_SERIAL_CLOCK_50		50UL
+#define I2C_MN_SERIAL_CLOCK_100		100UL
+#define I2C_MN_SERIAL_CLOCK_400		400UL
+
+/* L Period Time [ns], when SCF is 50kHz or 100kHz or 400kHz */
+#define I2C_MN_L_PERIOD_TIME_50		9440UL
+#define I2C_MN_L_PERIOD_TIME_100	4720UL
+#define I2C_MN_L_PERIOD_TIME_400	1320UL
+
+/* Setup Time [ns], when SCF is 50kHz or 100kHz or 400kHz */
+#define I2C_MN_SETUP_TIME_50		9440UL
+#define I2C_MN_SETUP_TIME_100		4720UL
+#define I2C_MN_SETUP_TIME_400		1320UL
+
+/* Data Setup Time [ns], when SCF is 50kHz or 100kHz or 400kHz */
+#define I2C_MN_DATA_SETUP_TIME_50	560UL
+#define I2C_MN_DATA_SETUP_TIME_100	280UL
+#define I2C_MN_DATA_SETUP_TIME_400	120UL
+
+/* FIFO resource */
+#define I2C_MN_SEND_FIFO_NUM		8U
+#define I2C_MN_RECV_FIFO_NUM		8U
+
+/* execution mode */
+#define I2C_MN_EXEC_START		0U
+#define I2C_MN_EXEC_READ		1U
+#define I2C_MN_EXEC_SEND		2U
+
+/* I2C Device Start state information Structure */
+struct i2c_algo_mn_exec_info {
+	unsigned short mode;		/* execution mode */
+	unsigned short flags;		/* control flag */
+	unsigned char  *buf;		/* data buffer pointer */
+	unsigned short len;		/* data length */
+	unsigned short cnt;		/* send/recv counter */
+	int result;			/* execution result */
+	unsigned short cnt_bak;		/* counter backup for watch */
+	unsigned short watch_timeflag;	/* watch timer flag */
+	int watch_timeval;		/* watch timer value */
+	struct timer_list watch_timer;	/* execution watch timer */
+};
+
+/* I2C Device infomation definition Structure */
+struct i2c_algo_mn_data {
+	unsigned long base;		/* Register Base Address */
+	void *iomap_base;		/* IOREMAP : Register Base Address */
+	int irq;			/* IRQ No. */
+	int irq_event;
+	wait_queue_head_t wait;		/* for IRQ handler */
+	int rate;			/* Default BusRate */
+	spinlock_t lock;		/* lock for controller */
+	unsigned int udelay;		/* usec delay */
+	unsigned short wr2rd_wait_time;	/* read wait time just after write (msec) */
+	struct i2c_algo_mn_exec_info exec_info;	/* execution information */
+};
+
+/* Bus monitoring definition */
+#define I2C_MN_BUS_POLLING_CNT		0x10000UL
+
+#endif /* ] I2C_MN_INTERNAL_H__INCLUDED */
diff -uNr linux-3.14.19/drivers/i2c/busses/i2c-mn.c linux-gerda/drivers/i2c/busses/i2c-mn.c
--- linux-3.14.19/drivers/i2c/busses/i2c-mn.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/i2c/busses/i2c-mn.c	2017-06-22 09:53:00.235039029 +0900
@@ -0,0 +1,1921 @@
+/*
+ *  i2c-mn.c i2c driver Hardware-specific control code for Panasonic Gerda-C series
+ *
+ *  Copyright (C) 2014 Panasonic Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/platform_device.h>
+#include <asm/uaccess.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c/i2c-mn.h>
+#include "i2c-mn-internal.h"
+
+#include <asm/io.h>
+#include <asm/irq.h>
+/*
+ * Confirmation
+ */
+/* #include <mach/intctl-regs.h> */
+
+#include <linux/syscalls.h>
+#include <linux/kthread.h>
+
+#undef DEBUG_I2C_MN
+/* #define DEBUG_I2C_MN */
+
+/* I2C  Debug level variable */
+static int i2c_debug;
+
+#ifdef DEBUG_I2C_MN
+/* Infomation mode */
+#define DEB1(fmt, args...) do { if (i2c_debug >= 1) printk(fmt, ## args); } while (0)
+/* Tracking mode */
+#define DEB2(fmt, args...) do { if (i2c_debug >= 2) printk(fmt, ## args); } while (0)
+/* Debuging mode */
+#define DEB3(fmt, args...) do { if (i2c_debug >= 3) printk(fmt, ## args); } while (0)
+#else	/* DEBUG_I2C_MN */
+#define DEB1(fmt, args...) do {} while (0)
+#define DEB2(fmt, args...) do {} while (0)
+#define DEB3(fmt, args...) do {} while (0)
+#endif	/* DEBUG_I2C_MN */
+
+#undef DEBUG_IO
+/* #define DEBUG_IO */
+
+#ifdef DEBUG_IO
+static char *names[] = {
+	"FI2CCR(0x00)",
+	"FI2CDTTX/FI2CDTRX(0x04)",
+	"Nothing(0x08)",
+	"NotUse(0x0c)",
+	"FI2CCYC(0x10)",
+	"FI2CLCTL(0x14)",
+	"FI2CSSUT(0x18)",
+	"FI2CDSUT(0x1C)",
+	"FI2CINT(0x20)",
+	"FI2CIE(0x24)",
+	"FI2CIC(0x28)",
+	"FI2CSR(0x2C)",
+	"Nothing(0x30)",
+	"FI2CRST(0x34)",
+	"FI2CBM(0x38)",
+	"Nothing(0x3C)",
+	"FI2CTBC(0x40)",
+	"FI2CRBC(0x44)",
+	"FI2CTBCM(0x48)",
+	"FI2CRBCM(0x4c)",
+};
+#endif
+
+/*
+ * Prototype declaration Section
+ */
+static void i2c_mn_add_watch_timer(struct i2c_algo_mn_data *mn_adap);
+static void i2c_mn_del_watch_timer(struct i2c_algo_mn_data *mn_adap);
+static void i2c_mn_watch_timer_handler(unsigned long data);
+static int i2c_mn_get_busrate(struct i2c_algo_mn_data *adap);
+static int i2c_mn_set_busrate(struct i2c_algo_mn_data *adap, unsigned int rate);
+static void i2c_mn_write32(struct i2c_algo_mn_data *adap, unsigned long reg, unsigned long val);
+static int i2c_mn_write_cmd_fifo(struct i2c_algo_mn_data *adap, unsigned long ie, unsigned long dttx, unsigned long cr, int timeout);
+static unsigned long i2c_mn_read32(struct i2c_algo_mn_data *adap, unsigned long reg);
+static int i2c_mn_remove(struct platform_device *pdev);
+static int i2c_mn_busmonitor_check(struct i2c_algo_mn_data *adap, unsigned long bm);
+static int i2c_mn_set_ie(struct i2c_algo_mn_data *mn_adap, unsigned long setie);
+static void i2c_mn_stop(struct i2c_adapter *i2c_adap);
+static int i2c_mn_start(struct i2c_adapter *i2c_adap, struct i2c_msg *msg);
+static int i2c_mn_sendbytes(struct i2c_adapter *i2c_adap);
+static int i2c_mn_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg msgs[], int num);
+static u32 i2c_mn_func(struct i2c_adapter *i2c_adap);
+static int i2c_mn_init(struct i2c_algo_mn_data *mn_adap);
+static int i2c_mn_add_bus(struct i2c_adapter *i2c_adap);
+static int i2c_mn_del_bus(struct i2c_adapter *i2c_adap);
+static int i2c_mn_reset(struct i2c_algo_mn_data *mn_adap, struct i2c_busreset_ioctl_data *setting);
+static int i2c_mn_control(struct i2c_adapter *i2c_adap, unsigned int cmd, unsigned long arg);
+static irqreturn_t i2c_mn_handler(int this_irq, void *dev_id);
+static int i2c_mn_bus_init_sub(struct i2c_adapter *i2c_adap);
+static int i2c_mn_probe(struct platform_device *pdev);
+static void i2c_mn_bus_exit_sub(struct i2c_adapter *i2c_adap);
+static int __init i2c_mn_bus_init(void);
+static void __exit i2c_mn_bus_exit(void);
+
+/**
+ * @brief i2c_mn_check_status
+ *
+ * Confirmation of the interrupt status.
+ *
+ * @param  exec_info        [in]  struct i2c_algo_mn_exec_info *
+ *                                               Device operation status.
+ * @param  ifct             [in]  unsigned long  Interrupt source Register information.
+ * @param  stat             [in]  unsigned long  Status Register information.
+ * @retval 0                        Normal end or Mode excluded.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ *
+ * @attention
+ * This function is called from the interrupt handler receiving process
+ *
+ */
+static inline int i2c_mn_check_status(
+	struct i2c_algo_mn_exec_info *exec_info, unsigned long ifct,
+	unsigned long stat)
+{
+	unsigned long stat_mask;
+	unsigned long stat_expect;
+
+	if ((exec_info->flags & I2C_M_IGNORE_NAK) != 0U) {
+		return 0;
+	}
+
+	stat_mask = I2C_MN_FI2CSR_STS
+			| I2C_MN_FI2CSR_ASS
+			| I2C_MN_FI2CSR_BB;
+
+	stat_expect = I2C_MN_FI2CSR_STS_NOT_DETECT_STOP
+			| I2C_MN_FI2CSR_ASS_NOT_MATCH
+			| I2C_MN_FI2CSR_BB_BUSY;
+
+	if (((stat & stat_mask) == stat_expect) &&
+	    ((ifct & I2C_MN_FI2CINT_ALI) == 0UL)) {
+		return 0;
+	}
+
+	return -EREMOTEIO;
+}
+
+/**
+ * @brief i2c_mn_check_ifct_read
+ *
+ * Checking of received byte complete interrupt.
+ *
+ * @param  ifct             [in]  unsigned long  Interrupt source Register information.
+ * @retval 0                        Normal end or Mode excluded.
+ * @retval -EREMOTEIO(-121)         Status mismatch.
+ *
+ * @attention
+ * This function is called from the interrupt handler receiving process
+ *
+ */
+static inline int i2c_mn_check_ifct_read(unsigned long ifct)
+{
+	/* abnormal state */
+	if ((ifct & (I2C_MN_FI2CINT_NCI
+		     | I2C_MN_FI2CINT_NAI
+		     | I2C_MN_FI2CINT_ALI)) != 0UL) {
+		return -EREMOTEIO;
+	}
+
+	/* should not occur */
+	if ((ifct & (I2C_MN_FI2CINT_RFI
+		     | I2C_MN_FI2CINT_TCI
+		     | I2C_MN_FI2CINT_TBI
+		     | I2C_MN_FI2CINT_GCI)) != 0UL) {
+		printk(KERN_ERR "%s: detect interrupt that should not occur. ifct = %#08lx\n", __func__, ifct);
+		return -EREMOTEIO;
+	}
+
+	/* expected interrupt */
+	if ((ifct & I2C_MN_FI2CINT_RBI) == 0UL) {
+		BUG();
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_check_ifct_send
+ *
+ * Check the transmit byte complete interrupt.
+ *
+ * @param  ifct             [in]  unsigned long  Interrupt source Register information.
+ * @retval 0                        Normal end or Mode excluded.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ *
+ * @attention
+ * This function is called from the interrupt handler receiving process
+ *
+ */
+static inline int i2c_mn_check_ifct_send(unsigned long ifct)
+{
+	/* abnormal state */
+	if ((ifct & (I2C_MN_FI2CINT_NCI
+		     | I2C_MN_FI2CINT_NAI
+		     | I2C_MN_FI2CINT_ALI)) != 0UL) {
+		return -EREMOTEIO;
+	}
+
+	/* should not occur */
+	if ((ifct & (I2C_MN_FI2CINT_RFI
+		     | I2C_MN_FI2CINT_RCI
+		     | I2C_MN_FI2CINT_RBI
+		     | I2C_MN_FI2CINT_GCI)) != 0UL) {
+		printk(KERN_ERR "%s: detect interrupt that should not occur. ifct = %#08lx\n", __func__, ifct);
+		return -EREMOTEIO;
+	}
+
+	/* expected interrupt */
+	if ((ifct & I2C_MN_FI2CINT_TEI) == 0UL) {
+		return -EREMOTEIO;
+	}
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_busmonitor_check
+ *
+ * Processing availability check in the status and the current mode of the I2C.
+ *
+ * @param  adap             [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  bm               [in]  unsigned long              Mask value of bus monitor register.
+ * @retval 0                        Success.
+ * @retval -1                       Failure.
+ *
+ */
+static int i2c_mn_busmonitor_check(
+	struct i2c_algo_mn_data *adap, unsigned long bm)
+{
+	unsigned long stat;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+
+	/* Get the state line from FI2CnBM register */
+	stat = i2c_mn_read32(adap, I2C_MN_FI2CBM);
+
+	/* mask check*/
+	if ((stat & bm) == bm) {
+#ifdef DBG_I2C
+		printk("%s: I2C_MN_FI2CBM MATCH\n", __func__);
+#endif	/* DBG_I2C */
+		return 0;
+	}
+
+#ifdef DBG_I2C
+	printk("%s: I2C_MN_FI2CBM NO MATCH stat=%08lx, bm=%08lx\n", __func__, stat, bm);
+#endif	/* DBG_I2C */
+	return -1;
+}
+
+/**
+ * @brief i2c_mn_set_ie
+ *
+ * Generate a stop condition on the i2c bus
+ * returns after the stop condition has been generated
+ *
+ * @param  mn_adap          [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  setie            [in]  unsigned long              Set in the interrupt mask value.
+ * @retval 0                        Normal end or Mode excluded.
+ * @retval -1                       Status mismatch.
+ *
+ */
+static int i2c_mn_set_ie(struct i2c_algo_mn_data *mn_adap, unsigned long setie)
+{
+	unsigned long nowie;
+	unsigned long sr;
+	int ret = -1;
+
+	nowie = i2c_mn_read32(mn_adap, I2C_MN_FI2CIE);
+	if (nowie != setie) {
+		/* empty check for Send/Receive FIFO before set ie. */
+		sr = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+		if ((sr & (I2C_MN_FI2CSR_RNE | I2C_MN_FI2CSR_TFE)) ==
+		    (I2C_MN_FI2CSR_RNE_EMPTY | I2C_MN_FI2CSR_TFE_EMPTY)) {
+			i2c_mn_write32(mn_adap, I2C_MN_FI2CIE, setie);
+			ret = 0;
+		} else {
+			printk(KERN_ERR "%s: Send or Receive FIFO is not empty, can not set IE. FI2CSR => %#lx\n", __func__, sr);
+		}
+	} else {
+		ret = 0;
+	}
+	return ret;
+}
+
+/**
+ * @brief i2c_mn_stop
+ *
+ * Generate a stop condition on the i2c bus
+ * returns after the stop condition has been generated
+ *
+ * @param  adap             [in]  struct i2c_adapter *  I2C Adapter Infomation.
+ *
+ */
+static void
+i2c_mn_stop(
+	struct i2c_adapter *i2c_adap
+)
+{
+	struct i2c_algo_mn_data *mn_adap;
+	unsigned long cr;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (i2c_adap == NULL) {
+		printk(KERN_ERR "i2c-algo-mn: Access to invalid pointer.\n");
+		return;
+	}
+
+	mn_adap = i2c_adap->algo_data;
+	if ((i2c_mn_read32(mn_adap, I2C_MN_FI2CSR) & I2C_MN_FI2CSR_BB) !=
+	    I2C_MN_FI2CSR_BB_BUSY) {
+		DEB1("=== already STOP\n");
+		return;
+	}
+
+	/* Stop Condition */
+	cr = i2c_mn_read32(mn_adap, I2C_MN_FI2CCR);
+	cr &= I2C_MN_FI2CCR_GACK;
+	cr |= (I2C_MN_FI2CCR_MST_MASTER
+	       | I2C_MN_FI2CCR_STA_STO_STOP
+	       | I2C_MN_FI2CCR_ACK_NACK);
+
+	DEB1("=== STOP\n");
+
+	i2c_mn_write32(mn_adap, I2C_MN_FI2CCR, cr);
+}
+/**
+ * @brief i2c_mn_start
+ *
+ * Generate a stop condition on the i2c bus
+ * returns after the start condition has been generated
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @param  msg              [in]  struct i2c_msg *       message data.
+ * @retval 0                        Normal end or Mode excluded.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ * @retval -ETIMEDOUT(-60)          Data transmission timeout.
+ *
+ */
+static int
+i2c_mn_start(
+	struct i2c_adapter *i2c_adap, struct i2c_msg *msg
+)
+{
+	struct i2c_algo_mn_exec_info *exec_info;
+	struct i2c_algo_mn_data *mn_adap;
+	unsigned short flags, nak_ok;
+	unsigned long ie;
+	unsigned long dttx;
+	unsigned long cr;
+	unsigned short addr;
+	int ret = 0;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if ((i2c_adap == NULL) || (msg == NULL)) {
+		printk(KERN_ERR "i2c-algo-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	if (msg->len == 0) {
+		return 0;
+	}
+
+	mn_adap = i2c_adap->algo_data;
+	exec_info = &(mn_adap->exec_info);
+	flags   = msg->flags;
+	nak_ok  = flags & (unsigned short)I2C_M_IGNORE_NAK;
+
+	DEB1("=== START/ReSTART\n");
+
+	addr = (msg->addr << 1U);
+	if ((flags & I2C_M_RD) != 0U) {
+		addr |= 1U;
+	}
+	if ((flags & I2C_M_REV_DIR_ADDR) != 0U) {
+		addr ^= 1U;
+	}
+
+	if ((addr & 0x01U) != 0U) {
+		/* read */
+		/* keep the initial value of FI2CRBC . */
+		ie = I2C_MN_IE_MST_RCV_INDETERMINATE;
+		if (msg->len == 1U) {
+			cr = I2C_MN_FI2CCR_ACK_NACK;
+		} else {
+			cr = I2C_MN_FI2CCR_ACK_ACK;
+		}
+	} else {
+		/* write */
+		/* keep the initial value of FI2CTBC . */
+		ie = I2C_MN_IE_MST_SND_INDETERMINATE;
+		cr = I2C_MN_FI2CCR_ACK_NACK;
+	}
+	if ((i2c_mn_read32(mn_adap, I2C_MN_FI2CSR) & I2C_MN_FI2CSR_BB) ==
+	    I2C_MN_FI2CSR_BB_BUSY) {
+		cr |= I2C_MN_FI2CCR_STA_STO_NOP;
+	} else {
+		cr |= I2C_MN_FI2CCR_STA_STO_START;
+	}
+	cr |= I2C_MN_FI2CCR_MST_MASTER;
+
+	/* Data */
+	dttx = (I2C_MN_FI2CDTTX_COM_COMMAND | (I2C_MN_FI2CDTTX_D & addr));
+
+	DEB2("=== SLAVE ADDRESS %#04x+%c=%#04x\n",
+		msg->addr, flags & I2C_M_RD ? 'R' : 'W', addr
+	);
+
+	ret = i2c_mn_write_cmd_fifo(mn_adap, ie, dttx, cr, i2c_adap->timeout);
+
+	if (-EREMOTEIO == ret) {
+		i2c_mn_stop(i2c_adap);
+	}
+
+	return ret;
+}
+/**
+ * @brief i2c_mn_sendbytes
+ *
+ * Waiting to send a NACK or ACK.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *  I2C Adapter Infomation.
+ * @retval  >=0                     The number of characters written.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ * @retval -ETIMEDOUT(-60)          Data transmission time-out.
+ *
+ */
+static int
+i2c_mn_sendbytes(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_mn_data *mn_adap;
+	struct i2c_algo_mn_exec_info *exec_info;
+	unsigned char *buf;
+	int wrcount = 0;
+	int ret = 0;
+	unsigned long ie;
+	unsigned long cr;
+	unsigned long dttx;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (i2c_adap == NULL) {
+		printk(KERN_ERR "i2c-algo-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	mn_adap = i2c_adap->algo_data;
+	exec_info = &(mn_adap->exec_info);
+	buf = exec_info->buf;
+
+	if (exec_info->len > 0U) {
+		ie = I2C_MN_IE_MST_SND_INDETERMINATE;
+		cr = I2C_MN_FI2CCR_STA_STO_NOP | I2C_MN_FI2CCR_ACK_NACK;
+		dttx = I2C_MN_FI2CDTTX_COM_DATA	|
+			(I2C_MN_FI2CDTTX_D & (unsigned long)buf[exec_info->cnt]);
+
+		ret = i2c_mn_write_cmd_fifo(mn_adap, ie, dttx, cr, i2c_adap->timeout);
+		if (ret != 0) {
+			i2c_mn_stop(i2c_adap);
+			return ret;		/* NAK or TIMEDOUT */
+		}
+
+		wrcount = (int)exec_info->cnt;
+	}
+
+	return wrcount;
+}
+
+/**
+ * @brief i2c_mn_xfer
+ *
+ * Transfer process of the I2C master message.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @param  msgs[]           [in]  struct i2c_msg         Message Info. Array.
+ * @param  num              [in]  int                    Number of Message Info. Array.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EINVAL(-22)             Input parameter Error.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ * @retval -EAGAIN(-11)             Transfer time-out.
+ *
+ */
+static int i2c_mn_xfer(
+	struct i2c_adapter *i2c_adap,
+	struct i2c_msg msgs[],
+	int num
+)
+{
+	int i, ret = 0;
+	struct i2c_msg *pmsg;
+	struct i2c_algo_mn_data *mn_adap;
+	struct i2c_algo_mn_exec_info *exec_info;
+
+	#ifdef DBG_I2C
+	{
+		unsigned int cnt;
+
+		printk("%d: %s  num = %d:\n", current->pid, __func__, num);
+		printk("%d: %s: msg[0].len   = 0x%08X\n", current->pid, __func__, msgs[0].len);
+		printk("%d: %s: msg[0].addr  = 0x%08X\n", current->pid, __func__, msgs[0].addr);
+		printk("%d: %s: msg[0].flags = 0x%08X\n", current->pid, __func__, msgs[0].flags);
+		for (cnt = 0; cnt < msgs[0].len; cnt++) {
+			printk("%d: %s: msg[0].buf[%d] = 0x%08X\n", current->pid, __func__, cnt, msgs[0].buf[cnt]);
+		}
+		for (cnt = 1; cnt < num; cnt++) {
+			printk("%d: %s: msg[%d].len   = 0x%08X\n", current->pid, __func__, cnt, msgs[cnt].len);
+			printk("%d: %s: msg[%d].addr  = 0x%08X\n", current->pid, __func__, cnt, msgs[cnt].addr);
+			printk("%d: %s: msg[%d].flags = 0x%08X\n", current->pid, __func__, cnt, msgs[cnt].flags);
+		}
+	}
+	#endif	/* DBG_I2C */
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if ((i2c_adap == NULL) || (msgs == NULL))	{
+		printk(KERN_ERR "i2c-algo-mn: Access to invalid pointer.\n");
+		ret = -ENODEV;
+		goto MN_END;
+	}
+	mn_adap = i2c_adap->algo_data;
+	exec_info = &(mn_adap->exec_info);
+
+	DEB1("=== i2c_mn_xfer\n");
+
+	{
+		unsigned long cnt;
+		unsigned long sr;
+
+		for (cnt = 0UL; cnt < I2C_MN_BUS_POLLING_CNT; cnt++) {
+			sr = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+			if ((sr & I2C_MN_FI2CSR_DB)
+			    == I2C_MN_FI2CSR_DB_NOT_BUSY) {
+				break;
+			}
+			cond_resched();
+		}
+
+		if (I2C_MN_BUS_POLLING_CNT == cnt) {
+			ret = -EAGAIN;
+			goto MN_END;
+		}
+
+		for (cnt = 0UL; cnt < I2C_MN_BUS_POLLING_CNT; cnt++) {
+			sr = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+			if ((sr & I2C_MN_FI2CSR_BB)
+			   == I2C_MN_FI2CSR_BB_NOT_BUSY) {
+				break;
+			}
+			cond_resched();
+		}
+		if (I2C_MN_BUS_POLLING_CNT == cnt) {
+			ret = -EAGAIN;
+			goto MN_END;
+		}
+
+		sr = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+		if ((sr & (I2C_MN_FI2CSR_RNE | I2C_MN_FI2CSR_TFE))
+		   != (I2C_MN_FI2CSR_RNE_EMPTY | I2C_MN_FI2CSR_TFE_EMPTY)) {
+			i2c_mn_write32(mn_adap, I2C_MN_FI2CRST,
+			(I2C_MN_FI2CRST_TBRST_RST | I2C_MN_FI2CRST_RBRST_RST));
+		    for (cnt = 0UL; cnt < I2C_MN_BUS_POLLING_CNT; cnt++) {
+				sr = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+				if ((sr & (I2C_MN_FI2CSR_RNE | I2C_MN_FI2CSR_TFE))
+				   == (I2C_MN_FI2CSR_RNE_EMPTY | I2C_MN_FI2CSR_TFE_EMPTY)) {
+					break;
+				}
+				cond_resched();
+			}
+			if (I2C_MN_BUS_POLLING_CNT == cnt) {
+				ret = -EAGAIN;
+				goto MN_END;
+			}
+		}
+	}
+
+	for (i = 0; i < num; ++i) 	{
+		/* READ wait just after WRITE */
+		if (i != 0) {
+			if (((msgs[i].flags & I2C_M_RD) != 0U) && ((msgs[i - 1].flags & I2C_M_RD) == 0U)) {
+				if (mn_adap->wr2rd_wait_time != 0U) {
+					signed long waitjiffies;
+
+					waitjiffies = ((signed long)mn_adap->wr2rd_wait_time + 1000 / HZ - 1) *
+						HZ / 1000 + 1;
+					set_current_state(TASK_UNINTERRUPTIBLE);
+					schedule_timeout(waitjiffies);
+				}
+			}
+		}
+
+		pmsg = &msgs[i];
+		exec_info->flags = pmsg->flags;		/* control flag */
+		exec_info->len = pmsg->len;		/* data length */
+		exec_info->buf = pmsg->buf;		/* data buffer pointer */
+		exec_info->cnt = 0U;			/* send/recv counter */
+
+		if ((pmsg->flags & I2C_M_NOSTART) == 0U) {
+			/* Start or ReStart Condition & Slave Address & R/W Command */
+			exec_info->mode = I2C_MN_EXEC_START;		/* execution mode */
+			ret = i2c_mn_start(i2c_adap, pmsg);
+			if (ret < 0) {
+				if (ret == -EREMOTEIO) {
+					DEB2("=== i2c_mn_xfer: NAK from device addr %2.2x msg #%d\n"
+						, msgs[i].addr, i
+					);
+				}
+				goto MN_END;
+			}
+		} else if ((pmsg->flags & I2C_M_RD) != 0U) {
+			/* read bytes into buffer*/
+			DEB2("=== i2c_mn_xfer: read %d bytes.\n", ret);
+			ret = -1;
+			BUG();
+		} else {
+			/* write bytes from buffer */
+			exec_info->mode = I2C_MN_EXEC_SEND;		/* execution mode */
+			ret = i2c_mn_sendbytes(i2c_adap);
+			DEB2("=== i2c_mn_xfer: wrote %d bytes.\n", ret);
+			if (ret < 0) {
+				goto MN_END;
+			}
+		}
+	}
+	i2c_mn_stop(i2c_adap);	/* STOP CONDITION */
+
+	ret = num;
+MN_END:
+
+	#ifdef DBG_I2C
+		if (0 <= ret) {
+			printk("%d: %s: return = %d\n", current->pid, __func__, ret);
+		} else {
+			printk("%d: %s: ERROR: return = %d\n", current->pid, __func__, ret);
+		}
+	#endif	/* DBG_I2C */
+	return ret;
+}
+
+/**
+ * @brief i2c_mn_func
+ *
+ * Acquisition of I2C processing mode.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @retval I2C_FUNC_I2C(1)           Processing mode of the I2C standard.
+ *
+ */
+static u32 i2c_mn_func(struct i2c_adapter *i2c_adap)
+{
+	u32 ret;
+
+	#ifdef DBG_I2C
+		printk("%d: %s:\n", current->pid, __func__);
+	#endif	/* DBG_I2C */
+	DEB1("=== i2c_mn_func\n");
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	ret = I2C_FUNC_I2C;
+	#ifdef DBG_I2C
+		if (0 <= ret) {
+			printk("%d: %s: return = %d\n", current->pid, __func__, ret);
+		} else {
+			printk("%d: %s: ERROR: return = %d\n", current->pid, __func__, ret);
+		}
+	#endif	/* DBG_I2C */
+	return ret;
+}
+
+/**
+ * @brief i2c_mn_init
+ *
+ * Do the initialization process of the device..
+ *
+ * @param  mn_adap          [in]  i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -ETIMEDOUT(-60)          Failed to register the bus rate.
+ *
+ */
+static int
+i2c_mn_init(struct i2c_algo_mn_data *mn_adap)
+{
+
+	int		result = 0;
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (mn_adap == NULL) {
+		printk(KERN_ERR "Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	/*
+	 * Set Bus Rate
+	 */
+	result = i2c_mn_set_busrate(mn_adap, (unsigned int)mn_adap->rate);
+	if (result < 0) {
+		printk(KERN_ERR "Failed to register the bus rate in the initialization process.\n");
+		return result;
+	}
+
+	return 0;
+}
+
+/*
+ * i2c_algorithm Control data
+ */
+static struct i2c_algorithm mn_algo = {
+	.master_xfer   = i2c_mn_xfer,
+	.functionality = i2c_mn_func,
+};
+
+/**
+ * @brief i2c_mn_add_bus
+ *
+ * registration of i2c adapter.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV                  The corresponding device can not be found.
+ * @retval -ETIMEDOUT(-60)          Failed to register the bus rate.
+ *
+ */
+static int
+i2c_mn_add_bus(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_mn_data *mn_adap = i2c_adap->algo_data;
+	int rval;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	/* register new adapter to i2c module... */
+	i2c_adap->algo  = &mn_algo;
+	i2c_adap->timeout = HZ;			/* default values, should */
+	i2c_adap->retries = 3;			/* default values, should */
+
+	rval = i2c_mn_init(mn_adap);
+
+	if (rval == 0) {
+		i2c_add_numbered_adapter(i2c_adap);
+	}
+	return rval;
+}
+
+/**
+ * @brief i2c_mn_del_bus
+ *
+ * unregistration of i2c adapter.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @retval 0                        Normal end.
+ *
+ * @attention
+ * For the wrapper function that simply calls the i2c adapter deletion process
+ *  of the common process, the return value will be 0 (normal end) always regardless
+ *  of the contents of the result.
+ *
+ */
+static int
+i2c_mn_del_bus(struct i2c_adapter *i2c_adap)
+{
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	i2c_del_adapter(i2c_adap);
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_reset
+ *
+ * Do a forced reset of the bus.
+ *
+ * @param  mn_adap          [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  setting          [in]  struct i2c_busreset_ioctl_data * Monitoring timer information.
+ * @retval 0                        Normal end.
+ * @retval -EINVAL(-121)            The corresponding device can not be found.
+ * @retval -EFAULT(-14)             Bus reset time-out.
+ *
+ */
+static int
+i2c_mn_reset(
+	struct i2c_algo_mn_data *mn_adap
+	, struct i2c_busreset_ioctl_data *setting
+)
+{
+	unsigned int interval, times;
+	unsigned long bmmask;
+	unsigned int cnt;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if ((mn_adap == NULL) || (setting == NULL)) {
+		return -EINVAL;
+	}
+
+	interval = setting->interval;
+	times    = setting->times;
+	if ((interval == 0U) || (times == 0U)) {
+		if (times == 0U) {
+			return -EINVAL;
+		} else {
+			return 0;
+		}
+	}
+
+	i2c_mn_write32(mn_adap, I2C_MN_FI2CRST, I2C_MN_FI2CRST_RST_RST);
+
+	bmmask = (I2C_MN_FI2CBM_SCLS_HIGH | I2C_MN_FI2CBM_SDAS_HIGH);
+
+	for (cnt = 0U; cnt < times; cnt++) {
+		if (i2c_mn_busmonitor_check(mn_adap, bmmask) == 0) {
+			return 0;
+		} else {
+			i2c_mn_write32(mn_adap, I2C_MN_FI2CRST, I2C_MN_FI2CRST_RST_RST);
+		}
+
+		udelay(interval);
+	}
+
+	return -EFAULT;
+}
+
+/**
+ * @brief i2c_mn_control
+ *
+ * do the processing for the request of ioctl.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @param  cmd              [in]  unsigned int           Request command.
+ * @param  arg              [in]  unsigned long          Supplied parameters.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EINVAL(-22)             Input parameter Error.
+ * @retval -EFAULT(-14)             Request processing failed.
+ * @retval -ENOTTY(-25)             Non-compliant request command.
+ *
+ */
+static int i2c_mn_control(
+	struct i2c_adapter *i2c_adap, unsigned int cmd, unsigned long arg
+)
+{
+	struct i2c_algo_mn_data *mn_adap;
+	int		status = 0;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (i2c_adap == NULL) {
+		printk(KERN_ERR "i2c-algo-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+	mn_adap = i2c_adap->algo_data;
+
+	DEB1("=== i2c_mn_control\n");
+
+	if (arg == 0UL) {
+		return -EINVAL;
+	}
+
+	switch (cmd) {
+	case I2C_BUSRESET:
+		{
+			struct i2c_busreset_ioctl_data	sBusresetData;
+
+			i2c_lock_adapter(i2c_adap);
+			#ifdef DBG_I2C
+				printk("%d: %s: BUSRESET\n", current->pid, __func__);
+			#endif	/* DBG_I2C */
+			status = copy_from_user(&sBusresetData, (void *)arg, sizeof(struct i2c_busreset_ioctl_data));
+			if (status != 0) {
+				i2c_unlock_adapter(i2c_adap);
+				return -EFAULT;
+			}
+			status = i2c_mn_reset(mn_adap, &sBusresetData);
+			#ifdef DBG_I2C
+				if (0 <= status) {
+					printk("%d: %s: return = %d\n", current->pid, __func__, status);
+				} else {
+					printk("%d: %s: ERROR: return = %d\n", current->pid, __func__, status);
+				}
+			#endif	/* DBG_I2C */
+			i2c_unlock_adapter(i2c_adap);
+			return status;
+		}
+	case I2C_SET_BUSRATE:
+		{
+			i2c_lock_adapter(i2c_adap);
+			#ifdef DBG_I2C
+				printk("%d: %s: SET_BUSRATE\n", current->pid, __func__);
+			#endif	/* DBG_I2C */
+			status = i2c_mn_set_busrate(mn_adap, arg);
+			#ifdef DBG_I2C
+				if (0 <= status) {
+					printk("%d: %s: SET_BUSRATE return = %d\n", current->pid, __func__, status);
+				} else {
+					printk("%d: %s: SET_BUSRATE ERROR: return = %d\n", current->pid, __func__, status);
+				}
+			#endif	/* DBG_I2C */
+			i2c_unlock_adapter(i2c_adap);
+			return status;
+		}
+	case I2C_GET_BUSRATE:
+		{
+			int	busRate;
+
+			i2c_lock_adapter(i2c_adap);
+			#ifdef DBG_I2C
+				printk("%d: %s: GET_BUSRATE\n", current->pid, __func__);
+			#endif	/* DBG_I2C */
+			busRate = i2c_mn_get_busrate(mn_adap);
+			put_user(busRate, (unsigned int *)arg);
+			#ifdef DBG_I2C
+				printk("%d: %s: GET_BUSRATE: return = 0\n", current->pid, __func__);
+			#endif	/* DBG_I2C */
+			i2c_unlock_adapter(i2c_adap);
+			break;
+		}
+	default:
+		return -ENOTTY;
+	}
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_write32
+ *
+ * write the value of the register.
+ *
+ * @param  adap             [in] struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  reg              [in] unsigned long              Offset Address of the register.
+ * @param  val              [in] unsigned long              Register value to writer.
+ *
+ * @attention
+ * It does not become the case processing error of the parameter error..
+ *
+ */
+static void
+i2c_mn_write32(
+	struct i2c_algo_mn_data *adap, unsigned long reg, unsigned long val
+)
+{
+	void *addr;
+	unsigned long flags;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+
+	if (adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return;
+	}
+	spin_lock_irqsave(&(adap->lock), flags);
+	addr = (unsigned char *)adap->iomap_base + (reg & I2C_MN_RMSK);
+	writel(val, addr);	/* iowrite32(val, addr); */
+	spin_unlock_irqrestore(&(adap->lock), flags);
+
+#ifdef DEBUG_IO
+	DEB3("*** write %s at %#lx <= %#04lx\n", names[reg/4], (unsigned long)addr, val);
+#endif
+}
+/**
+ * @brief i2c_mn_read32
+ *
+ * load the value of the register.
+ *
+ * @param  adap             [in] struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  reg              [in] unsigned long              Offset Address of the register.
+ * @retval >= 0                     Register value read.
+ *
+ * @attention
+ * It becomes the return value is zero in the case of parameter error..
+ *
+ */
+static unsigned long
+i2c_mn_read32(struct i2c_algo_mn_data *adap, unsigned long reg)
+{
+	void *addr;
+	unsigned long val, flags;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return 0UL;
+	}
+	spin_lock_irqsave(&(adap->lock), flags);
+	addr = (unsigned char *)adap->iomap_base + (reg & I2C_MN_RMSK);
+	val  = readl(addr);	/* ioread32(addr); */
+	spin_unlock_irqrestore(&(adap->lock), flags);
+
+#ifdef DEBUG_IO
+	DEB3("*** read  %s => %#lx\n", names[reg/4], val);
+#endif
+	return val;
+}
+
+/**
+ * @brief i2c_mn_add_watch_timer
+ *
+ * Registration of the watch doc timer.
+ *
+ * @param  mn_adap          [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ *
+ */
+static void
+i2c_mn_add_watch_timer(struct i2c_algo_mn_data *mn_adap)
+{
+	struct i2c_algo_mn_exec_info *exec_info = &mn_adap->exec_info;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	exec_info->watch_timeflag = 1U;
+	exec_info->cnt_bak = exec_info->cnt;
+
+	exec_info->watch_timer.expires = jiffies + exec_info->watch_timeval;
+	exec_info->watch_timer.data = (unsigned long)mn_adap;
+	exec_info->watch_timer.function = i2c_mn_watch_timer_handler;
+	add_timer(&exec_info->watch_timer);
+}
+
+/**
+ * @brief i2c_mn_del_watch_timer
+ *
+ * Unregistration of the watch doc timer.
+ *
+ * @param  mn_adap          [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ *
+ */
+static void
+i2c_mn_del_watch_timer(struct i2c_algo_mn_data *mn_adap)
+{
+	struct i2c_algo_mn_exec_info *exec_info = &mn_adap->exec_info;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	exec_info->watch_timeflag = 0U;
+	del_timer(&exec_info->watch_timer);
+}
+
+/**
+ * @brief i2c_mn_watch_timer_handler
+ *
+ * Handler for timeout Of watch doc timer.
+ *
+ * @param  data             [in]  unsigned long  ID number of the cyclic handler to be referenced.
+ *
+ */
+static void
+i2c_mn_watch_timer_handler(unsigned long data)
+{
+	struct i2c_algo_mn_data *mn_adap = (struct i2c_algo_mn_data *)data;
+	struct i2c_algo_mn_exec_info *exec_info = &(mn_adap->exec_info);
+	unsigned long flags;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	exec_info->watch_timeflag = 0U;
+
+	/* check whether to have already done wakeup.  */
+	if (1 == mn_adap->irq_event) {
+		/* Wakeup has already been executed.  */
+		return;
+	}
+
+	if (exec_info->cnt != exec_info->cnt_bak) {
+		/* next watch timer */
+		i2c_mn_add_watch_timer(mn_adap);
+	} else {
+		/* timeout error, wakeup */
+		exec_info->result = -ETIMEDOUT;
+
+		/* wake up */
+		spin_lock_irqsave(&(mn_adap->lock), flags);
+		mn_adap->irq_event = 1;
+		spin_unlock_irqrestore(&(mn_adap->lock), flags);
+		wake_up(&(mn_adap->wait));
+	}
+}
+
+/**
+ * @brief i2c_mn_write_cmd_fifo
+ *
+ * .
+ *
+ * @param  adap             [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @param  ie               [in]  unsigned long              Interrupt mask value.
+ * @param  dttx             [in]  unsigned long              Transmit FIFO value.
+ * @param  cr               [in]  unsigned long              Control register value.
+ * @param  timeout          [in]  int                        Timeout value.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EREMOTEIO(-121)         Status mismatch or Bus Busy.
+ * @retval -ETIMEDOUT(-60)          Data transmission time-out.
+ *
+ * @attention
+ * Please Call after you Open the device this function.
+ * However, you can not directly call from the user application.
+ *
+ */
+static int
+i2c_mn_write_cmd_fifo(
+	struct i2c_algo_mn_data *adap,
+	unsigned long ie,	/* FI2CIE all bits fixed */
+	unsigned long dttx,	/* FI2CDTTX all bits fixed */
+	unsigned long cr,	/* FI2CCR.MST,STA,STO,ACK  FI2CCR.GACK not fixed */
+	int timeout)
+{
+	void *addr_dttx;
+	void *addr_cr;
+	int irq;
+	int ret = 0;
+	unsigned long flags;
+	unsigned long nowcr;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	if (i2c_mn_set_ie(adap, ie) != 0) {
+		return -EREMOTEIO;
+	}
+
+	addr_dttx = (unsigned char *)adap->iomap_base + (I2C_MN_FI2CDTTX & I2C_MN_RMSK);
+	addr_cr   = (unsigned char *)adap->iomap_base + (I2C_MN_FI2CCR   & I2C_MN_RMSK);
+	irq = adap->irq;
+
+#ifdef DEBUG_IO
+	DEB2(
+		"*** Write CMD and Wait IRQ [%lu msec] TIMEOUT[%u]\n"
+		, ((jiffies * 1000) / HZ), timeout
+	);
+	DEB3("=== Enable IRQ\n");
+#endif
+	nowcr = i2c_mn_read32(adap, I2C_MN_FI2CCR);
+
+	/*
+	 *  1byte Read with Restart (expertise of H/W team)
+	 *   1byte Read Command with ReStart: RBC <-- 1: Rcv Byte Num Spec Flow
+	 *   Read Command of except above   : RBC <-- 0: Indeterminate Length Flow
+	 *   * Write Command or data are not related to RBC, leave RBC as it is.
+	 */
+	if ((dttx & (I2C_MN_FI2CDTTX_COM | 0x01UL))
+	    == (I2C_MN_FI2CDTTX_COM_COMMAND | 0x01UL)) {
+		if ((cr & (I2C_MN_FI2CCR_STA_STO | I2C_MN_FI2CCR_ACK))
+		    == (I2C_MN_FI2CCR_STA_STO_NOP | I2C_MN_FI2CCR_ACK_NACK)) {
+			i2c_mn_write32(adap, I2C_MN_FI2CRBC, 1UL);
+		} else {
+			i2c_mn_write32(adap, I2C_MN_FI2CRBC, 0UL);
+		}
+	}
+
+	if ((cr & I2C_MN_FI2CCR_STA_STO)
+	    == I2C_MN_FI2CCR_STA_STO_START) {
+		/*
+		 *   When 1st msg (w/ Start)
+		 */
+		cr |= (nowcr & I2C_MN_FI2CCR_GACK);
+		#ifdef DEBUG_IO
+		DEB3("*** write(writel) %s at %#lx <= %#04lx\n",
+		     names[I2C_MN_FI2CDTTX/4], (unsigned long)addr_dttx, dttx);
+		DEB3("*** write(writel) %s at %#lx <= %#04lx\n",
+		     names[I2C_MN_FI2CCR/4], (unsigned long)addr_cr, cr);
+		#endif
+		enable_irq(irq);
+		spin_lock_irqsave(&(adap->lock), flags);
+		adap->irq_event = 0;
+		adap->exec_info.result = 0;
+		writel(dttx, addr_dttx); /* set command */
+		writel(cr, addr_cr);     /* issue Start condition */
+		spin_unlock_irqrestore(&(adap->lock), flags);
+	} else if ((cr & I2C_MN_FI2CCR_STA_STO)
+		   == I2C_MN_FI2CCR_STA_STO_NOP) {
+		/*
+		 *  When 2nd or later msg
+		 */
+		if (((nowcr ^ cr) & I2C_MN_FI2CCR_ACK) != 0UL) {
+			i2c_mn_write32(adap, I2C_MN_FI2CCR,
+				(nowcr & ~I2C_MN_FI2CCR_ACK)
+				| (cr & I2C_MN_FI2CCR_ACK));
+		}
+		#ifdef DEBUG_IO
+		DEB3("*** write(writel) %s at %#lx <= %#04lx\n",
+		     names[I2C_MN_FI2CDTTX/4], (unsigned long)addr_dttx, dttx);
+		#endif
+		enable_irq(irq);
+		spin_lock_irqsave(&(adap->lock), flags);
+		adap->irq_event = 0;
+		adap->exec_info.result = 0;
+		writel(dttx, addr_dttx); /* When ReStart set command */
+								 /* and issue ReStart */
+		spin_unlock_irqrestore(&(adap->lock), flags);
+	} else {
+		BUG();
+	}
+
+	if (irq > -1) {
+		adap->exec_info.watch_timeval = timeout;
+		i2c_mn_add_watch_timer(adap);
+
+		wait_event(adap->wait, (adap->irq_event == 1));
+		ret = adap->exec_info.result;
+
+		if (adap->exec_info.watch_timeflag == 1U) {
+			i2c_mn_del_watch_timer(adap);
+		}
+#ifdef DEBUG_IO
+		DEB3("*** i2c_mn_write_cmd_fifo Result = %d(%x)\n", ret, ret);
+#endif
+	} else {
+		unsigned long start;
+
+		ret = 0;
+		start = jiffies;
+		/* Wait for SCL High */
+		while ((i2c_mn_read32(adap, I2C_MN_FI2CBM) & I2C_MN_FI2CBM_SCLS) != I2C_MN_FI2CBM_SCLS_HIGH) {
+			if (time_after_eq(jiffies, start + (unsigned long)timeout)) {
+				if ((i2c_mn_read32(adap, I2C_MN_FI2CBM) & I2C_MN_FI2CBM_SCLS) == I2C_MN_FI2CBM_SCLS_HIGH) {
+					break;
+				}
+				ret = -ETIMEDOUT;
+				break;
+			}
+			cond_resched();
+		}
+	}
+
+#ifdef DEBUG_IO
+	DEB2(
+		"*** End Wait [%lu msec] errno = %d\n"
+		, ((jiffies * 1000) / HZ), ret
+	);
+	DEB3("=== Disable IRQ\n");
+#endif
+
+	/* Disable all int fact */
+	i2c_mn_write32(adap, I2C_MN_FI2CIE, I2C_MN_FI2CIE_ALL_DISABLE);
+
+	/* Clear all int fact */
+	i2c_mn_write32(adap, I2C_MN_FI2CIC, I2C_MN_FI2CIC_ALL_CLEAR);
+
+	disable_irq(irq);
+
+	return ret;
+}
+
+/**
+ * @brief i2c_mn_get_l_period_time
+ *
+ * Calculation function of the period timer associated with the setting of the clock frequency.
+ *
+ * @param  scf              [in]  unsigned long  Clock cycle.
+ * @retval >= 0                     period timer was calculated.
+ *
+ */
+static inline unsigned long i2c_mn_get_l_period_time(unsigned long scf)
+{
+	unsigned long col;
+
+	if (scf < I2C_MN_SERIAL_CLOCK_100) {
+		col = ((((I2C_MN_L_PERIOD_TIME_50 - I2C_MN_L_PERIOD_TIME_100)
+			   * (I2C_MN_SERIAL_CLOCK_100 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_100 - I2C_MN_SERIAL_CLOCK_50))
+			   + I2C_MN_L_PERIOD_TIME_100);
+	} else {
+		col = ((((I2C_MN_L_PERIOD_TIME_100 - I2C_MN_L_PERIOD_TIME_400)
+			   * (I2C_MN_SERIAL_CLOCK_400 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_400 - I2C_MN_SERIAL_CLOCK_100))
+			   + I2C_MN_L_PERIOD_TIME_400);
+	}
+
+	return col;
+}
+
+/**
+ * @brief i2c_mn_get_setup_time
+ *
+ * Calculation function of the setup timer associated with the setting of the clock frequency.
+ *
+ * @param  scf              [in]  unsigned long  Clock cycle.
+ * @retval >= 0                     Setup timer was calculated.
+ *
+ */
+static inline unsigned long i2c_mn_get_setup_time(unsigned long scf)
+{
+	unsigned long col;
+
+	if (scf < I2C_MN_SERIAL_CLOCK_100) {
+		col = ((((I2C_MN_SETUP_TIME_50 - I2C_MN_SETUP_TIME_100)
+			   * (I2C_MN_SERIAL_CLOCK_100 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_100 - I2C_MN_SERIAL_CLOCK_50))
+			   + I2C_MN_SETUP_TIME_100);
+	} else {
+		col = ((((I2C_MN_SETUP_TIME_100 - I2C_MN_SETUP_TIME_400)
+			   * (I2C_MN_SERIAL_CLOCK_400 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_400 - I2C_MN_SERIAL_CLOCK_100))
+			   + I2C_MN_SETUP_TIME_400);
+	}
+
+	return col;
+}
+
+/**
+ * @brief i2c_mn_get_data_setup_time
+ *
+ * Calculation function of the setup timer associated with the setting of the clock frequency.
+ *
+ * @param  scf              [in]  unsigned long  Clock cycle.
+ * @retval >= 0                     Data Setup timer was calculated.
+ *
+ */
+static inline unsigned long i2c_mn_get_data_setup_time(unsigned long scf)
+{
+	unsigned long col;
+
+	if (scf < I2C_MN_SERIAL_CLOCK_100) {
+		col = ((((I2C_MN_DATA_SETUP_TIME_50 - I2C_MN_DATA_SETUP_TIME_100)
+			   * (I2C_MN_SERIAL_CLOCK_100 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_100 - I2C_MN_SERIAL_CLOCK_50))
+			   + I2C_MN_DATA_SETUP_TIME_100);
+	} else {
+		col = ((((I2C_MN_DATA_SETUP_TIME_100 - I2C_MN_DATA_SETUP_TIME_400)
+			   * (I2C_MN_SERIAL_CLOCK_400 - scf))
+			   / (I2C_MN_SERIAL_CLOCK_400 - I2C_MN_SERIAL_CLOCK_100))
+			   + I2C_MN_DATA_SETUP_TIME_400);
+	}
+
+	return col;
+}
+
+/**
+ * @brief i2c_mn_set_busrate
+ *
+ * I will change the bus rate of the specified device.
+ *
+ * @param  adap             [in]  struct i2c_algo_mn_data *    I2C Adapter Infomation.
+ * @param  rate             [in]  unsigned int                 BusRate value you want to set.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EFAULT(-14)             Bus reset time-out.
+ *
+ * @attention
+ * Please Call after you Open the device this function.
+ * However, you can not directly call from the user application.
+ *
+ */
+static int
+i2c_mn_set_busrate(struct i2c_algo_mn_data *adap, unsigned int rate)
+{
+	unsigned long scf;
+	unsigned long val;
+	struct i2c_busreset_ioctl_data sBusresetData;
+	int ret;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	/* Keep bus clock frequency (rate = SCL freq[kHz] / 10[kHz])       */
+	/* Bus clock can be changed by only attach entry.           */
+	if (rate < I2C_MN_RATE_MIN) {
+		#ifdef DBG_I2C
+			printk("%s: %d: rate Below the minimum value\n", __func__, rate);
+		#endif	/* DBG_I2C */
+		rate = I2C_MN_RATE_MIN;
+	} else if (I2C_MN_RATE_MAX < rate) {
+		#ifdef DBG_I2C
+			printk("%s: %d: rate Maximum value or more\n", __func__, rate);
+		#endif	/* DBG_I2C */
+		rate = I2C_MN_RATE_MAX;
+	}
+
+	/* Bus Reset */
+	sBusresetData.interval = HZ;
+	sBusresetData.times    = 3U;
+
+	ret = i2c_mn_reset(adap, &sBusresetData);
+	if (ret < 0) {
+		printk(KERN_ERR "i2c-mn:  busrate rewrite timeoutr.\n");
+		return  ret;
+	}
+
+	/*
+	 *  Set Clock etc.
+	 *   Serial Clock Frequency(scf) = rate * 10 [kHz]
+	 *   I2C_MN_IOCLK = PCLK[Hz]
+	 *   I2C_MN_CLK_DIV = 4
+	 *   FI2CCYC.C = (PCLK[Hz] / (scf * 1000)) / 4 [kHz]
+	 *   FI2CLCTL.L = (L Period Time[ms] * PCLK[Hz]) / 4 [ns]
+	 *   FI2CSSUT.S = (Setup Time[ms] * PCLK[Hz])  / 4 [ns]
+	 *   FI2CDSUT.T = (Data Setup Time[ms] * PCLK[Hz])  / 4 [ns]
+	 *   * L Period Time, Setup Time, Data Setup Time are
+	 *     proportionally between 100[kHz] and 400[kHz].
+	 */
+	scf = (unsigned long)(rate * 10U);
+	val = (I2C_MN_IOCLK / (scf * 1000UL)) / I2C_MN_CLK_DIV;
+	i2c_mn_write32(adap, I2C_MN_FI2CCYC, val);
+
+	val = (i2c_mn_get_l_period_time(scf) * (I2C_MN_IOCLK / I2C_MN_CLK_DIV / 1000UL)) / 1000000UL;
+	i2c_mn_write32(adap, I2C_MN_FI2CLCTL, val);
+
+	val = (i2c_mn_get_setup_time(scf) * (I2C_MN_IOCLK / I2C_MN_CLK_DIV / 1000UL)) / 1000000UL;
+	i2c_mn_write32(adap, I2C_MN_FI2CSSUT, val);
+
+	val = (i2c_mn_get_data_setup_time(scf) * (I2C_MN_IOCLK / I2C_MN_CLK_DIV / 1000UL)) / 1000000UL;
+	i2c_mn_write32(adap, I2C_MN_FI2CDSUT, val);
+
+	udelay(adap->udelay);
+
+	/* Calc Delay [sec = 1 / Hz] => [msec =    1 / kHz] */
+	/*                           => [usec = 1000 / kHz] */
+	adap->udelay = ((1000U / scf) / 1000U) + 1U;
+
+#ifdef DEBUG_IO
+	DEB3("*** i2c_mn_set_busrate : udelay %d\n", adap->udelay);
+#endif
+
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_get_busrate
+ *
+ * Acquisition of setting bus rate of the specified device.
+ *
+ * @param  adap             [in]  struct i2c_algo_mn_data *  I2C Adapter Infomation.
+ * @retval >=0                      BusRate value read.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ *
+ * @attention
+ * Please Call after you Open the device this function.
+ * However, you can not directly call from the user application.
+ *
+ */
+static int
+i2c_mn_get_busrate(struct i2c_algo_mn_data *adap)
+{
+	int rate;
+	unsigned long cnt;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+
+	/*
+	 *   I2C_MN_IOCLK = PCLK[Hz]
+	 *   I2C_MN_CLK_DIV = 4
+	 *   scf = (rate * 10)[kHz]
+	 *   FI2CCYC.C = (PCLK[Hz] / (scf * 1000)) / 4 [kHz]
+	 *   rate = (PCLK[Hz] /FI2CCYC.C ) / 4 / 1000 / 10 [kHz]
+	 */
+	cnt = i2c_mn_read32(adap, I2C_MN_FI2CCYC);
+	rate = (int)((I2C_MN_IOCLK / cnt) / I2C_MN_CLK_DIV / 1000UL / 10UL);
+
+	return rate;
+}
+
+/**
+ * @brief i2c_mn_handler
+ *
+ * Interrupt Control.
+ *
+ * @param  this_irq         [in]  int    Interrupt number.
+ * @param  dev_id           [in]  void * Interrupt target device identification number.
+ * @retval IRQ_HANDLED              interrupt was handled(0x01).
+ *
+ */
+static irqreturn_t
+i2c_mn_handler(int this_irq, void *dev_id)
+{
+	struct i2c_algo_mn_data *mn_adap =
+		((struct i2c_adapter *)dev_id)->algo_data;
+	struct i2c_algo_mn_exec_info *exec_info =
+		&(mn_adap->exec_info);
+	unsigned char *buf = exec_info->buf;
+	unsigned long flags;
+	unsigned long ifct, ifct_mask;
+	unsigned long stat;
+	unsigned long dttx;
+	unsigned long cr;
+	unsigned long sr;
+	unsigned short sendnum;
+	unsigned short i;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	/* check whether to have already done wakeup.  */
+	if (1 == mn_adap->irq_event) {
+		/* Wakeup has already been executed.  */
+		return IRQ_HANDLED;
+	}
+
+	/* get interrupt factor and status info */
+	ifct = i2c_mn_read32(mn_adap, I2C_MN_FI2CINT);
+	stat = i2c_mn_read32(mn_adap, I2C_MN_FI2CSR);
+
+	ifct_mask = I2C_MN_FI2CINT_ALL &
+		(I2C_MN_FI2CINT_TRI | I2C_MN_FI2CINT_RRI);
+	if ((ifct & ifct_mask) == 0UL) {
+		return IRQ_HANDLED;
+	}
+
+	/* check the execution result */
+	switch (exec_info->mode) {
+	case I2C_MN_EXEC_START:
+		if (i2c_mn_check_status(exec_info, ifct, stat) == 0) {
+			/* set next operation */
+			if ((exec_info->flags & I2C_M_RD) != 0U) {
+				exec_info->mode = I2C_MN_EXEC_READ;
+				if (i2c_mn_check_ifct_read(ifct) == 0) {
+					buf[exec_info->cnt]
+						= (i2c_mn_read32(mn_adap, I2C_MN_FI2CDTRX) & I2C_MN_FI2CDTRX_D);
+					exec_info->cnt++;
+				} else {
+					#ifdef DBG_I2C
+						printk("%d: %s: ERROR: %d: flags = 0x%08X\n", current->pid, __func__, __LINE__, exec_info->flags);
+					#endif	/* DBG_I2C */
+					exec_info->result = -EREMOTEIO;
+				}
+			} else {
+				exec_info->mode = I2C_MN_EXEC_SEND;
+				if (i2c_mn_check_ifct_send(ifct) != 0) {
+					#ifdef DBG_I2C
+						printk("%d: %s: ERROR: %d: flags = 0x%08X\n", current->pid, __func__, __LINE__, exec_info->flags);
+					#endif	/* DBG_I2C */
+					exec_info->result = -EREMOTEIO;
+				}
+			}
+		} else {
+			#ifdef DBG_I2C
+				printk("%d: %s: ERROR: %d: flags = 0x%08X\n", current->pid, __func__, __LINE__, exec_info->flags);
+			#endif	/* DBG_I2C */
+			exec_info->result = -EREMOTEIO;	/* NAK */
+		}
+		break;
+
+	case I2C_MN_EXEC_READ:
+		if (i2c_mn_check_ifct_read(ifct) == 0) {
+			buf[exec_info->cnt]
+			= i2c_mn_read32(mn_adap, I2C_MN_FI2CDTRX);
+			exec_info->cnt++;
+		} else {
+			#ifdef DBG_I2C
+				printk("%d: %s: ERROR: %d: flags = 0x%08X\n", current->pid, __func__, __LINE__, exec_info->flags);
+			#endif	/* DBG_I2C */
+			exec_info->result = -EREMOTEIO;
+		}
+		break;
+
+	case I2C_MN_EXEC_SEND:
+		if ((i2c_mn_check_status(exec_info, ifct, stat) == 0) &&
+		    ((i2c_mn_check_ifct_send(ifct)) == 0)) {
+			exec_info->cnt++;
+		} else {
+			#ifdef DBG_I2C
+				printk("%d: %s: ERROR: %d: flags = 0x%08X\n", current->pid, __func__, __LINE__, exec_info->flags);
+			#endif	/* DBG_I2C */
+			exec_info->result = -EREMOTEIO;	/* NAK */
+		}
+	    break;
+
+	default:
+	    break;
+	}
+
+	if ((exec_info->cnt < exec_info->len) && (0 == exec_info->result)) {
+		/* execute the next byte */
+		if (exec_info->mode == I2C_MN_EXEC_READ) {
+			/* get now FI2CCR for create setting value. */
+			cr = i2c_mn_read32(mn_adap, I2C_MN_FI2CCR);
+			if ((exec_info->cnt < (exec_info->len - 1U)) && ((exec_info->flags & I2C_M_NO_RD_ACK) == 0U)) {
+				cr &= ~I2C_MN_FI2CCR_ACK;
+				cr |= I2C_MN_FI2CCR_ACK_ACK; /* Send Ack */
+			} else {
+				cr &= ~I2C_MN_FI2CCR_ACK;
+				cr |= I2C_MN_FI2CCR_ACK_NACK; /* NoAck */
+			}
+
+			i2c_mn_write32(mn_adap, I2C_MN_FI2CCR, cr);
+		} else if (exec_info->mode == I2C_MN_EXEC_SEND) {
+			sendnum = exec_info->len - exec_info->cnt;
+			if (sendnum >= I2C_MN_SEND_FIFO_NUM) {
+				sendnum = I2C_MN_SEND_FIFO_NUM;
+			}
+			for (i = 0U; i < sendnum; i++) {
+				sr = i2c_mn_read32(mn_adap,
+						      I2C_MN_FI2CSR);
+				/* write to Send FIFO with check of not full */
+				if ((sr & I2C_MN_FI2CSR_TNF)
+				    == I2C_MN_FI2CSR_TNF_NOT_FULL) {
+					dttx = I2C_MN_FI2CDTTX_COM_DATA
+						| (I2C_MN_FI2CDTTX_D & buf[exec_info->cnt + i]);
+					i2c_mn_write32(mn_adap,
+							  I2C_MN_FI2CDTTX,
+							  dttx);
+				} else {
+					/*
+					 *  FIXME: It should not occur that
+					 *         Send FIFO is full.
+					 */
+					BUG();
+				}
+			}
+			/* the last one is added at next interrupt. */
+			exec_info->cnt += (sendnum - 1);
+		}
+		/* clear int fact */
+		i2c_mn_write32(mn_adap, I2C_MN_FI2CIC, ifct & I2C_MN_FI2CIC_ALL);
+	} else {
+		/* clear int fact */
+		i2c_mn_write32(mn_adap, I2C_MN_FI2CIC, ifct & I2C_MN_FI2CIC_ALL);
+		/* wake up */
+		spin_lock_irqsave(&(mn_adap->lock), flags);
+		mn_adap->irq_event = 1;
+		spin_unlock_irqrestore(&(mn_adap->lock), flags);
+		wake_up(&(mn_adap->wait));
+	}
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Default information for each chip
+ */
+/* I2C-0(ch0) Data */
+static struct i2c_algo_mn_data mn_data_ch0;
+static struct i2c_adapter mn_ops_ch0 = {
+	.owner          = THIS_MODULE,
+	.class          = I2C_CLASS_HWMON,
+	.algo_data      = &mn_data_ch0,
+	.name           = "MN I2C Adapter(ch0)",
+	.pfControl	= i2c_mn_control,
+	.nr		= 0,
+};
+
+/* I2C-0(ch1) Data */
+static struct i2c_algo_mn_data mn_data_ch1;
+static struct i2c_adapter mn_ops_ch1 = {
+	.owner          = THIS_MODULE,
+	.class          = I2C_CLASS_HWMON,
+	.algo_data      = &mn_data_ch1,
+	.name           = "MN I2C Adapter(ch1)",
+	.pfControl	= i2c_mn_control,
+	.nr		= 1,
+};
+#ifdef CONFIG_MACH_GERDAC
+/* I2C-1(ch0) Data */
+static struct i2c_algo_mn_data mn_data_ch2;
+static struct i2c_adapter mn_ops_ch2 = {
+	.owner          = THIS_MODULE,
+	.class          = I2C_CLASS_HWMON,
+	.algo_data      = &mn_data_ch2,
+	.name           = "MN I2C Adapter(ch2)",
+	.pfControl	= i2c_mn_control,
+	.nr		= 2,
+};
+
+/* I2C-1(ch1) Data */
+static struct i2c_algo_mn_data mn_data_ch3;
+static struct i2c_adapter mn_ops_ch3 = {
+	.owner          = THIS_MODULE,
+	.class          = I2C_CLASS_HWMON,
+	.algo_data      = &mn_data_ch3,
+	.name           = "MN I2C Adapter(ch3)",
+	.pfControl	= i2c_mn_control,
+	.nr		= 3,
+};
+#endif
+
+/*
+ * Chip Basic data
+ */
+static struct i2c_adapter *mn_ops[I2C_MN_ADAP_MAX + 1] = {
+	[0] = &mn_ops_ch0,
+	[1] = &mn_ops_ch1,
+#ifdef CONFIG_MACH_GERDAC
+	[2] = &mn_ops_ch2,
+	[3] = &mn_ops_ch3,
+#endif /* CONFIG_MACH_GERDAC */
+	[I2C_MN_ADAP_MAX] = NULL,
+};
+
+/**
+ * @brief i2c_mn_bus_init_sub
+ *
+ * Sub-function for "i2c_mn_bus_init".
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ *
+ */
+static int i2c_mn_bus_init_sub(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_mn_data *mn_adap;
+	unsigned long base;
+	int           irq;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (i2c_adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+	mn_adap = i2c_adap->algo_data;
+
+	if (mn_adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return -ENODEV;
+	}
+	base = mn_adap->base;
+	irq  = mn_adap->irq;
+
+	init_waitqueue_head(&(mn_adap->wait));
+	mn_adap->irq_event = 0;
+	spin_lock_init(&(mn_adap->lock));
+
+	printk(KERN_INFO "i2c-mn: i/o base %#08lx. irq %d\n", base, irq);
+
+	if (request_mem_region(base, I2C_MN_IO_SIZE, "i2c-mn") == 0) {
+		printk(KERN_ERR "i2c-mn: I/O address %#08lx is in use.\n", base);
+		goto out;
+	}
+
+	mn_adap->iomap_base = ioremap(base, I2C_MN_IO_SIZE);
+	if ((mn_adap->iomap_base) == 0) {
+		printk(KERN_ERR "i2c-mn: I/O address %#08lx can't map.\n", base);
+		goto out_region;
+	}
+
+	disable_irq(irq);
+
+	if (irq > -1) {
+		if (request_irq(irq, i2c_mn_handler, 0, "i2c-mn", i2c_adap) < 0) {
+			printk(KERN_ERR "i2c-mn: Request irq%d failed\n", irq);
+			goto out_remap;
+		}
+	}
+
+	/*
+	 * Confirmation
+	 */
+	/* Clear INTC
+	mn_intc_clear( irq );
+	*/
+
+	disable_irq(irq);
+
+	init_timer(&mn_adap->exec_info.watch_timer);
+
+	if (i2c_mn_add_bus(i2c_adap) < 0) {
+		printk(KERN_ERR "i2c-mn: Failed to add i2c bus\n");
+		goto out_irq;
+	}
+	return 0;
+
+ out_irq:
+	if (irq > -1)
+		free_irq(irq, i2c_adap);
+ out_remap:
+	iounmap(mn_adap->iomap_base);
+ out_region:
+	release_mem_region(base, I2C_MN_IO_SIZE);
+ out:
+	return -ENODEV;
+}
+
+/**
+ * @brief i2c_mn_probe
+ *
+ * Driver registration process.
+ *
+ * @param  pdev             [in]  struct platform_device *  Device Registration Information.
+ * @retval 0                        Normal end.
+ * @retval -ENODEV(-19)             The corresponding device can not be found.
+ * @retval -EINVAL(-22)             Number of registered over.
+ *
+ */
+static int i2c_mn_probe(struct platform_device *pdev)
+{
+	struct i2c_mn_pdata		*pdata = dev_get_platdata(&pdev->dev);
+	struct i2c_algo_mn_data		*psAlgoData;
+	int		ret;
+
+	if (I2C_MN_ADAP_MAX <= pdev->id) {
+		return -EINVAL;
+	}
+
+	psAlgoData = (struct i2c_algo_mn_data *)mn_ops[pdev->id]->algo_data;
+	psAlgoData->base = pdata->base;
+	psAlgoData->irq  = pdata->irq;
+	psAlgoData->rate = pdata->rate;
+
+	ret = i2c_mn_bus_init_sub(mn_ops[pdev->id]);
+	return ret;
+}
+
+/*
+ * I2C driver Control data
+ */
+static struct platform_driver i2c_mn_driver = {
+	.probe = i2c_mn_probe,
+	.remove = i2c_mn_remove,
+	.driver = {
+		.name = "i2c-mn",
+		.owner = THIS_MODULE,
+	},
+};
+
+/**
+ * @brief i2c_mn_bus_exit_sub
+ *
+ * Sub-function for Release process of the driver when deleting.
+ *
+ * @param  i2c_adap         [in]  struct i2c_adapter *   I2C Adapter Infomation.
+ *
+ */
+static void
+i2c_mn_bus_exit_sub(struct i2c_adapter *i2c_adap)
+{
+	struct i2c_algo_mn_data *mn_adap;
+	unsigned long base;
+	int           irq;
+
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	if (i2c_adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return;
+	}
+
+	mn_adap = i2c_adap->algo_data;
+	if (mn_adap == NULL) {
+		printk(KERN_ERR "i2c-mn: Access to invalid pointer.\n");
+		return;
+	}
+
+	base = mn_adap->base;
+	irq  = mn_adap->irq;
+
+	i2c_mn_del_bus(i2c_adap);
+
+	if (irq > 0) {
+		disable_irq(irq);
+		free_irq(irq, i2c_adap);
+	}
+	iounmap(mn_adap->iomap_base);
+	release_mem_region(base, I2C_MN_IO_SIZE);
+}
+
+/**
+ * @brief i2c_mn_remove
+ *
+ * Release process of the driver when deleting.
+ *
+ * @param  pdev             [in]  struct platform_device *     Device Registration Information.
+ * @retval 0                        Normal end.
+ *
+ * @attention
+ * This function is Wrapper function of "i2c_mn_bus_exit_sub".
+ *
+ */
+static int i2c_mn_remove(struct platform_device *pdev)
+{
+	DEB3("\n\n##** %s, %d, %s **##\n\n", __FILE__, __LINE__, __func__);
+	i2c_mn_bus_exit_sub(mn_ops[pdev->id]);
+
+	return 0;
+}
+
+/**
+ * @brief i2c_mn_bus_init
+ *
+ * Initialization process of driver registration.
+ *
+ * @retval 0                        Normal end.
+ * @retval -EBUSY(-16)              Already registered.
+ * @retval -EINVAL(-22)             Connection destination bus is missing.
+ * @retval -ENOMEM(-12)             Required memory acquisition failure.
+ *
+ * @attention
+ * This function is called from the kernel to the driver when registering.
+ *
+ */
+static int __init i2c_mn_bus_init(void)
+{
+	int		status;
+
+	status = platform_driver_register(&i2c_mn_driver);
+
+	return status;
+}
+
+/**
+ * @brief i2c_mn_bus_exit
+ *
+ * Release process of the driver when deleting.
+ *
+ * @attention
+ * This function is called from the kernel to the driver when released.
+ *
+ */
+static void __exit i2c_mn_bus_exit(void)
+{
+	platform_driver_unregister(&i2c_mn_driver);
+}
+
+MODULE_LICENSE("GPL");
+subsys_initcall(i2c_mn_bus_init);
+module_exit(i2c_mn_bus_exit);
+
+module_param(i2c_debug, int, 0);
diff -uNr linux-3.14.19/drivers/i2c/i2c-dev.c linux-gerda/drivers/i2c/i2c-dev.c
--- linux-3.14.19/drivers/i2c/i2c-dev.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/i2c/i2c-dev.c	2017-06-22 09:53:00.247039029 +0900
@@ -330,6 +330,7 @@
 	return res;
 }
 
+#if !defined(CONFIG_I2C_MN) && !defined(CONFIG_I2C_MN_MODULE)
 static noinline int i2cdev_ioctl_smbus(struct i2c_client *client,
 		unsigned long arg)
 {
@@ -414,6 +415,7 @@
 	}
 	return res;
 }
+#endif
 
 static long i2cdev_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
@@ -445,17 +447,29 @@
 		client->addr = arg;
 		return 0;
 	case I2C_TENBIT:
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+		printk("%d: %s: I2C_TENBIT is Non-compliant request\n",
+			current->pid, __func__);
+		return -ENOTTY;
+#else
 		if (arg)
 			client->flags |= I2C_M_TEN;
 		else
 			client->flags &= ~I2C_M_TEN;
 		return 0;
+#endif
 	case I2C_PEC:
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+		printk("%d: %s: I2C_PEC is Non-compliant request\n",
+			current->pid, __func__);
+		return -ENOTTY;
+#else
 		if (arg)
 			client->flags |= I2C_CLIENT_PEC;
 		else
 			client->flags &= ~I2C_CLIENT_PEC;
 		return 0;
+#endif
 	case I2C_FUNCS:
 		funcs = i2c_get_functionality(client->adapter);
 		return put_user(funcs, (unsigned long __user *)arg);
@@ -464,7 +478,13 @@
 		return i2cdev_ioctl_rdrw(client, arg);
 
 	case I2C_SMBUS:
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+		printk("%d: %s: I2C_SMBUS is Non-compliant request\n",
+			current->pid, __func__);
+		return -ENOTTY;
+#else
 		return i2cdev_ioctl_smbus(client, arg);
+#endif
 
 	case I2C_RETRIES:
 		client->adapter->retries = arg;
@@ -481,8 +501,20 @@
 		 * zero in this case, and userspace code might accidentally
 		 * have depended on that bug.
 		 */
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+		{
+			int status;
+			if (client->adapter->pfControl) {
+				status = (*client->adapter->pfControl)(client->adapter, cmd, arg);
+				if (0 > status)
+					printk("%d: %s: ERROR: return = %d\n", current->pid, __func__, status);
+				return status;
+			}
+		}
+#endif
 		return -ENOTTY;
 	}
+
 	return 0;
 }
 
diff -uNr linux-3.14.19/drivers/irqchip/irq-gic.c linux-gerda/drivers/irqchip/irq-gic.c
--- linux-3.14.19/drivers/irqchip/irq-gic.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/irqchip/irq-gic.c	2017-06-22 09:52:38.839039666 +0900
@@ -246,9 +246,16 @@
 static int gic_set_affinity(struct irq_data *d, const struct cpumask *mask_val,
 			    bool force)
 {
+#ifdef CONFIG_SHARED_GIC
+	void __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + gic_irq(d);
+	unsigned int cpu;
+	u8 val;
+	unsigned int i;
+#else /* !CONFIG_SHARED_GIC */
 	void __iomem *reg = gic_dist_base(d) + GIC_DIST_TARGET + (gic_irq(d) & ~3);
 	unsigned int cpu, shift = (gic_irq(d) % 4) * 8;
 	u32 val, mask, bit;
+#endif /* !CONFIG_SHARED_GIC */
 
 	if (!force)
 		cpu = cpumask_any_and(mask_val, cpu_online_mask);
@@ -258,12 +265,26 @@
 	if (cpu >= NR_GIC_CPU_IF || cpu >= nr_cpu_ids)
 		return -EINVAL;
 
+#ifdef CONFIG_SHARED_GIC
+	raw_spin_lock(&irq_controller_lock);
+	val = readb_relaxed(reg);
+	for (i = 0; i < NR_GIC_CPU_IF; i++)
+		if (gic_cpu_map[i] == val)
+			break;
+	if (i >= NR_GIC_CPU_IF) {
+		raw_spin_unlock(&irq_controller_lock);
+		return -EINVAL;
+	}
+	writeb_relaxed(gic_cpu_map[cpu], reg);
+	raw_spin_unlock(&irq_controller_lock);
+#else /* !CONFIG_SHARED_GIC */
 	raw_spin_lock(&irq_controller_lock);
 	mask = 0xff << shift;
 	bit = gic_cpu_map[cpu] << shift;
 	val = readl_relaxed(reg) & ~mask;
 	writel_relaxed(val | bit, reg);
 	raw_spin_unlock(&irq_controller_lock);
+#endif /* !CONFIG_SHARED_GIC */
 
 	return IRQ_SET_MASK_OK;
 }
@@ -381,10 +402,15 @@
 static void __init gic_dist_init(struct gic_chip_data *gic)
 {
 	unsigned int i;
+#ifdef CONFIG_SHARED_GIC
+	u8 cpumask, target;
+#else /* !CONFIG_SHARED_GIC */
 	u32 cpumask;
+#endif /* !CONFIG_SHARED_GIC */
 	unsigned int gic_irqs = gic->gic_irqs;
 	void __iomem *base = gic_data_dist_base(gic);
 
+#ifndef CONFIG_SHARED_GIC
 	writel_relaxed(0, base + GIC_DIST_CTRL);
 
 	/*
@@ -392,11 +418,28 @@
 	 */
 	for (i = 32; i < gic_irqs; i += 16)
 		writel_relaxed(0, base + GIC_DIST_CONFIG + i * 4 / 16);
+#endif /* !CONFIG_SHARED_GIC */
 
 	/*
 	 * Set all global interrupts to this CPU only.
 	 */
 	cpumask = gic_get_cpumask(gic);
+#ifdef CONFIG_SHARED_GIC
+	for (i = 32; i < gic_irqs; i++) {
+		target = readb_relaxed(base + GIC_DIST_TARGET + i);
+
+		if (!(target & cpumask)) {
+			/* The cpu target is not set for Linux. */
+			continue;
+		}
+
+		/*
+		 * Disable all interrupts.  Leave the PPI and SGIs alone
+		 * as these enables are banked registers.
+		 */
+		writel_relaxed(1 << (i % 32), base + GIC_DIST_ENABLE_CLEAR + (i / 32) * 4);
+	}
+#else /* !CONFIG_SHARED_GIC */
 	cpumask |= cpumask << 8;
 	cpumask |= cpumask << 16;
 	for (i = 32; i < gic_irqs; i += 4)
@@ -416,6 +459,7 @@
 		writel_relaxed(0xffffffff, base + GIC_DIST_ENABLE_CLEAR + i * 4 / 32);
 
 	writel_relaxed(1, base + GIC_DIST_CTRL);
+#endif /* !CONFIG_SHARED_GIC */
 }
 
 static void gic_cpu_init(struct gic_chip_data *gic)
diff -uNr linux-3.14.19/drivers/mmc/core/mmc.c linux-gerda/drivers/mmc/core/mmc.c
--- linux-3.14.19/drivers/mmc/core/mmc.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mmc/core/mmc.c	2017-06-22 09:52:36.911039723 +0900
@@ -294,7 +294,7 @@
 	}
 
 	card->ext_csd.rev = ext_csd[EXT_CSD_REV];
-	if (card->ext_csd.rev > 7) {
+	if (card->ext_csd.rev > 8) {
 		pr_err("%s: unrecognised EXT_CSD revision %d\n",
 			mmc_hostname(card->host), card->ext_csd.rev);
 		err = -EINVAL;
diff -uNr linux-3.14.19/drivers/mmc/core/sdio.c linux-gerda/drivers/mmc/core/sdio.c
--- linux-3.14.19/drivers/mmc/core/sdio.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mmc/core/sdio.c	2017-06-22 09:52:36.911039723 +0900
@@ -1232,3 +1232,59 @@
 	return err;
 }
 
+int sdio_reset_comm(struct mmc_card *card)
+{
+	struct mmc_host *host = card->host;
+	u32 ocr;
+	int err;
+
+	printk("%s():\n", __func__);
+	mmc_go_idle(host);
+
+	mmc_set_clock(host, host->f_min);
+
+	err = mmc_send_io_op_cond(host, 0, &ocr);
+	if (err)
+		goto err;
+
+	host->ocr = mmc_select_voltage(host, ocr);
+	if (!host->ocr) {
+		err = -EINVAL;
+		goto err;
+	}
+
+	err = mmc_send_io_op_cond(host, host->ocr, &ocr);
+	if (err)
+		goto err;
+
+	if (mmc_host_is_spi(host)) {
+		err = mmc_spi_set_crc(host, use_spi_crc);
+		if (err)
+		goto err;
+	}
+
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_send_relative_addr(host, &card->rca);
+		if (err)
+			goto err;
+		mmc_set_bus_mode(host, MMC_BUSMODE_PUSHPULL);
+	}
+	if (!mmc_host_is_spi(host)) {
+		err = mmc_select_card(card);
+		if (err)
+			goto err;
+	}
+
+	mmc_set_clock(host, card->cis.max_dtr);
+	err = sdio_enable_wide(card);
+	if (err)
+		goto err;
+
+	return 0;
+ err:
+	printk("%s: Error resetting SDIO communications (%d)\n",
+	       mmc_hostname(host), err);
+	return err;
+}
+EXPORT_SYMBOL(sdio_reset_comm);
+
diff -uNr linux-3.14.19/drivers/mmc/host/Kconfig linux-gerda/drivers/mmc/host/Kconfig
--- linux-3.14.19/drivers/mmc/host/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mmc/host/Kconfig	2017-06-22 09:52:37.051039719 +0900
@@ -689,3 +689,46 @@
 	help
 	  Say Y here to include driver code to support SD/MMC card interface
 	  of Realtek PCI-E card reader
+
+config MMC_GERDAC
+	bool "Panasonic GerdaC MMC/SD/SDIO Host Controller support"
+	depends on MMC
+	help
+	  This selects support for the SD/SDIO/MMC controller on Panasonic GerdaC.
+
+config MMC_USE_SDIOSLOT
+	bool "Use SDIO Slot(SDIF-0)"
+	depends on MMC_GERDAC
+	default n
+	help
+	  This selects support for SDIO slot(SDIF-0).
+
+config MMC_USE_EMMCSLOT
+	bool "Use eMMC Slot(SDIF-1)"
+	depends on MMC_GERDAC
+	default y
+	help
+	  This selects support for eMMC slot(SDIF-1).
+
+config MMC_USE_SDSLOT
+	bool "Use SD Slot(SDIF-2) [DANGEROUS]"
+	depends on MMC_GERDAC
+	default n
+	help
+	  This selects support for SD slot(SDIF-2).
+
+config BTWIFI_15S_SETTING
+	bool "BT_EN/WL_EN for 1.5S borad."
+	depends on MMC_GERDAC
+	default n
+	help
+	  BT_EN/WL_EN GPIO setting is different between Gerda-C reference board and
+	  1.5S board. Enable this option will use the setting for 1.5S board.
+	  For 1S board, it is same to Gerda-C reference board, so do NOT enable this option.
+
+config MMC_GERDA3
+	bool "Panasonic Gerda3 MMC/SD/SDIO Host Controller support"
+	depends on MMC
+	help
+	  This selects support for the SD/SDIO/MMC controller on Panasonic Gerda3.
+
diff -uNr linux-3.14.19/drivers/mmc/host/Makefile linux-gerda/drivers/mmc/host/Makefile
--- linux-3.14.19/drivers/mmc/host/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mmc/host/Makefile	2017-06-22 09:52:37.047039719 +0900
@@ -68,3 +68,11 @@
 ifeq ($(CONFIG_CB710_DEBUG),y)
 	CFLAGS-cb710-mmc	+= -DDEBUG
 endif
+
+obj-$(CONFIG_MMC_GERDAC)	+= gerdac_mmc.o
+obj-$(CONFIG_MMC_GERDAC)	+= gerdac_mmc_dma.o
+obj-$(CONFIG_MMC_GERDAC)	+= gerdac_mmc_pio.o
+
+obj-$(CONFIG_MMC_GERDA3)	+= gerdac_mmc.o
+obj-$(CONFIG_MMC_GERDA3)	+= gerdac_mmc_dma.o
+obj-$(CONFIG_MMC_GERDA3)	+= gerdac_mmc_pio.o
diff -uNr linux-3.14.19/drivers/mmc/host/gerdac_mmc.c linux-gerda/drivers/mmc/host/gerdac_mmc.c
--- linux-3.14.19/drivers/mmc/host/gerdac_mmc.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/mmc/host/gerdac_mmc.c	2017-06-22 09:52:37.043039719 +0900
@@ -0,0 +1,513 @@
+/*
+ * linux/drivers/mmc/host/gerdac_mmc.c
+ *
+ * Copyright (C) 20XX-20XX XXX XXX, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/mfd/core.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/scatterlist.h>
+
+#include <linux/mmc/gerdac.h>
+#include <linux/mmc/host.h>
+
+#include "gerdac_mmc.h"
+
+#ifdef CONFIG_PM
+static int gerdac_mmc_suspend(struct platform_device *dev, pm_message_t state)
+{
+	int ret;
+	
+	ret = gerdac_mmc_host_suspend(&dev->dev);
+	
+	return ret;
+}
+
+static int gerdac_mmc_resume(struct platform_device *dev)
+{
+	int ret = 0;
+	
+	ret = gerdac_mmc_host_resume(&dev->dev);
+	
+	return ret;
+}
+#else
+#define gerdac_mmc_suspend NULL
+#define gerdac_mmc_resume NULL
+#endif
+
+static int gerdac_mmc_probe(struct platform_device *pdev)
+{
+	struct gerdac_mmc_data *pdata;
+	struct gerdac_mmc_host *host;
+	struct resource *res;
+	int ret = -EINVAL, irq;
+	
+	pdata = pdev->dev.platform_data;
+	if( !pdata || !pdata->hclk ){
+		pr_err(" ERROR:resource regist fail\n");
+		goto out;
+	}
+	
+	irq = platform_get_irq(pdev, 0);
+	if( irq < 0 ){
+		ret = irq;
+		pr_err(" ERROR:resource regist fail\n");
+		goto out;
+	}
+	
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if( !res ){
+		pr_err(" ERROR:resource regist fail\n");
+		return -EINVAL;
+	}
+	
+	/* SD control register space size is 0x200, 0x400 for bus_shift=1 */
+	pdata->bus_shift = resource_size(res) >> 10;
+
+	ret = gerdac_mmc_host_probe(&host, pdev, pdata);
+	if( ret ){
+		pr_err(" ERROR:resource regist fail\n");
+		goto out;
+	}
+	
+	ret = request_irq(irq, gerdac_mmc_irq, IRQF_TRIGGER_HIGH, dev_name(&pdev->dev), host);
+	if( ret ){
+		pr_err(" ERROR:resource regist fail\n");
+		goto host_remove;
+	}
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"\n");
+	
+	pr_info("MMC: %s at SDIF%d (irq %d, dma %s, hclk %dHz)\n", mmc_hostname(host->mmc), pdev->id, irq, pdata->use_dma?"enable":"disable", pdata->hclk);
+	
+	return 0;
+	
+host_remove:
+	gerdac_mmc_host_remove(host);
+	
+out:
+	return ret;
+}
+
+static int gerdac_mmc_remove(struct platform_device *pdev)
+{
+	struct mmc_host *mmc = platform_get_drvdata(pdev);
+	
+	if( mmc ){
+		struct gerdac_mmc_host *host = mmc_priv(mmc);
+		
+		free_irq(platform_get_irq(pdev, 0), host);
+		gerdac_mmc_host_remove(host);
+	}
+	
+	return 0;
+}
+
+/* ------------------- device registration ----------------------- */
+
+static struct platform_driver gerdac_mmc_driver = {
+	.driver = {
+		.name = "gerdac-mmc",
+		.owner = THIS_MODULE,
+	},
+	.probe = gerdac_mmc_probe,
+	.remove = gerdac_mmc_remove,
+	.suspend = gerdac_mmc_suspend,
+	.resume = gerdac_mmc_resume,
+};
+
+#define gic_spi(nr)		((nr) + 32)
+
+#ifdef	CONFIG_MMC_GERDAC
+//
+// for GerdaC
+//
+static const struct resource sdif0_resources[] __initconst = {
+     DEFINE_RES_MEM_NAMED( 0x9C006000, 0x410, "sdif0_sdip_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005000, 0x100, "sdif0_sdma_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005380, 0x040, "sdif0_sdma_reg_rx" ),
+     DEFINE_RES_MEM_NAMED( 0x9C0053C0, 0x040, "sdif0_sdma_reg_tx" ),
+     DEFINE_RES_IRQ_NAMED( gic_spi(122), "sdif0" ),
+};
+static const struct resource sdif1_resources[] __initconst = {
+     DEFINE_RES_MEM_NAMED( 0x9C007000, 0x410, "sdif1_sdip_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005000, 0x100, "sdif1_sdma_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005400, 0x040, "sdif1_sdma_reg_rx" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005440, 0x040, "sdif1_sdma_reg_tx" ),
+     DEFINE_RES_IRQ_NAMED( gic_spi(124), "sdif1" ),
+};
+static const struct resource sdif2_resources[] __initconst = {
+     DEFINE_RES_MEM_NAMED( 0x9C007800, 0x410, "sdif2_sdip_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005000, 0x100, "sdif2_sdma_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005480, 0x040, "sdif2_sdma_reg_rx" ),
+     DEFINE_RES_MEM_NAMED( 0x9C0054C0, 0x040, "sdif2_sdma_reg_tx" ),
+     DEFINE_RES_IRQ_NAMED( gic_spi(126), "sdif2" ),
+};
+static const struct resource *sdif_resources[3] = {
+     sdif0_resources,
+     sdif1_resources,
+     sdif2_resources,
+};
+#ifdef	CONFIG_MMC_USE_SDIOSLOT
+static struct gerdac_mmc_data  sdif0_platform_data = {
+	.hclk = 100000000,
+//	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED | MMC_CAP_SDIO_IRQ | MMC_CAP_UHS_SDR12 | MMC_CAP_UHS_SDR25 | MMC_CAP_UHS_SDR50,
+	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED,
+	.capabilities2 = 0,
+//	.flags = GERDAC_MMC_SDIO_IRQ | GERDAC_MMC_WRPROTECT_DISABLE,
+	.flags = GERDAC_MMC_WRPROTECT_DISABLE,
+	.bus_shift = 0,
+	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.use_dma = true,
+	.dev = NULL,
+	.set_pwr = NULL,		//š
+	.set_clk_div = NULL,	//š
+	.clk_enable = NULL,		//š
+	.clk_disable = NULL,	//š
+	.slave_id_rx = 10,
+	.slave_id_tx = 11,
+};
+#endif	/* CONFIG_MMC_USE_SDIOSLOT */
+#ifdef	CONFIG_MMC_USE_EMMCSLOT
+static struct gerdac_mmc_data  sdif1_platform_data = {
+	.hclk = 100000000,
+	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED | MMC_CAP_NONREMOVABLE | MMC_CAP_1_8V_DDR,
+//	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_8_BIT_DATA | MMC_CAP_MMC_HIGHSPEED | MMC_CAP_SD_HIGHSPEED | MMC_CAP_NONREMOVABLE,
+	.capabilities2 = 0,
+	.flags = GERDAC_MMC_WRPROTECT_DISABLE,
+	.bus_shift = 0,
+	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.use_dma = true,
+	.dev = NULL,
+	.set_pwr = NULL,		//š
+	.set_clk_div = NULL,	//š
+	.clk_enable = NULL,		//š
+	.clk_disable = NULL,	//š
+	.slave_id_rx = 12,
+	.slave_id_tx = 13,
+};
+#endif	/* CONFIG_MMC_USE_EMMCSLOT */
+#ifdef	CONFIG_MMC_USE_SDSLOT
+static struct gerdac_mmc_data  sdif2_platform_data = {
+	.hclk = 50000000,
+	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED ,
+	.capabilities2 = 0,
+	.flags = GERDAC_MMC_WRPROTECT_DISABLE,
+	.bus_shift = 0,
+	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.use_dma = false,
+	.dev = NULL,
+	.set_pwr = NULL,		//š
+	.set_clk_div = NULL,	//š
+	.clk_enable = NULL,		//š
+	.clk_disable = NULL,	//š
+	.slave_id_rx = 14,
+	.slave_id_tx = 15,
+};
+#endif	/* CONFIG_MMC_USE_SDSLOT */
+#else	/* CONFIG_MMC_GERDAC */
+//
+// for Gerda3
+//
+static const struct resource sdif0_resources[] __initconst = {
+     DEFINE_RES_MEM_NAMED( 0x9C006000, 0x410, "sdif0_sdip_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005000, 0x100, "sdif0_sdma_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005300, 0x040, "sdif0_sdma_reg_rx" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005340, 0x040, "sdif0_sdma_reg_tx" ),
+     DEFINE_RES_IRQ_NAMED( gic_spi(103), "sdif0" ),
+};
+static const struct resource sdif1_resources[] __initconst = {
+     DEFINE_RES_MEM_NAMED( 0x9C007000, 0x410, "sdif1_sdip_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005000, 0x100, "sdif1_sdma_reg" ),
+     DEFINE_RES_MEM_NAMED( 0x9C005380, 0x040, "sdif1_sdma_reg_rx" ),
+     DEFINE_RES_MEM_NAMED( 0x9C0053C0, 0x040, "sdif1_sdma_reg_tx" ),
+     DEFINE_RES_IRQ_NAMED( gic_spi(105), "sdif1" ),
+};
+static const struct resource *sdif_resources[2] = {
+     sdif0_resources,
+     sdif1_resources,
+};
+static struct gerdac_mmc_data  sdif0_platform_data = {
+	.hclk = 50000000,
+	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED,
+	.capabilities2 = 0,
+	.flags = GERDAC_MMC_WRPROTECT_DISABLE,
+	.bus_shift = 0,
+	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.dev = NULL,
+	.set_pwr = NULL,
+	.set_clk_div = NULL,
+	.clk_enable = NULL,
+	.clk_disable = NULL,
+	.slave_id_rx = 8,
+	.slave_id_tx = 9,
+};
+static struct gerdac_mmc_data  sdif1_platform_data = {
+	.hclk = 50000000,
+	.capabilities = MMC_CAP_4_BIT_DATA | MMC_CAP_SD_HIGHSPEED,
+	.capabilities2 = 0,
+	.flags = GERDAC_MMC_WRPROTECT_DISABLE,
+	.bus_shift = 0,
+	.ocr_mask = MMC_VDD_32_33 | MMC_VDD_33_34,
+	.dev = NULL,
+	.set_pwr = NULL,
+	.set_clk_div = NULL,
+	.clk_enable = NULL,
+	.clk_disable = NULL,
+	.slave_id_rx = 10,
+	.slave_id_tx = 11,
+};
+#endif	/* CONFIG_MC_GERDAC */
+
+
+
+void __init gerdac_system_initialize( void )
+{
+#ifdef	CONFIG_MMC_GERDAC
+//
+// for GerdaC
+//
+	
+	void __iomem		*vaddr_base;
+	volatile u32		utemp32;
+	
+	// eMMC_ONLY setting start
+	//
+	// “à•”ƒNƒƒbƒN‹Ÿ‹‹
+	vaddr_base = ioremap_nocache(0x9c011000, 0x100);
+		/* SDCLKCTRL */
+	*(volatile u32 *)(vaddr_base + 0x1C) = 0x00000005;	/* SD0:100MHz,SD1:100MHz,SD2:50MHz */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x1C);
+
+		/* CGCTRL2 */									/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 |= 0x00001000;								/* SD1:‹Ÿ‹‹ */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+		/* CGCTRL3 */									/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x14);
+	utemp32 |= 0x000000C0;								/* SD0:‹Ÿ‹‹,ƒXƒgƒŠ[ƒ€—p‹Ÿ‹‹ */
+	*(volatile u32 *)(vaddr_base + 0x14) = utemp32;
+	iounmap(vaddr_base);
+	
+	// ƒŠƒZƒbƒg‰ðœ
+	vaddr_base = ioremap_nocache(0x9C010000, 0x100);
+
+		/* RSTCTRL0 */									/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x00);
+	utemp32 |= 0x00000001;								/* ƒXƒgƒŠ[ƒ€—pƒŠƒZƒbƒg‰ðœ */
+	*(volatile u32 *)(vaddr_base + 0x00) = utemp32;
+
+		/* RSTCTRL14 */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x68);
+	utemp32 |= 0x00000001;								/* ƒƒ‚ƒŠ(ƒXƒgƒŠ[ƒ€)—pƒŠƒZƒbƒg‰ðœ */
+	*(volatile u32 *)(vaddr_base + 0x68) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x68);
+	iounmap(vaddr_base);
+	
+	// SDIP‚Ì‹N“®Ý’è
+	vaddr_base = ioremap_nocache(0x9C000000, 0x100);
+		/* IOBPERICLKSTOP(SD0/1/2:clksdip_st_i‘I‘ð,all’âŽ~) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 |= 0x02390339;								/* [25][21][20][19][16][09][08][05][04][03][00]=1 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+		/* IOBPERIRESET(SD0/1/2:ƒŠƒZƒbƒg) */			/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);
+	utemp32 |= 0x00000130;								/* [08][05][04]=1 */
+	*(volatile u32 *)(vaddr_base + 0x0C) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);
+		/* IOBPERICLKSTOP(SD0/1/2:ŒŸoclk‹Ÿ‹‹,ƒƒCƒ“ƒNƒƒbƒN‹Ÿ‹‹) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 &= 0xFFF6FFF6;								/* [19][16][03][00]=0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+		/* IOBPERICLKSTOP(SD0/1/2:clksdip_st_i‹Ÿ‹‹) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 &= 0xFFEFFFEF;								/* [20][04]=0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+		/* IOBPERICLKSTOP(SD0/1/2:clksdip_st_i’âŽ~) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 |= 0x00100010;								/* [20][04]=1 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+		/* IOBPERIRESET(SD0/1/2:ƒŠƒZƒbƒg‰ðœ) */		/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);
+	utemp32 &= 0xFFFFFECF;								/* [08][05][04]=0 */
+	*(volatile u32 *)(vaddr_base + 0x0C) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);
+		/* IOBPERICLKSTOP(SD0/1/2:clksdip_st_i‹Ÿ‹‹) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 &= 0xFFEFFFEF;								/* [20][04]=0 */
+
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+		/* IOBPERICLKSTOP(Žü•ÓIF:ƒƒCƒ“ƒNƒƒbƒN‹Ÿ‹‹) */	/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	utemp32 &= 0xFFFFFEFF;								/* [08]=0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	
+	// SDMAC‚Ì‹N“®Ý’è
+		/* IOBRESET(SDMAC:ƒŠƒZƒbƒg‰ðœ) */			/* š‘¼‚Æ”í‚é‰Â”\«‚ ‚è */
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x04);
+	utemp32 &= 0xFFFFFF7F;								/* [07]=0 */
+	*(volatile u32 *)(vaddr_base + 0x04) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x04);
+	iounmap(vaddr_base);
+	//
+	// eMMC_ONLY setting end
+	
+	// gpio setting
+#ifdef CONFIG_BTWIFI_15S_SETTING
+	vaddr_base = ioremap_nocache(0x9C016000, 0x100);
+	/* GPODATA4 (BT_EN GPIO 153 WL_EN: 128)*/
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x070);
+	utemp32 |= 0x02000001;
+	*(volatile u32 *)(vaddr_base + 0x070) = utemp32;
+#else
+#endif
+#else	/* CONFIG_MMC_GERDAC */
+//
+// for Gerda3
+//
+	void __iomem		*vaddr_base;
+	volatile u32		utemp32;
+	
+	/* GPIO */
+	vaddr_base = ioremap_nocache(0x9c016000, 0x100);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0xC0);	/* FSEL1 */
+	utemp32 |= 0xCC0000CC;							/* gpio0:SDIF1WP,gpio1:SDIF1CD,gpio6:SDIF1DAT2,gpio7:SDIF1DAT3 */
+	*(volatile u32 *)(vaddr_base + 0xC0) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0xC0);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0xC4);	/* FSEL2 */
+	utemp32 |= 0x0000CCCC;							/* gpio8:SDIF1CMD,gpio9:SDIF1CLK,gpio10:SDIF1DAT0,gpio11:SDIF1DAT1 */
+	*(volatile u32 *)(vaddr_base + 0xC4) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0xC4);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x00);	/* IECTRL1 */
+	utemp32 |= 0x00000DC3;							/* 0,1,6,7,8,10,11:IN or IO */
+	*(volatile u32 *)(vaddr_base + 0x00) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x00);
+	
+	iounmap(vaddr_base);
+	
+	/* all clock */
+	vaddr_base = ioremap_nocache(0x9c011000, 0x100);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x14);	/* CGCTRL3 */
+	utemp32 |= 0x000000C0;							/* sdsrcclk,srtmclk */
+	*(volatile u32 *)(vaddr_base + 0x14) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x14);
+	
+	iounmap(vaddr_base);
+	
+	/* all reset */
+	vaddr_base = ioremap_nocache(0x9c010000, 0x100);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x00);	/* RSTCTRL0 */
+	utemp32 |= 0x00000001;							/* strmnrst */
+	*(volatile u32 *)(vaddr_base + 0x00) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x00);
+	
+	iounmap(vaddr_base);
+	
+	/* blk clock/reset */
+	vaddr_base = ioremap_nocache(0x9c000000, 0x100);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x04);	/* IOBRESET SDMACƒŠƒZƒbƒg‰ðœ */
+	utemp32 &= 0xFFFFFF7F;							/* [7]0 */
+	*(volatile u32 *)(vaddr_base + 0x04) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x04);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);	/* IOBPERICLKSTOP SDIF•ŒŸo—pƒNƒƒbƒN‹Ÿ‹‹ */
+	utemp32 &= 0xFFF6FFF6;							/* [19]0,[16]0,[3]0,[0]0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);	/* IOBPERICLKSTOP ƒNƒƒbƒN‹Ÿ‹‹ */
+	utemp32 &= 0xFFEFFEEF;							/* [20]0,[8]0,[4]0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);	/* IOBPERICLKSTOP ƒNƒƒbƒN’âŽ~ */
+	utemp32 |= 0x00100110;							/* [20]1,[8]1,[4]1 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);	/* IOBPERIRESET Žü•ÓIOƒuƒƒbƒNƒŠƒZƒbƒg‰ðœ*/
+	utemp32 &= 0xFFFFFECF;							/* [8]0,[5]0,[4]0 */
+	*(volatile u32 *)(vaddr_base + 0x0C) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x0C);
+	
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);	/* IOBPERICLKSTOP ƒNƒƒbƒN‹Ÿ‹‹ */
+	utemp32 &= 0xFFEFFEEF;							/* [20]0,[8]0,[4]0 */
+	*(volatile u32 *)(vaddr_base + 0x10) = utemp32;
+	utemp32 = *(volatile u32 *)(vaddr_base + 0x10);
+	
+	iounmap(vaddr_base);
+#endif	/* CONFIG_MC_GERDAC */
+}
+void __init gerdac_add_sdif_device( struct gerdac_mmc_data *pdata, unsigned int index )
+{
+	struct platform_device_info info = {
+		.name = "gerdac-mmc",
+		.id = index,
+		.data = pdata,
+		.size_data = sizeof(*pdata),
+		.num_res = ARRAY_SIZE(sdif0_resources),
+	};
+	
+	if (index >= ARRAY_SIZE(sdif_resources))
+		return;
+	
+	info.res = sdif_resources[index];
+	
+	platform_device_register_full(&info);
+}
+
+module_platform_driver(gerdac_mmc_driver);
+
+static int __init	gerdac_mmc_init(void)
+{
+	/* sdmac/sdip/gpio */
+	gerdac_system_initialize();
+	
+	/* sdif */
+#ifdef	CONFIG_MMC_GERDAC
+#ifdef	CONFIG_MMC_USE_EMMCSLOT
+	gerdac_add_sdif_device(&sdif1_platform_data, 1);
+#endif	/* CONFIG_MMC_USE_EMMCSLOT */
+#ifdef	CONFIG_MMC_USE_SDIOSLOT
+	gerdac_add_sdif_device(&sdif0_platform_data, 0);
+#endif	/* CONFIG_MMC_USE_SDSLOT */
+#ifdef	CONFIG_MMC_USE_SDSLOT
+	gerdac_add_sdif_device(&sdif2_platform_data, 2);
+#endif	/* CONFIG_MMC_USE_SDSLOT */
+#else	/* CONFIG_MMC_GERDAC */
+//	gerdac_add_sdif_device(&sdif0_platform_data, 0);
+	gerdac_add_sdif_device(&sdif1_platform_data, 1);
+#endif	/* CONFIG_MMC_GERDAC */
+	
+	return 0;
+}
+static void __exit gerdac_mmc_exit(void)
+{
+}
+subsys_initcall(gerdac_mmc_init);
+module_exit(gerdac_mmc_exit);
+
+MODULE_DESCRIPTION("Panasonic Gerda-C SD/MMC driver");
+MODULE_AUTHOR("Xxxxxx <Yyyyy@zzzzz>");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:gerdac-mmc");
diff -uNr linux-3.14.19/drivers/mmc/host/gerdac_mmc.h linux-gerda/drivers/mmc/host/gerdac_mmc.h
--- linux-3.14.19/drivers/mmc/host/gerdac_mmc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/mmc/host/gerdac_mmc.h	2017-06-22 09:52:37.043039719 +0900
@@ -0,0 +1,341 @@
+/*
+ * linux/drivers/mmc/host/gerdac_mmc.h
+ *
+ * Copyright (C) 20XX-20XX XXX XXX, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef GERDAC_MMC_H
+#define GERDAC_MMC_H
+
+#include <linux/highmem.h>
+#include <linux/mmc/gerdac.h>
+#include <linux/mutex.h>
+#include <linux/pagemap.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+
+#include <asm/rt3.h>
+
+/* Definitions for values the CTRL_SDIO_STATUS register can take. */
+#define GERDAC_SDIO_STAT_IOIRQ		0x0001
+#define GERDAC_SDIO_STAT_EXPUB52	0x4000
+#define GERDAC_SDIO_STAT_EXWT		0x8000
+#define GERDAC_SDIO_MASK_ALL		0xc007
+
+/* Define some IRQ masks */
+/* This is the mask used at reset by the chip */
+#define GERDAC_MASK_ALL				0x837f031d
+#define GERDAC_MASK_READOP			(GERDAC_STAT_RXRDY | GERDAC_STAT_DATAEND)
+#define GERDAC_MASK_WRITEOP			(GERDAC_STAT_TXRQ | GERDAC_STAT_DATAEND)
+#define GERDAC_MASK_CMD				(GERDAC_STAT_CMDRESPEND | GERDAC_STAT_CMDTIMEOUT | \
+										GERDAC_STAT_CARD_REMOVE | GERDAC_STAT_CARD_INSERT)
+#define GERDAC_MASK_IRQ				(GERDAC_MASK_READOP | GERDAC_MASK_WRITEOP | GERDAC_MASK_CMD)
+
+struct gerdac_mmc_data;
+
+/*
+ * We differentiate between the following 3 power states:
+ * 1. card slot powered off, controller stopped. This is used, when either there
+ *    is no card in the slot, or the card really has to be powered down.
+ * 2. card slot powered on, controller stopped. This is used, when a card is in
+ *    the slot, but no activity is currently taking place. This is a power-
+ *    saving mode with card-state preserved. This state can be entered, e.g.
+ *    when MMC clock-gating is used.
+ * 3. card slot powered on, controller running. This is the actual active state.
+ */
+enum gerdac_mmc_power {
+	GERDAC_MMC_OFF_STOP,	/* card power off, controller stopped */
+	GERDAC_MMC_ON_STOP,		/* card power on, controller stopped */
+	GERDAC_MMC_ON_RUN,		/* card power on, controller running */
+};
+
+struct gerdac_mmc_host {
+	void __iomem			*ctl;
+	void __iomem			*sdma_ctl;
+	void __iomem			*sdma_rxctl;
+	void __iomem			*sdma_txctl;
+	struct mmc_command      *cmd;
+	struct mmc_request      *mrq;
+	struct mmc_data         *data;
+	struct mmc_host         *mmc;
+
+	/* Controller and card power state */
+	enum gerdac_mmc_power	power;
+
+	/* Callbacks for clock / power control */
+	void (*set_pwr)(struct platform_device *host, int state);
+	void (*set_clk_div)(struct platform_device *host, int state);
+
+	/* pio related stuff */
+	struct scatterlist      *sg_ptr;
+	struct scatterlist      *sg_orig;
+	unsigned int            sg_len;
+	unsigned int            sg_off;
+
+	struct platform_device *pdev;
+	struct gerdac_mmc_data *pdata;
+
+	/* DMA support */
+	bool					force_pio;
+
+	/* Track lost interrupts */
+	struct delayed_work		delayed_reset_work;
+	struct work_struct		done;
+
+	/* Cache IRQ mask */
+	u32						sdcard_irq_mask;
+	u32						sdio_irq_mask;
+
+	spinlock_t				lock;		/* protect host private data */
+	unsigned long			last_req_ts;
+	struct mutex			ios_lock;	/* protect set_ios() context */
+	bool					native_hotplug;
+	bool					resuming;
+};
+
+int gerdac_mmc_host_probe(struct gerdac_mmc_host **host,
+			struct platform_device *pdev,
+			struct gerdac_mmc_data *pdata);
+void gerdac_mmc_host_remove(struct gerdac_mmc_host *host);
+void gerdac_mmc_do_data_irq(struct gerdac_mmc_host *host);
+
+void gerdac_mmc_enable_mmc_irqs(struct gerdac_mmc_host *host, u32 i);
+void gerdac_mmc_disable_mmc_irqs(struct gerdac_mmc_host *host, u32 i);
+irqreturn_t gerdac_mmc_irq(int irq, void *devid);
+irqreturn_t gerdac_mmc_sdcard_irq(int irq, void *devid);
+irqreturn_t gerdac_mmc_card_detect_irq(int irq, void *devid);
+irqreturn_t gerdac_mmc_sdio_irq(int irq, void *devid);
+
+static inline char *gerdac_mmc_kmap_atomic(struct scatterlist *sg,
+					 unsigned long *flags)
+{
+	local_irq_save(*flags);
+	return kmap_atomic(sg_page(sg)) + sg->offset;
+}
+
+static inline void gerdac_mmc_kunmap_atomic(struct scatterlist *sg,
+					  unsigned long *flags, void *virt)
+{
+	kunmap_atomic(virt - sg->offset);
+	local_irq_restore(*flags);
+}
+
+void gerdac_mmc_start_dma(struct gerdac_mmc_host *host, struct mmc_data *data);
+void gerdac_mmc_enable_dma(struct gerdac_mmc_host *host, bool enable);
+void gerdac_mmc_abort_dma(struct gerdac_mmc_host *host);
+void gerdac_mmc_sdmac_kick( struct gerdac_mmc_host *host, u32 buf, u32 size, bool read );
+
+#ifdef CONFIG_PM
+int gerdac_mmc_host_suspend(struct device *dev);
+int gerdac_mmc_host_resume(struct device *dev);
+#else	/* CONFIG_PM */
+#define gerdac_mmc_host_suspend NULL
+#define gerdac_mmc_host_resume NULL
+#endif	/* CONFIG_PM */
+
+int gerdac_mmc_host_runtime_suspend(struct device *dev);
+int gerdac_mmc_host_runtime_resume(struct device *dev);
+
+//==============
+// for debug
+//==============
+//	select
+#define	GERDAC_MMC_LOG							// defined:on
+#define	GERDAC_MMC_LOG_SDIO_ON		1			// Slot0 1:on 0:off
+#define	GERDAC_MMC_LOG_EMMC_ON		1			// Slot1 1:on 0:off
+#define	GERDAC_MMC_LOG_SD_ON		1			// Slot2 1:on 0:off
+#define	GERDAC_MMC_LOG_LEVEL		KERN_INFO	// KERN_EMERG	:0
+												// KERN_ALERT	:1
+												// KERN_CRIT	:2
+												// KERN_ERR		:3
+												// KERN_WARNING	:4(default)
+												// KERN_NOTICE	:5
+												// KERN_INFO	:6
+												// KERN_DEBUG	:7
+#define	GERDAC_MMC_LOG_FUNCLINE		0			// 1:on 0:off
+
+//#define	GERDAC_MMC_USE_RTT					// Real Time Trace(user log)
+#define	GERDAC_MMC_MAX_REQ_SIZE		16			// * 4KB unit
+//==============
+#ifdef	GERDAC_MMC_LOG
+
+enum{
+	GERDAC_MMC_REG = 0,
+	GERDAC_MMC_DMA,
+	GERDAC_MMC_CMD,
+	GERDAC_MMC_SEQ,
+	GERDAC_MMC_ERR,
+	GERDAC_MMC_PER,
+};
+#define	gerdac_mmc_debug_log(host,type,fmt,...)																			\
+{																														\
+	u32	id = host->pdev->id;																							\
+	if( (id == 0 && GERDAC_MMC_LOG_SDIO_ON)																				\
+		|| (id == 1 && GERDAC_MMC_LOG_EMMC_ON)																			\
+			|| (id == 2 && GERDAC_MMC_LOG_SD_ON) ){																		\
+		switch( type ){																									\
+			case GERDAC_MMC_ERR:																						\
+					if( GERDAC_MMC_LOG_FUNCLINE ){																		\
+						printk(GERDAC_MMC_LOG_LEVEL"#sdif%d# %-32s:%4d: "fmt,id,__FUNCTION__,__LINE__,##__VA_ARGS__);	\
+					}else{																								\
+						printk(GERDAC_MMC_LOG_LEVEL"#sdif%d# : "fmt,id,##__VA_ARGS__);									\
+					}																									\
+				break;																									\
+				case GERDAC_MMC_DMA:																					\
+			case GERDAC_MMC_SEQ:																						\
+			case GERDAC_MMC_CMD:																						\
+				case GERDAC_MMC_PER:																					\
+			case GERDAC_MMC_REG:																						\
+			default:																									\
+				break;																									\
+		}																												\
+	}																													\
+}
+#define	gerdac_mmc_debug_regdump(host)																																		\
+{																																											\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"  == SDIP Register Dump ================================\n" );																		\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   CMD    =0x%08x, ARG    =0x%08x\n",sd_ctrl_read16(host,CTL_SD_CMD),sd_ctrl_read32(host,CTL_ARG_REG) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   STOP   =0x%08x, SECCNT =0x%08x\n",sd_ctrl_read16(host,CTL_STOP_INTERNAL_ACTION),sd_ctrl_read16(host,CTL_XFER_BLK_COUNT) );		\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   INFO1/2=0x%08x, MASK1/2=0x%08x\n",sd_ctrl_read32(host,CTL_STATUS),sd_ctrl_read32(host,CTL_IRQ_MASK) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   CLKCTRL=0x%08x, SIZE   =0x%08x\n",sd_ctrl_read16(host,CTL_SD_CARD_CLK_CTL),sd_ctrl_read16(host,CTL_SD_XFER_LEN) );				\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   OPTION =0x%08x, ERR1/2 =0x%08x\n",sd_ctrl_read16(host,CTL_SD_MEM_CARD_OPT),sd_ctrl_read32(host,CTL_SD_ERROR_DETAIL_STATUS) );	\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   IOMODE =0x%08x, IOINFO =0x%08x\n",sd_ctrl_read16(host,CTL_TRANSACTION_CTL),sd_ctrl_read16(host,CTL_SDIO_STATUS) );				\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   IOMASK =0x%08x, CC_EXT =0x%08x\n",sd_ctrl_read16(host,CTL_SDIO_IRQ_MASK),sd_ctrl_read16(host,CTL_DMA_ENABLE) );					\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   SFTRST =0x%08x, VERSION=0x%08x\n",sd_ctrl_read16(host,CTL_RESET_SD),sd_ctrl_read16(host,CTL_VERSION) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   HOST_MD=0x%08x, IF_MODE=0x%08x\n",sd_ctrl_read16(host,CTL_HOST_MODE),sd_ctrl_read16(host,CTL_SDIF_MODE) );						\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   UHS1_MD=0x%08x, MMC_MD =0x%08x\n",sd_ctrl_read16(host,CTL_UHS1MODE),sd_ctrl_read16(host,CTL_MMCMODE) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"  == SDMAC Register Dump ===============================\n" );																		\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx CTL1=0x%08x, Rx CTR1=0x%08x\n",sd_sdma_txctrl_read32(host, 0x00),sd_sdma_rxctrl_read32(host, 0x00) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx CTL2=0x%08x, Rx CTR2=0x%08x\n",sd_sdma_txctrl_read32(host, 0x04),sd_sdma_rxctrl_read32(host, 0x04) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx STAT=0x%08x, Rx STAT=0x%08x\n",sd_sdma_txctrl_read32(host, 0x10),sd_sdma_rxctrl_read32(host, 0x10) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx IR  =0x%08x, Rx IR  =0x%08x\n",sd_sdma_txctrl_read32(host, 0x14),sd_sdma_rxctrl_read32(host, 0x14) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx IE  =0x%08x, Rx IE  =0x%08x\n",sd_sdma_txctrl_read32(host, 0x18),sd_sdma_rxctrl_read32(host, 0x18) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx ID  =0x%08x, Rx ID  =0x%08x\n",sd_sdma_txctrl_read32(host, 0x1C),sd_sdma_rxctrl_read32(host, 0x1C) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx SRCM=0x%08x, Rx SRCM=0x%08x\n",sd_sdma_txctrl_read32(host, 0x20),sd_sdma_rxctrl_read32(host, 0x20) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx DSTM=0x%08x, Rx DSTM=0x%08x\n",sd_sdma_txctrl_read32(host, 0x24),sd_sdma_rxctrl_read32(host, 0x24) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx SRCA=0x%08x, Rx SRCA=0x%08x\n",sd_sdma_txctrl_read32(host, 0x28),sd_sdma_rxctrl_read32(host, 0x28) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx DSTA=0x%08x, Rx DSTA=0x%08x\n",sd_sdma_txctrl_read32(host, 0x2C),sd_sdma_rxctrl_read32(host, 0x2C) );							\
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"   Tx SIZE=0x%08x, Rx SIZE=0x%08x\n",sd_sdma_txctrl_read32(host, 0x30),sd_sdma_rxctrl_read32(host, 0x30) );							\
+}
+#else	/* GERDAC_MMC_LOG */
+#define	gerdac_mmc_debug_log(host,type,fmt,...)
+#define	gerdac_mmc_debug_regdump(host)
+#endif	/* GERDAC_MMC_LOG */
+//=======
+#ifdef	GERDAC_MMC_USE_RTT
+#define	gerdac_mmc_rtt_log(int)		\
+{									\
+	_TRC_usr_log(int);				\
+}
+#define	gerdac_mmc_rtt_log_start()	\
+{									\
+	_TRC_sta_log();					\
+}
+#define	gerdac_mmc_rtt_log_stop()	\
+{									\
+	_TRC_stp_log();					\
+}
+#else	/* GERDAC_MMC_USE_RTT */
+#define	gerdac_mmc_rtt_log(int)
+#define	gerdac_mmc_rtt_log_start()
+#define	gerdac_mmc_rtt_log_stop()
+#endif	/* GERDAC_MMC_USE_RTT */
+//=======
+static inline u16 sd_ctrl_read16(struct gerdac_mmc_host *host, int addr)
+{
+	u16 val;
+	
+	val = readw(host->ctl + (addr << host->pdata->bus_shift));
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG R]0x%04x,0x%04x\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)val);
+	
+	return val;
+}
+
+static inline void sd_ctrl_read16_rep(struct gerdac_mmc_host *host, int addr, u16 *buf, int count)
+{
+	readsw(host->ctl + (addr << host->pdata->bus_shift), buf, count);
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG R]0x%04x,0x%04x...\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)buf[0]);
+}
+
+static inline u32 sd_ctrl_read32(struct gerdac_mmc_host *host, int addr)
+{
+	u32 val;
+	
+	val = readw(host->ctl + (addr << host->pdata->bus_shift)) |
+			readw(host->ctl + ((addr + 2) << host->pdata->bus_shift)) << 16;
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG R]0x%04x,0x%08x\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)val);
+	
+	return val;
+}
+
+static inline void sd_ctrl_write16(struct gerdac_mmc_host *host, int addr, u16 val)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG W]0x%04x,0x%04x\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)val);
+	writew(val, host->ctl + (addr << host->pdata->bus_shift));
+}
+
+static inline void sd_ctrl_write16_rep(struct gerdac_mmc_host *host, int addr,
+		u16 *buf, int count)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG W]0x%04x,0x%04x...\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)buf[0]);
+	writesw(host->ctl + (addr << host->pdata->bus_shift), buf, count);
+}
+
+static inline void sd_ctrl_write32(struct gerdac_mmc_host *host, int addr, u32 val)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDIP    REG W]0x%04x,0x%08x\n", (unsigned int)(addr << host->pdata->bus_shift),(unsigned int)val);
+	writew(val, host->ctl + (addr << host->pdata->bus_shift));
+	writew(val >> 16, host->ctl + ((addr + 2) << host->pdata->bus_shift));
+}
+
+//=======
+static inline u32 sd_sdma_ctrl_read32(struct gerdac_mmc_host *host, int addr)
+{
+	u32 val;
+	
+	val = readl(host->sdma_ctl + addr);
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA    REG R]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	
+	return val;
+}
+static inline void sd_sdma_ctrl_write32(struct gerdac_mmc_host *host, int addr, u32 val)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA    REG W]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	writel(val, host->sdma_ctl + addr);
+}
+static inline u32 sd_sdma_rxctrl_read32(struct gerdac_mmc_host *host, int addr)
+{
+	u32 val;
+	
+	val = readl(host->sdma_rxctl + addr);
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA-RX REG R]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	
+	return val;
+}
+static inline void sd_sdma_rxctrl_write32(struct gerdac_mmc_host *host, int addr, u32 val)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA-RX REG W]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	writel(val, host->sdma_rxctl + addr);
+}
+static inline u32 sd_sdma_txctrl_read32(struct gerdac_mmc_host *host, int addr)
+{
+	u32 val;
+	
+	val = readl(host->sdma_txctl + addr);
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA-TX REG R]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	
+	return val;
+}
+static inline void sd_sdma_txctrl_write32(struct gerdac_mmc_host *host, int addr, u32 val)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_REG,"  [SDMA-TX REG W]0x%04x,0x%08x\n", (unsigned int)(addr),(unsigned int)val);
+	writel(val, host->sdma_txctl + addr);
+}
+//=======
+
+#endif	/* GERDAC_MMC_H */
diff -uNr linux-3.14.19/drivers/mmc/host/gerdac_mmc_dma.c linux-gerda/drivers/mmc/host/gerdac_mmc_dma.c
--- linux-3.14.19/drivers/mmc/host/gerdac_mmc_dma.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/mmc/host/gerdac_mmc_dma.c	2017-06-22 09:52:37.047039719 +0900
@@ -0,0 +1,181 @@
+/*
+ * linux/drivers/mmc/host/gerdac_mmc_dma.c
+ *
+ * Copyright (C) 20XX-20XX XXX XXX, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/gerdac.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/scatterlist.h>
+
+#include "gerdac_mmc.h"
+
+#define GERDAC_MMC_MIN_DMA_LEN		8
+
+void gerdac_mmc_enable_dma(struct gerdac_mmc_host *host, bool enable)
+{
+//šDMA‹–‰Â
+}
+
+void gerdac_mmc_abort_dma(struct gerdac_mmc_host *host)
+{
+	gerdac_mmc_enable_dma(host, false);
+	
+//šDMA‹­§’âŽ~
+	
+	gerdac_mmc_enable_dma(host, true);
+}
+
+static void gerdac_mmc_sdmac_init( struct gerdac_mmc_host *host )
+{
+	// DMAC‘S‘ÌÝ’è(ƒŒ[ƒg§Œä):CDGSD_PERFCNFG
+	sd_sdma_ctrl_write32(host, 0x08, sd_sdma_ctrl_read32(host, 0x08) & ~0x00010000);
+	// ŠeŽíŽ‘Œ¹‚Ìƒpƒ‰ƒ[ƒ^Ý’è(ƒŒ[ƒg§ŒäŠÖ˜A)
+	;
+	// ŠeŽíŽ‘Œ¹‚Ìƒpƒ‰ƒ[ƒ^Ý’è(ƒŠƒ“ƒOƒoƒbƒtƒ@ŠÖ˜A)
+	;
+}
+
+void gerdac_mmc_sdmac_kick( struct gerdac_mmc_host *host, u32 buf, u32 size, bool read )
+{
+	u16	id;
+	
+	if( read ){
+		id = host->pdata->slave_id_rx;
+		// ƒ`ƒƒƒlƒ‹ó‘ÔŠm”F			:CDGSD_CHnSTAT.bit4
+		if( sd_sdma_rxctrl_read32(host, 0x10) & 0x00000010 ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR," ----------------->DMA Rx kick over!!\n");
+//			return -EINVAL;
+		}
+		
+		// ƒ`ƒƒƒlƒ‹§Œä				:CDGSD_CHnCTRL1 and CDGSD_CHnCTRL2
+//		sd_sdma_rxctrl_write32(host, 0x00, 0x00000080);	/* default */
+//		sd_sdma_rxctrl_write32(host, 0x04, 0x00000006);	/* default(—Dæ“xƒŒƒxƒ‹6’á) */
+		
+		// ƒAƒhƒŒƒbƒVƒ“ƒOƒ‚[ƒhÝ’è	:CDGSD_CHnSRCAMODE and CDGSD_CHnDSTAMODE
+		sd_sdma_rxctrl_write32(host, 0x20, 0x00000020);
+//		sd_sdma_rxctrl_write32(host, 0x20, 0x70000020);	/* TUNIT=64byte */
+		sd_sdma_rxctrl_write32(host, 0x24, 0x00000000);
+		
+		// ŠJŽnƒAƒhƒŒƒXÝ’è			:CDGSD_CHnSRCSTRTADRS and CDGSD_CHnDSTSTRTADRS
+		sd_sdma_rxctrl_write32(host, 0x28, 0x00000000);		/* src */
+		sd_sdma_rxctrl_write32(host, 0x2C, (u32)buf);		/* dst */
+		
+		// “]‘—ƒTƒCƒYÝ’è			:CDGSD_CHnSIZE
+		sd_sdma_rxctrl_write32(host, 0x30, size);
+		
+		// Š„ž‚Ý—vˆöƒNƒŠƒA			:CDGSD_CHnIR
+		sd_sdma_rxctrl_write32(host, 0x14, sd_sdma_rxctrl_read32(host, 0x14));
+		
+		// Š„ž‚Ý‹–‰Â				:CDGSD_CHnIE
+		sd_sdma_rxctrl_write32(host, 0x18, 0x00022012);
+	
+	}else{
+		id = host->pdata->slave_id_tx;
+		// ƒ`ƒƒƒlƒ‹ó‘ÔŠm”F			:CDGSD_CHnSTAT.bit4
+		if( sd_sdma_txctrl_read32(host, 0x10) & 0x00000010 ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR," ----------------->DMA Tx kick over!!\n");
+//			return -EINVAL;
+		}
+		
+		// ƒ`ƒƒƒlƒ‹§Œä				:CDGSD_CHnCTRL1 and CDGSD_CHnCTRL2
+//		sd_sdma_txctrl_write32(host, 0x00, 0x00000080);	/* default */
+//		sd_sdma_txctrl_write32(host, 0x04, 0x00000006);	/* default(—Dæ“xƒŒƒxƒ‹6’á) */
+		
+		// ƒAƒhƒŒƒbƒVƒ“ƒOƒ‚[ƒhÝ’è	:CDGSD_CHnSRCAMODE and CDGSD_CHnDSTAMODE
+		sd_sdma_txctrl_write32(host, 0x20, 0x00000000);
+		sd_sdma_txctrl_write32(host, 0x24, 0x00000020);
+//		sd_sdma_txctrl_write32(host, 0x24, 0x70000020);	/* TUNIT=64byte */
+		
+		// ŠJŽnƒAƒhƒŒƒXÝ’è			:CDGSD_CHnSRCSTRTADRS and CDGSD_CHnDSTSTRTADRS
+		sd_sdma_txctrl_write32(host, 0x28, (u32)buf);		/* src */
+		sd_sdma_txctrl_write32(host, 0x2C, 0x00000000);		/* dst */
+		
+		// “]‘—ƒTƒCƒYÝ’è			:CDGSD_CHnSIZE
+		sd_sdma_txctrl_write32(host, 0x30, size);
+		
+		// Š„ž‚Ý—vˆöƒNƒŠƒA			:CDGSD_CHnIR
+		sd_sdma_txctrl_write32(host, 0x14, sd_sdma_txctrl_read32(host, 0x14));
+		
+		// Š„ž‚Ý‹–‰Â				:CDGSD_CHnIE
+		sd_sdma_txctrl_write32(host, 0x18, 0x00022012);
+	}
+	
+#if 0
+	gerdac_mmc_debug_regdump( host );
+#endif
+	
+	// “]‘——v‹
+	gerdac_mmc_rtt_log(2);
+	sd_sdma_ctrl_write32(host, 0x00, (1 << id));
+}
+
+void gerdac_mmc_start_dma(struct gerdac_mmc_host *host, struct mmc_data *data)
+{
+	struct scatterlist *sg = host->sg_ptr;
+	
+	if( host->pdata->use_dma ){
+	host->force_pio = false;
+	}else{
+		host->force_pio = true;
+	}
+	
+	gerdac_mmc_disable_mmc_irqs(host, GERDAC_STAT_TXRQ|GERDAC_STAT_RXRDY);
+	
+	if( (host->sg_len > 1) || (sg->length > (GERDAC_MMC_MAX_REQ_SIZE*PAGE_CACHE_SIZE)) ){
+		host->force_pio = true;
+	}
+	
+	if( sg->length < GERDAC_MMC_MIN_DMA_LEN ){
+		host->force_pio = true;
+	}
+	
+	if ( !host->force_pio ){
+		if( data->flags & MMC_DATA_READ ){
+			dma_map_sg(&host->pdev->dev, sg, host->sg_len, DMA_FROM_DEVICE);
+		}else{
+			dma_map_sg(&host->pdev->dev, sg, host->sg_len, DMA_TO_DEVICE);
+		}
+		if( (host->sg_ptr->dma_address + host->sg_off) & 0x1FF ){	// 128byte alignment check
+			host->force_pio = true;
+			if( data->flags & MMC_DATA_READ ){
+				dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->sg_len, DMA_FROM_DEVICE);
+			}else{
+				dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->sg_len, DMA_TO_DEVICE);
+			}
+		}
+	}
+	
+	if ( host->force_pio ){
+		/* PIO */
+//		gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," PIO start\n");
+		sd_ctrl_write16(host, CTL_DMA_ENABLE, sd_ctrl_read16(host, CTL_DMA_ENABLE) & ~0x0020);	/* CC_EXT_MODE.SDRWEN clr */
+		sd_ctrl_write16(host, CTL_DMA_ENABLE, sd_ctrl_read16(host, CTL_DMA_ENABLE) & ~0x0002);	/* CC_EXT_MODE.DMASDRW clr */
+		sd_ctrl_write16(host, CTL_HOST_MODE, sd_ctrl_read16(host, CTL_HOST_MODE) | 0x0001);		/* HOST_MODE.WMODE set */
+	}else{
+		/* DMA */
+//		gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," DMA start\n");
+		sd_ctrl_write16(host, CTL_DMA_ENABLE, sd_ctrl_read16(host, CTL_DMA_ENABLE) & ~0x0020);	/* CC_EXT_MODE.SDRWEN clr */
+		sd_ctrl_write16(host, CTL_DMA_ENABLE, sd_ctrl_read16(host, CTL_DMA_ENABLE) | 0x0002);	/* CC_EXT_MODE.DMASDRW set */
+		sd_ctrl_write16(host, CTL_HOST_MODE, sd_ctrl_read16(host, CTL_HOST_MODE) & ~0x0001);	/* HOST_MODE.WMODE clr */
+		
+		
+		gerdac_mmc_sdmac_init(host);
+		
+		if( data->flags & MMC_DATA_READ ){
+			gerdac_mmc_sdmac_kick(host, (u32)host->sg_ptr->dma_address + host->sg_off, host->sg_ptr->length, true);
+		}else{
+			gerdac_mmc_sdmac_kick(host, (u32)host->sg_ptr->dma_address + host->sg_off, host->sg_ptr->length, false);
+		}
+	}
+}
diff -uNr linux-3.14.19/drivers/mmc/host/gerdac_mmc_pio.c linux-gerda/drivers/mmc/host/gerdac_mmc_pio.c
--- linux-3.14.19/drivers/mmc/host/gerdac_mmc_pio.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/mmc/host/gerdac_mmc_pio.c	2017-06-22 09:52:37.051039719 +0900
@@ -0,0 +1,1239 @@
+/*
+ * linux/drivers/mmc/host/gerdac_mmc_pio.c
+ *
+ * Copyright (C) 20XX-20XX XXX XXX, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/highmem.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/mmc.h>
+#include <linux/mmc/slot-gpio.h>
+#include <linux/mmc/gerdac.h>
+#include <linux/module.h>
+#include <linux/pagemap.h>
+#include <linux/platform_device.h>
+#include <linux/pm_qos.h>
+#include <linux/pm_runtime.h>
+#include <linux/regulator/consumer.h>
+#include <linux/scatterlist.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+
+#include "gerdac_mmc.h"
+
+void gerdac_mmc_enable_mmc_irqs(struct gerdac_mmc_host *host, u32 i)
+{
+	host->sdcard_irq_mask &= ~(i & GERDAC_MASK_IRQ);
+	sd_ctrl_write32(host, CTL_IRQ_MASK, host->sdcard_irq_mask);
+}
+
+void gerdac_mmc_disable_mmc_irqs(struct gerdac_mmc_host *host, u32 i)
+{
+	host->sdcard_irq_mask |= (i & GERDAC_MASK_IRQ);
+	sd_ctrl_write32(host, CTL_IRQ_MASK, host->sdcard_irq_mask);
+}
+
+static void gerdac_mmc_ack_mmc_irqs(struct gerdac_mmc_host *host, u32 i)
+{
+	sd_ctrl_write32(host, CTL_STATUS, ~i);
+}
+
+static void gerdac_mmc_init_sg(struct gerdac_mmc_host *host, struct mmc_data *data)
+{
+	host->sg_len = data->sg_len;
+	host->sg_ptr = data->sg;
+	host->sg_orig = data->sg;
+	host->sg_off = 0;
+}
+
+static int gerdac_mmc_next_sg(struct gerdac_mmc_host *host)
+{
+	host->sg_ptr = sg_next(host->sg_ptr);
+	host->sg_off = 0;
+	
+	return --host->sg_len;
+}
+
+static void gerdac_mmc_enable_sdio_irq(struct mmc_host *mmc, int enable)
+{
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	if( enable ){
+		host->sdio_irq_mask = GERDAC_SDIO_MASK_ALL & ~GERDAC_SDIO_STAT_IOIRQ;
+		sd_ctrl_write16(host, CTL_TRANSACTION_CTL, 0x0001);
+		sd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);
+	}else{
+		host->sdio_irq_mask = GERDAC_SDIO_MASK_ALL;
+		sd_ctrl_write16(host, CTL_SDIO_IRQ_MASK, host->sdio_irq_mask);
+		sd_ctrl_write16(host, CTL_TRANSACTION_CTL, 0x0000);
+	}
+}
+
+static void gerdac_mmc_set_clock(struct gerdac_mmc_host *host, int new_clock)
+{
+	u32 clk = 0, clock;
+	
+	if( new_clock ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"new_clock=%d\n",new_clock);
+		for( clock = host->mmc->f_min, clk = 0x80000080; new_clock >= (clock<<1); clk >>= 1 ){
+			clock <<= 1;
+		}
+//		clk |= 0x100;
+	}
+	
+	if( (clk>>22) & 1 ){
+		clk |= 0x0400;
+	}else{
+		;
+	}
+	
+	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, clk & 0x7ff);
+	
+	msleep(10);
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"new_clock(REG)=0x%04x\n",sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+}
+
+static void gerdac_mmc_clk_stop(struct gerdac_mmc_host *host)
+{
+	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, ~0x0100 & sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+	
+	msleep(10);
+}
+
+static void gerdac_mmc_clk_start(struct gerdac_mmc_host *host)
+{
+	sd_ctrl_write16(host, CTL_SD_CARD_CLK_CTL, 0x0100 | sd_ctrl_read16(host, CTL_SD_CARD_CLK_CTL));
+	
+	msleep(10);
+}
+
+static void gerdac_mmc_reset(struct gerdac_mmc_host *host)
+{
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+
+	sd_ctrl_write16(host, CTL_RESET_SD, 0x0000);
+	msleep(10);
+	
+	sd_ctrl_write16(host, CTL_RESET_SD, 0x0001);
+	msleep(10);
+}
+
+static void gerdac_mmc_reset_work(struct work_struct *work)
+{
+	struct gerdac_mmc_host *host = container_of(work, struct gerdac_mmc_host, delayed_reset_work.work);
+	struct mmc_request *mrq;
+	unsigned long flags;
+	
+	spin_lock_irqsave(&host->lock, flags);
+	mrq = host->mrq;
+	
+	/*
+	 * is request already finished? Since we use a non-blocking
+	 * cancel_delayed_work(), it can happen, that a .set_ios() call preempts
+	 * us, so, have to check for IS_ERR(host->mrq)
+	 */
+	if( IS_ERR_OR_NULL(mrq) || time_is_after_jiffies(host->last_req_ts + msecs_to_jiffies(2000)) ){
+//	if( IS_ERR_OR_NULL(mrq) || time_is_after_jiffies(host->last_req_ts + msecs_to_jiffies(5000)) ){
+		spin_unlock_irqrestore(&host->lock, flags);
+		return;
+	}
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"timeout waiting for hardware interrupt (CMD%u)\n",mrq->cmd->opcode);
+	gerdac_mmc_debug_regdump( host );
+#if 1
+pr_err(" ****** %s : timeout ******\n", mmc_hostname(host->mmc));
+//while(1);
+#endif
+	
+	if( host->data ){
+		host->data->error = -ETIMEDOUT;
+	}else if( host->cmd ){
+		host->cmd->error = -ETIMEDOUT;
+	}else{
+		mrq->cmd->error = -ETIMEDOUT;
+	}
+	
+	host->cmd = NULL;
+	host->data = NULL;
+	host->force_pio = false;
+	
+	spin_unlock_irqrestore(&host->lock, flags);
+	
+	gerdac_mmc_reset(host);
+	
+	/* Ready for new calls */
+	host->mrq = NULL;
+	
+	gerdac_mmc_abort_dma(host);
+	mmc_request_done(host->mmc, mrq);
+}
+
+/* called with host->lock held, interrupts disabled */
+static void gerdac_mmc_finish_request(struct gerdac_mmc_host *host)
+{
+	struct mmc_request *mrq;
+	unsigned long flags;
+	
+//	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," done(CMD%u)\n",host->mrq->cmd->opcode);
+	
+	spin_lock_irqsave(&host->lock, flags);
+	
+	mrq = host->mrq;
+	
+	if( IS_ERR_OR_NULL(mrq) ){
+		spin_unlock_irqrestore(&host->lock, flags);
+		return;
+	}
+	
+	host->cmd = NULL;
+	host->data = NULL;
+	host->force_pio = false;
+	
+	cancel_delayed_work(&host->delayed_reset_work);
+	
+	host->mrq = NULL;
+	spin_unlock_irqrestore(&host->lock, flags);
+	
+	if( mrq->cmd->error || (mrq->data && mrq->data->error) ){
+		gerdac_mmc_abort_dma(host);
+	}
+	
+	if( mrq->data ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_PER,"     >>> done\n");
+	}
+	gerdac_mmc_rtt_log(7);
+	
+	mmc_request_done(host->mmc, mrq);
+}
+
+static void gerdac_mmc_done_work(struct work_struct *work)
+{
+	struct gerdac_mmc_host *host = container_of(work, struct gerdac_mmc_host, done);
+	
+	gerdac_mmc_finish_request(host);
+}
+
+//šƒRƒƒ“ƒg’ˆÓII
+/* These are the bitmasks the tmio chip requires to implement the MMC response
+ * types. Note that R1 and R6 are the same in this scheme. */
+#define APP_CMD        0x0040
+#define RESP_NONE      0x0300
+#define RESP_R1        0x0400
+#define RESP_R1B       0x0500
+#define RESP_R2        0x0600
+#define RESP_R3        0x0700
+#define DATA_PRESENT   0x0800
+#define TRANSFER_READ  0x1000
+#define TRANSFER_MULTI 0x2000
+#define SECURITY_CMD   0x4000
+
+static int gerdac_mmc_start_command(struct gerdac_mmc_host *host, struct mmc_command *cmd)
+{
+	struct mmc_data *data = host->data;
+	int c = cmd->opcode;
+	u32 irq_mask = GERDAC_MASK_CMD;
+	
+	if( !data ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_CMD,"<<CMD%02u ARG %08x                                        >>\n",cmd->opcode, cmd->arg);
+	}else{
+		gerdac_mmc_debug_log(host,GERDAC_MMC_CMD,"<<CMD%02u ARG %08x LEN %08x                           >>\n",cmd->opcode, cmd->arg, data->blocks*data->blksz);
+	}
+	
+	/* CMD12 is handled by hardware */
+	if( cmd->opcode == MMC_STOP_TRANSMISSION && !cmd->arg ){
+		sd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, 0x001);
+		return 0;
+	}
+	
+	switch( mmc_resp_type(cmd) ){
+		case MMC_RSP_NONE:	c |= RESP_NONE;	break;
+		case MMC_RSP_R1:	c |= RESP_R1;	break;
+		case MMC_RSP_R1B:	c |= RESP_R1B;	break;
+		case MMC_RSP_R2:	c |= RESP_R2;	break;
+		case MMC_RSP_R3:	c |= RESP_R3;	break;
+		default:
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"Unknown response type 0x%04x(flag=0x%04x)\n",mmc_resp_type(cmd),cmd->flags);
+//			return -EINVAL;		š
+	}
+	
+	host->cmd = cmd;
+	
+	if( cmd->opcode == 53 ){
+		c |= SECURITY_CMD;
+	}
+	if( data ){
+		c |= DATA_PRESENT;
+		if( data->blocks > 1 ){
+			sd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, 0x100);
+			c |= TRANSFER_MULTI;
+		}
+		if( data->flags & MMC_DATA_READ ){
+			c |= TRANSFER_READ;
+		}
+	}
+	
+	if( !host->native_hotplug ){
+		irq_mask &= ~(GERDAC_STAT_CARD_REMOVE | GERDAC_STAT_CARD_INSERT);
+	}
+	gerdac_mmc_enable_mmc_irqs(host, irq_mask);
+	
+	/* Fire off the command */
+	sd_ctrl_write32(host, CTL_ARG_REG, cmd->arg);
+	sd_ctrl_write16(host, CTL_SD_CMD, c);
+	gerdac_mmc_rtt_log(3);
+	
+	return 0;
+}
+
+//šƒRƒƒ“ƒg’ˆÓ
+/*
+ * This chip always returns (at least?) as much data as you ask for.
+ * I'm unsure what happens if you ask for less than a block. This should be
+ * looked into to ensure that a funny length read doesn't hose the controller.
+ */
+static void gerdac_mmc_pio_irq(struct gerdac_mmc_host *host)
+{
+	struct mmc_data *data = host->data;
+	void *sg_virt;
+	unsigned short *buf;
+	unsigned int count;
+	unsigned long flags;
+	
+	if( !host->force_pio ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"PIO IRQ in DMA mode!\n");
+		return;
+	}else if( !data ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"Spurious PIO IRQ\n");
+		return;
+	}
+	
+	sg_virt = gerdac_mmc_kmap_atomic(host->sg_ptr, &flags);
+	buf = (unsigned short *)(sg_virt + host->sg_off);
+	
+	count = host->sg_ptr->length - host->sg_off;
+	if( count > data->blksz ){
+		count = data->blksz;
+	}
+	
+//	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"count: %08x offset: %08x flags %08x\n",count, host->sg_off, data->flags);
+	
+	/* Transfer the data */
+	if( data->flags & MMC_DATA_READ ){
+		sd_ctrl_read16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+		if( host->sg_off == 0 ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_DMA," Rx(PIO) >>> cmd=%2d,arg=0x%08x(%s F%x A:%05x),blk=0x%04x,cnt=0x%04x,buf=----------,dat=%04x %04x %04x %04x  %04x %04x %04x %04x\n", host->mrq->cmd->opcode, host->mrq->cmd->arg, ((host->mrq->cmd->arg & 0x80000000)?"W":"R"),((host->mrq->cmd->arg)>>28)&0x7, ((host->mrq->cmd->arg)>>9)&0x1ffff ,data->blksz, data->blocks, buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7] );
+		}
+	}else{
+		sd_ctrl_write16_rep(host, CTL_SD_DATA_PORT, buf, count >> 1);
+		if( host->sg_off == 0 ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_DMA," Tx(PIO) >>> cmd=%2d,arg=0x%08x(%s F%x A:%05x),blk=0x%04x,cnt=0x%04x,buf=----------,dat=%04x %04x %04x %04x  %04x %04x %04x %04x\n", host->mrq->cmd->opcode, host->mrq->cmd->arg, ((host->mrq->cmd->arg & 0x80000000)?"W":"R"),((host->mrq->cmd->arg)>>28)&0x7, ((host->mrq->cmd->arg)>>9)&0x1ffff ,data->blksz, data->blocks, buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7] );
+		}
+	}
+	
+	host->sg_off += count;
+	
+	gerdac_mmc_kunmap_atomic(host->sg_ptr, &flags, sg_virt);
+	
+	if( host->sg_off == host->sg_ptr->length ){
+		gerdac_mmc_next_sg(host);
+	}
+	
+	return;
+}
+
+/* needs to be called with host->lock held */
+void gerdac_mmc_do_data_irq(struct gerdac_mmc_host *host)
+{
+	struct mmc_data *data = host->data;
+	struct mmc_command *stop;
+	
+	host->data = NULL;
+	
+	if( !data ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"Spurious data end IRQ\n");
+		return;
+	}
+	stop = data->stop;
+	
+	if( !host->force_pio ){
+		unsigned long flags;
+		void *sg_virt;
+		unsigned short *buf;
+		sg_virt = gerdac_mmc_kmap_atomic(host->sg_ptr, &flags);
+		buf = (unsigned short *)(sg_virt + host->sg_off);
+		if( data->flags & MMC_DATA_READ ){
+			while( (sd_sdma_rxctrl_read32(host, 0x14) & 0x00000002) == 0 );
+			gerdac_mmc_debug_log(host,GERDAC_MMC_DMA," Rx(DMA) >>> cmd=%2d,arg=0x%08x(%s F%x A:%05x),blk=0x%04x,cnt=0x%04x,buf=0x%08x,dat=%04x %04x %04x %04x  %04x %04x %04x %04x\n", host->mrq->cmd->opcode, host->mrq->cmd->arg, ((host->mrq->cmd->arg & 0x80000000)?"W":"R"),((host->mrq->cmd->arg)>>28)&0x7, ((host->mrq->cmd->arg)>>9)&0x1ffff ,data->blksz, data->blocks, host->sg_ptr->dma_address,buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7] );
+			dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->sg_len, DMA_FROM_DEVICE);
+		}else{
+			while( (sd_sdma_txctrl_read32(host, 0x14) & 0x00000002) == 0 );
+			gerdac_mmc_debug_log(host,GERDAC_MMC_DMA," Tx(DMA) >>> cmd=%2d,arg=0x%08x(%s F%x A:%05x),blk=0x%04x,cnt=0x%04x,buf=0x%08x,dat=%04x %04x %04x %04x  %04x %04x %04x %04x\n", host->mrq->cmd->opcode, host->mrq->cmd->arg, ((host->mrq->cmd->arg & 0x80000000)?"W":"R"),((host->mrq->cmd->arg)>>28)&0x7, ((host->mrq->cmd->arg)>>9)&0x1ffff ,data->blksz, data->blocks, host->sg_ptr->dma_address,buf[0],buf[1],buf[2],buf[3],buf[4],buf[5],buf[6],buf[7] );
+			dma_unmap_sg(&host->pdev->dev, host->sg_ptr, host->sg_len, DMA_TO_DEVICE);
+		}
+		gerdac_mmc_kunmap_atomic(host->sg_ptr, &flags, sg_virt);
+//
+	}
+	
+	/* FIXME - return correct transfer count on errors */
+	if( !data->error ){
+		data->bytes_xfered = data->blocks * data->blksz;
+	}else{
+		data->bytes_xfered = 0;
+	}
+	
+//šƒRƒƒ“ƒg’ˆÓ
+	/*
+	 * FIXME: other drivers allow an optional stop command of any given type
+	 *        which we dont do, as the chip can auto generate them.
+	 *        Perhaps we can be smarter about when to use auto CMD12 and
+	 *        only issue the auto request when we know this is the desired
+	 *        stop command, allowing fallback to the stop command the
+	 *        upper layers expect. For now, we do what works.
+	 */
+	
+	if( stop ){
+		if( stop->opcode == MMC_STOP_TRANSMISSION && !stop->arg ){
+			sd_ctrl_write16(host, CTL_STOP_INTERNAL_ACTION, 0x000);
+		}else{
+			BUG();
+		}
+	}
+	
+	schedule_work(&host->done);
+}
+
+static void gerdac_mmc_data_irq(struct gerdac_mmc_host *host)
+{
+	struct mmc_data *data;
+	
+	spin_lock(&host->lock);
+	
+	data = host->data;
+	if( !data ){
+		goto out;
+	}
+	
+	gerdac_mmc_do_data_irq(host);
+	gerdac_mmc_disable_mmc_irqs(host, GERDAC_MASK_READOP | GERDAC_MASK_WRITEOP);
+	
+out:
+	spin_unlock(&host->lock);
+}
+
+static void gerdac_mmc_cmd_irq(struct gerdac_mmc_host *host, unsigned int stat)
+{
+	struct mmc_command *cmd = host->cmd;
+	int i, addr;
+	
+	spin_lock(&host->lock);
+	
+	if( !host->cmd ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"Spurious CMD IRQ\n");
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"info=0x%x, mask=0x%x, stat=0x%x, err=0x%x\n",sd_ctrl_read32(host, CTL_STATUS),sd_ctrl_read32(host, CTL_IRQ_MASK),stat,sd_ctrl_read32(host, CTL_SD_ERROR_DETAIL_STATUS));
+		goto out;
+	}
+	
+	host->cmd = NULL;
+	
+//šƒRƒƒ“ƒg’ˆÓ
+	/* This controller is sicker than the PXA one. Not only do we need to
+	 * drop the top 8 bits of the first response word, we also need to
+	 * modify the order of the response for short response command types.
+	 */
+	
+	for( i = 3, addr = CTL_RESPONSE ; i >= 0 ; i--, addr += 4 ){
+		cmd->resp[i] = sd_ctrl_read32(host, addr);
+	}
+	
+	if( cmd->flags &  MMC_RSP_136 ){
+		cmd->resp[0] = (cmd->resp[0] << 8) | (cmd->resp[1] >> 24);
+		cmd->resp[1] = (cmd->resp[1] << 8) | (cmd->resp[2] >> 24);
+		cmd->resp[2] = (cmd->resp[2] << 8) | (cmd->resp[3] >> 24);
+		cmd->resp[3] <<= 8;
+	}else if( cmd->flags & MMC_RSP_R3 ){
+		cmd->resp[0] = cmd->resp[3];
+	}
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_CMD,"<<                   RES %08x %08x %08x %08x>>\n",cmd->resp[0],cmd->resp[1],cmd->resp[2],cmd->resp[3]);
+	
+	if( stat & GERDAC_STAT_CMDTIMEOUT ){
+//		if( host->pdev->id == 1 )
+		gerdac_mmc_debug_log(host,GERDAC_MMC_CMD," -> respense timeout(CMD%02u)\n",cmd->opcode);
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CMDTIMEOUT);
+		cmd->error = -ETIMEDOUT;
+	}else if( stat & GERDAC_STAT_CRCFAIL && cmd->flags & MMC_RSP_CRC ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"<<CMD%02u ARG %08x -> %s, F%x, adrs:%05x, cnt:%03x%s     >>\n",cmd->opcode, cmd->arg, (cmd->arg&0x80000000?"W":"R"),((cmd->arg)>>28)&0x7, ((cmd->arg)>>9)&0x1ffff,(cmd->arg)&0x1ff,(cmd->arg&0x08000000?"block":"bytes"));
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"<<                   RES %08x %08x %08x %08x>>\n",cmd->resp[0],cmd->resp[1],cmd->resp[2],cmd->resp[3]);
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR," -> crc failed(CMD%02u) %04x %04x stat=%08x\n",cmd->opcode, sd_ctrl_read16(host, CTL_SD_ERROR_DETAIL_STATUS), sd_ctrl_read16(host, CTL_SD_ERROR_DETAIL_STATUS2),stat);
+//		gerdac_mmc_debug_regdump( host );
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CRCFAIL);
+		cmd->error = -EILSEQ;
+	}
+	
+//šƒRƒƒ“ƒg’ˆÓ
+	/* If there is data to handle we enable data IRQs here, and
+	 * we will ultimatley finish the request in the data_end handler.
+	 * If theres no data or we encountered an error, finish now.
+	 */
+	if( host->data && !cmd->error ){
+		if( host->force_pio ){
+			if( host->data->flags & MMC_DATA_READ ){
+				gerdac_mmc_enable_mmc_irqs(host, GERDAC_MASK_READOP);
+			}else{
+				gerdac_mmc_enable_mmc_irqs(host, GERDAC_MASK_WRITEOP);
+			}
+		}else{
+			gerdac_mmc_enable_mmc_irqs(host, GERDAC_STAT_DATAEND);
+		}
+	}else{
+		schedule_work(&host->done);
+	}
+	
+out:
+	spin_unlock(&host->lock);
+}
+
+static void gerdac_mmc_card_irq_status(struct gerdac_mmc_host *host, int *ireg, int *status)
+{
+	*status = sd_ctrl_read32(host, CTL_STATUS);
+	*ireg = *status & GERDAC_MASK_IRQ & ~host->sdcard_irq_mask;
+}
+
+static bool __gerdac_mmc_card_detect_irq(struct gerdac_mmc_host *host, int ireg, int status)
+{
+	struct mmc_host *mmc = host->mmc;
+	
+	/* Card insert / remove attempts */
+	if( ireg & (GERDAC_STAT_CARD_INSERT | GERDAC_STAT_CARD_REMOVE) ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," **** Slot:%d detect or remove ****\n", host->pdev->id );
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CARD_INSERT | GERDAC_STAT_CARD_REMOVE);
+		if( (((ireg & GERDAC_STAT_CARD_REMOVE) && mmc->card) ||
+		     ((ireg & GERDAC_STAT_CARD_INSERT) && !mmc->card)) &&
+		    !work_pending(&mmc->detect.work) ){
+			mmc_detect_change(host->mmc, msecs_to_jiffies(100));
+		}
+		
+		return true;
+	}
+	
+	return false;
+}
+
+irqreturn_t gerdac_mmc_card_detect_irq(int irq, void *devid)
+{
+	unsigned int ireg, status;
+	struct gerdac_mmc_host *host = devid;
+	
+	gerdac_mmc_card_irq_status(host, &ireg, &status);
+	__gerdac_mmc_card_detect_irq(host, ireg, status);
+	
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(gerdac_mmc_card_detect_irq);
+
+static bool __gerdac_mmc_sdcard_irq(struct gerdac_mmc_host *host, int ireg, int status)
+{
+	/* Command completion */
+	if( ireg & (GERDAC_STAT_CMDRESPEND | GERDAC_STAT_CMDTIMEOUT) ){
+		gerdac_mmc_rtt_log(4);
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CMDRESPEND | GERDAC_STAT_CMDTIMEOUT);
+		gerdac_mmc_cmd_irq(host, status);
+		return true;
+	}
+	
+	/* Data transfer */
+	if( ireg & (GERDAC_STAT_RXRDY | GERDAC_STAT_TXRQ) ){
+		gerdac_mmc_rtt_log(5);
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_RXRDY | GERDAC_STAT_TXRQ);
+		gerdac_mmc_pio_irq(host);
+		return true;
+	}
+	
+	/* Data transfer completion */
+	if( ireg & GERDAC_STAT_DATAEND ){
+		gerdac_mmc_rtt_log(6);
+		gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_DATAEND);
+		gerdac_mmc_data_irq(host);
+		return true;
+	}
+	
+	return false;
+}
+
+irqreturn_t gerdac_mmc_sdcard_irq(int irq, void *devid)
+{
+	unsigned int ireg, status;
+	struct gerdac_mmc_host *host = devid;
+	
+	gerdac_mmc_card_irq_status(host, &ireg, &status);
+	__gerdac_mmc_sdcard_irq(host, ireg, status);
+	
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(gerdac_mmc_sdcard_irq);
+
+irqreturn_t gerdac_mmc_sdio_irq(int irq, void *devid)
+{
+	struct gerdac_mmc_host *host = devid;
+	struct mmc_host *mmc = host->mmc;
+	struct gerdac_mmc_data *pdata = host->pdata;
+	unsigned int ireg, status;
+	
+	if( !(pdata->flags & GERDAC_MMC_SDIO_IRQ) ){
+		return IRQ_HANDLED;
+	}
+	
+	status = sd_ctrl_read16(host, CTL_SDIO_STATUS);
+	ireg = status & GERDAC_SDIO_MASK_ALL & ~host->sdcard_irq_mask;
+	
+	sd_ctrl_write16(host, CTL_SDIO_STATUS, status & ~GERDAC_SDIO_MASK_ALL);
+	
+	if( mmc->caps & MMC_CAP_SDIO_IRQ && ireg & GERDAC_SDIO_STAT_IOIRQ ){
+		mmc_signal_sdio_irq(mmc);
+	}
+	
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(gerdac_mmc_sdio_irq);
+
+irqreturn_t gerdac_mmc_irq(int irq, void *devid)
+{
+	struct gerdac_mmc_host *host = devid;
+	unsigned int ireg, status;
+	
+//	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," IRQ start\n");
+	
+	gerdac_mmc_card_irq_status(host, &ireg, &status);
+	if( __gerdac_mmc_card_detect_irq(host, ireg, status) ){
+		return IRQ_HANDLED;
+	}
+	
+	if( __gerdac_mmc_sdcard_irq(host, ireg, status) ){
+		return IRQ_HANDLED;
+	}
+	
+	gerdac_mmc_sdio_irq(irq, devid);
+	
+	return IRQ_HANDLED;
+}
+EXPORT_SYMBOL(gerdac_mmc_irq);
+
+static int gerdac_mmc_start_data(struct gerdac_mmc_host *host, struct mmc_data *data)
+{
+	struct gerdac_mmc_data *pdata = host->pdata;
+	
+//	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ," setup data transfer: blocksize %08x  nr_blocks %d\n",data->blksz, data->blocks);
+	
+	/* Some hardware cannot perform 2 byte requests in 4 bit mode */
+	if( host->mmc->ios.bus_width == MMC_BUS_WIDTH_4 ){
+		int blksz_2bytes = pdata->flags & GERDAC_MMC_BLKSZ_2BYTES;
+		
+		if( data->blksz < 2 || (data->blksz < 4 && !blksz_2bytes) ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"%s: %d byte block unsupported in 4 bit mode\n", mmc_hostname(host->mmc), data->blksz);
+			return -EINVAL;
+		}
+	}
+	
+	gerdac_mmc_init_sg(host, data);
+	host->data = data;
+
+	/* Set transfer length / blocksize */
+	sd_ctrl_write16(host, CTL_SD_XFER_LEN, data->blksz);
+	sd_ctrl_write16(host, CTL_XFER_BLK_COUNT, data->blocks);
+	
+	gerdac_mmc_start_dma(host, data);
+	
+	return 0;
+}
+
+/* Process requests from the MMC layer */
+static void gerdac_mmc_request(struct mmc_host *mmc, struct mmc_request *mrq)
+{
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	int ret;
+	
+	gerdac_mmc_rtt_log(1);
+	if( mrq->data ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_PER," REQ >>> cmd=%d, arg=0x%08x, blksz=0x%04x, blocks=0x%04x\n", mrq->cmd->opcode, mrq->cmd->arg, mrq->data->blksz, mrq->data->blocks);
+	}
+	
+	spin_lock_irqsave(&host->lock, flags);
+	
+	if( host->mrq ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"request not null\n");
+		if( IS_ERR(host->mrq) ){
+			spin_unlock_irqrestore(&host->lock, flags);
+			mrq->cmd->error = -EAGAIN;
+			mmc_request_done(mmc, mrq);
+			return;
+		}
+	}
+	
+	host->last_req_ts = jiffies;
+	wmb();
+	host->mrq = mrq;
+	
+	spin_unlock_irqrestore(&host->lock, flags);
+	
+	gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CMD_IDX_ERR|GERDAC_STAT_CRCFAIL|GERDAC_STAT_STOPBIT_ERR
+								|GERDAC_STAT_DATATIMEOUT|GERDAC_STAT_RXOVERFLOW|GERDAC_STAT_TXUNDERRUN|GERDAC_STAT_CMDTIMEOUT|GERDAC_STAT_ILL_ACCESS);
+	gerdac_mmc_ack_mmc_irqs(host, GERDAC_STAT_CMDRESPEND|GERDAC_STAT_DATAEND|GERDAC_STAT_RXRDY|GERDAC_STAT_TXRQ);
+	
+	if( mrq->data ){
+		ret = gerdac_mmc_start_data(host, mrq->data);
+		if( ret ){
+			goto fail;
+		}
+	}
+	
+	ret = gerdac_mmc_start_command(host, mrq->cmd);
+	if( !ret ){
+		schedule_delayed_work(&host->delayed_reset_work, msecs_to_jiffies(2000));
+//		schedule_delayed_work(&host->delayed_reset_work, msecs_to_jiffies(5000));
+		return;
+	}
+	
+fail:
+	host->force_pio = false;
+	host->mrq = NULL;
+	mrq->cmd->error = ret;
+	mmc_request_done(mmc, mrq);
+}
+
+static int gerdac_mmc_clk_update(struct mmc_host *mmc)
+{
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	struct gerdac_mmc_data *pdata = host->pdata;
+	int ret;
+	
+	if( !pdata->clk_enable ){
+		return -ENOTSUPP;
+	}
+	
+	ret = pdata->clk_enable(host->pdev, &mmc->f_max);
+	if( !ret ){
+		mmc->f_min = mmc->f_max / 512;
+	}
+	
+	return ret;
+}
+
+static void gerdac_mmc_power_on(struct gerdac_mmc_host *host, unsigned short vdd)
+{
+#ifdef	CONFIG_MMC_GERDAC
+	// PowerON 3.3V	šÅ‰‚©‚ç1.8V•K—v‚©H
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"power_on=1.8V\n");
+//	sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & 0xFFFC) | 0x0001);	// 3.3V
+	sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & 0xFFFC) | 0x0002);	// 1.8V
+#endif	/* CONFIG_MMC_GERDAC */
+}
+
+static void gerdac_mmc_power_off(struct gerdac_mmc_host *host)
+{
+#ifdef	CONFIG_MMC_GERDAC
+	//PowerOFF 0V
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"power_off\n");
+	sd_ctrl_write16(host, CTL_BUS_MODE, sd_ctrl_read16(host, CTL_BUS_MODE) & 0xFFFC);
+#endif	/* CONFIG_MMC_GERDAC */
+}
+
+/* Set MMC clock / power. */
+static void gerdac_mmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	unsigned long flags;
+	
+	mutex_lock(&host->ios_lock);
+	
+	spin_lock_irqsave(&host->lock, flags);
+	if( host->mrq ){
+		if( IS_ERR(host->mrq) ){
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"%s.%d: concurrent .set_ios(), clk %u, mode %u\n", current->comm, task_pid_nr(current), ios->clock, ios->power_mode);
+			host->mrq = ERR_PTR(-EINTR);
+		}else{
+			gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"%s.%d: CMD%u active since %lu, now %lu!\n", current->comm, task_pid_nr(current), host->mrq->cmd->opcode, host->last_req_ts, jiffies);
+		}
+		spin_unlock_irqrestore(&host->lock, flags);
+		
+		mutex_unlock(&host->ios_lock);
+		return;
+	}
+	
+	host->mrq = ERR_PTR(-EBUSY);
+	
+	spin_unlock_irqrestore(&host->lock, flags);
+	
+//šƒRƒƒ“ƒg’ˆÓ
+	/*
+	 * host->power toggles between false and true in both cases - either
+	 * or not the controller can be runtime-suspended during inactivity.
+	 * But if the controller has to be kept on, the runtime-pm usage_count
+	 * is kept positive, so no suspending actually takes place.
+	 */
+	if( ios->power_mode == MMC_POWER_ON && ios->clock ){
+		if( host->power != GERDAC_MMC_ON_RUN ){
+			gerdac_mmc_clk_update(mmc);
+		}
+		if( host->power == GERDAC_MMC_OFF_STOP ){
+			gerdac_mmc_reset(host);
+		}
+		gerdac_mmc_set_clock(host, ios->clock);
+		if( host->power == GERDAC_MMC_OFF_STOP ){
+			/* power up SD card and the bus */
+			gerdac_mmc_power_on(host, ios->vdd);
+		}
+		host->power = GERDAC_MMC_ON_RUN;
+		/* start bus clock */
+		gerdac_mmc_clk_start(host);
+	}else if( ios->power_mode != MMC_POWER_UP ){
+		unsigned int old_power = host->power;
+		
+		if( old_power != GERDAC_MMC_OFF_STOP ){
+			if( ios->power_mode == MMC_POWER_OFF ){
+				gerdac_mmc_power_off(host);
+				host->power = GERDAC_MMC_OFF_STOP;
+			}else{
+				host->power = GERDAC_MMC_ON_STOP;
+			}
+		}
+		
+		if( old_power == GERDAC_MMC_ON_RUN ){
+			gerdac_mmc_clk_stop(host);
+		}
+	}
+	
+	if( host->power != GERDAC_MMC_OFF_STOP ){
+		switch( ios->bus_width ){
+			case MMC_BUS_WIDTH_1:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"bus_width=1\n");
+				sd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, 0x80e0);
+				break;
+			case MMC_BUS_WIDTH_4:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"bus_width=4\n");
+				sd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, 0x00e0);
+				break;
+			case MMC_BUS_WIDTH_8:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"bus_width=8\n");
+				sd_ctrl_write16(host, CTL_SD_MEM_CARD_OPT, 0x20e0);
+				break;
+			default:
+				break;
+		}
+#ifdef	CONFIG_MMC_GERDAC
+		switch( ios->timing ){
+			case MMC_TIMING_LEGACY:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=LEGACY\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) & ~0x0001);			// DDR=0
+				sd_ctrl_write16(host, CTL_BUS_MODE, sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700);				// ACSMODE=0
+				sd_ctrl_write16(host, CTL_UHS1MODE, sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003);				// UHS1MODE=0,SDRSEL=0
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) & ~0x0001);				// MMCMODE=0
+				break;
+			case MMC_TIMING_MMC_HS:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=MMC HS\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) & ~0x0001);			// DDR=0
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700) | 0x0100);	// ACSMODE=1
+				sd_ctrl_write16(host, CTL_UHS1MODE, sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003);				// UHS1MODE=0,SDRSEL=0
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) | 0x0001);					// MMCMODE=1
+				break;
+			case MMC_TIMING_SD_HS:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=SD HS\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) & ~0x0001);			// DDR=0
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700) | 0x0100);	// ACSMODE=1
+				sd_ctrl_write16(host, CTL_UHS1MODE, sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003);				// UHS1MODE=0,SDRSEL=0
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) & ~0x0001);				// MMCMODE=0
+				break;
+			case MMC_TIMING_UHS_SDR12:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=UHS SDR12\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) & ~0x0001);			// DDR=0
+				sd_ctrl_write16(host, CTL_BUS_MODE, sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700);				// ACSMODE=0
+				sd_ctrl_write16(host, CTL_UHS1MODE, (sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003) | 0x0002);	// UHS1MODE=1,SDRSEL=0
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) & ~0x0001);				// MMCMODE=0
+				break;
+			case MMC_TIMING_UHS_SDR50:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=UHS SDR50\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) & ~0x0001);			// DDR=0
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700) | 0x0200);	// ACSMODE=2
+				sd_ctrl_write16(host, CTL_UHS1MODE, (sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003) | 0x0003);	// UHS1MODE=1,SDRSEL=1
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) & ~0x0001);				// MMCMODE=0
+				break;
+			case MMC_TIMING_UHS_DDR50:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"ac_timing=DDR50\n");
+				sd_ctrl_write16(host, CTL_SDIF_MODE, sd_ctrl_read16(host, CTL_SDIF_MODE) | 0x0001);				// DDR=1
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0700) | 0x0400);	// ACSMODE=4
+				sd_ctrl_write16(host, CTL_UHS1MODE, sd_ctrl_read16(host, CTL_UHS1MODE) & ~0x0003);				// UHS1MODE=0,SDRSEL=0
+				sd_ctrl_write16(host, CTL_MMCMODE, sd_ctrl_read16(host, CTL_MMCMODE) | 0x0001);					// MMCMODE=1
+				break;
+			default:
+				break;
+		}
+		switch( ios->drv_type ){
+			case MMC_SET_DRIVER_TYPE_B:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"driver_type=B\n");
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0030) | 0x0000);	// TypeB
+				break;
+			case MMC_SET_DRIVER_TYPE_A:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"driver_type=A\n");
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0030) | 0x0010);	// TypeA
+				break;
+			case MMC_SET_DRIVER_TYPE_C:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"driver_type=C\n");
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0030) | 0x0020);	// TypeC
+				break;
+			case MMC_SET_DRIVER_TYPE_D:
+				gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"driver_type=D\n");
+				sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & ~0x0030) | 0x0030);	// TypeD
+				break;
+			default:
+				break;
+		}
+#else	/* CONFIG_MMC_GERDAC */
+#endif	/* CONFIG_MMC_GERDAC */
+	}
+	
+//šƒRƒƒ“ƒg’ˆÓ
+	/* Let things settle. delay taken from winCE driver */
+	udelay(140);
+	if( PTR_ERR(host->mrq) == -EINTR ){
+		gerdac_mmc_debug_log(host,GERDAC_MMC_ERR,"%s.%d: IOS interrupted: clk %u, mode %u\n", current->comm, task_pid_nr(current), ios->clock, ios->power_mode);
+	}
+	host->mrq = NULL;
+	
+	mutex_unlock(&host->ios_lock);
+}
+
+static int gerdac_mmc_get_ro(struct mmc_host *mmc)
+{
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	struct gerdac_mmc_data *pdata = host->pdata;
+	int ret = mmc_gpio_get_ro(mmc);
+	
+	if( ret >= 0 ){
+		return ret;
+	}
+	
+	return !((pdata->flags & GERDAC_MMC_WRPROTECT_DISABLE) ||
+		 (sd_ctrl_read32(host, CTL_STATUS) & GERDAC_STAT_WRPROTECT));
+}
+
+static int gerdac_mmc_start_signal_voltage_switch(struct mmc_host *mmc, struct mmc_ios *ios)
+{
+#ifdef	CONFIG_MMC_GERDAC
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	switch (ios->signal_voltage) {
+		case MMC_SIGNAL_VOLTAGE_330:
+			sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & 0xFFFC) | 0x0001);
+			break;
+		case MMC_SIGNAL_VOLTAGE_180:
+			sd_ctrl_write16(host, CTL_BUS_MODE, (sd_ctrl_read16(host, CTL_BUS_MODE) & 0xFFFC) | 0x0002);
+			break;
+		case MMC_SIGNAL_VOLTAGE_120:
+			/* not support */
+			break;
+		default:
+			/* No signal voltage switch required */
+			break;
+	}
+#endif	/* CONFIG_MMC_GERDAC */
+	
+	return 0;
+}
+
+static const struct mmc_host_ops gerdac_mmc_ops = {
+	.request			= gerdac_mmc_request,
+	.set_ios			= gerdac_mmc_set_ios,
+	.get_ro				= gerdac_mmc_get_ro,
+	.get_cd				= mmc_gpio_get_cd,
+	.enable_sdio_irq	= gerdac_mmc_enable_sdio_irq,
+	.start_signal_voltage_switch = gerdac_mmc_start_signal_voltage_switch,
+};
+
+static int gerdac_mmc_init_ocr(struct gerdac_mmc_host *host)
+{
+	struct gerdac_mmc_data *pdata = host->pdata;
+	struct mmc_host *mmc = host->mmc;
+	
+	mmc_regulator_get_supply(mmc);
+	
+	/* use ocr_mask if no regulator */
+	if( !mmc->ocr_avail ){
+		mmc->ocr_avail =  pdata->ocr_mask;
+	}
+	
+	/*
+	 * try again.
+	 * There is possibility that regulator has not been probed
+	 */
+	if( !mmc->ocr_avail ){
+		return -EPROBE_DEFER;
+	}
+	
+	return 0;
+}
+
+static void gerdac_mmc_of_parse(struct platform_device *pdev, struct gerdac_mmc_data *pdata)
+{
+	const struct device_node *np = pdev->dev.of_node;
+	if( !np ){
+		return;
+	}
+	if( of_get_property(np, "toshiba,mmc-wrprotect-disable", NULL) ){		// š
+		pdata->flags |= GERDAC_MMC_WRPROTECT_DISABLE;
+	}
+}
+
+int gerdac_mmc_host_probe(struct gerdac_mmc_host **host,
+				  struct platform_device *pdev,
+				  struct gerdac_mmc_data *pdata)
+{
+	struct gerdac_mmc_host *_host;
+	struct mmc_host *mmc;
+	struct resource *res_ctl, *res_sdma_ctl, *res_sdma_rxctl, * res_sdma_txctl;
+	int ret;
+	u32 irq_mask = GERDAC_MASK_CMD;
+	
+	gerdac_mmc_of_parse(pdev, pdata);
+	
+	res_ctl = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	res_sdma_ctl = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	res_sdma_rxctl = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	res_sdma_txctl = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if( !res_ctl || !res_sdma_ctl || !res_sdma_rxctl || !res_sdma_txctl ){
+		return -EINVAL;
+	}
+	
+	mmc = mmc_alloc_host(sizeof(struct gerdac_mmc_host), &pdev->dev);
+	if( !mmc ){
+		return -ENOMEM;
+	}
+	
+	ret = mmc_of_parse(mmc);
+	if( ret < 0 ){
+		goto host_free;
+	}
+	
+	pdata->dev = &pdev->dev;
+	_host = mmc_priv(mmc);
+	_host->pdata = pdata;
+	_host->mmc = mmc;
+	_host->pdev = pdev;
+	platform_set_drvdata(pdev, mmc);
+	
+	_host->set_pwr = pdata->set_pwr;
+	_host->set_clk_div = pdata->set_clk_div;
+	
+	ret = gerdac_mmc_init_ocr(_host);
+	if( ret < 0 ){
+		goto host_free;
+	}
+	
+	_host->ctl = ioremap_nocache(res_ctl->start, resource_size(res_ctl));
+	_host->sdma_ctl = ioremap_nocache(res_sdma_ctl->start, resource_size(res_sdma_ctl));
+	_host->sdma_rxctl = ioremap_nocache(res_sdma_rxctl->start, resource_size(res_sdma_rxctl));
+	_host->sdma_txctl = ioremap_nocache(res_sdma_txctl->start, resource_size(res_sdma_txctl));
+	if( !_host->ctl || !_host->sdma_ctl || !_host->sdma_rxctl || !_host->sdma_txctl ){
+		ret = -ENOMEM;
+		goto host_free;
+	}
+
+	{
+		void __iomem		*vaddr_base;
+		volatile u32		utemp32;
+		vaddr_base = ioremap_nocache(0x9C010344, 4);
+		utemp32 = *(volatile u32 *)(vaddr_base + 0x0000);
+		iounmap(vaddr_base);
+		if( _host->pdata->use_dma && (utemp32 == 0x0000) ){
+			_host->pdata->use_dma = false;	/* ES1 DMA Disable */
+		}
+	}
+	
+	mmc->ops = &gerdac_mmc_ops;
+	mmc->caps |= MMC_CAP_4_BIT_DATA | pdata->capabilities;
+	mmc->caps2 |= pdata->capabilities2;
+	mmc->max_segs = 1;
+	mmc->max_blk_size = 512;
+	mmc->max_blk_count = GERDAC_MMC_MAX_REQ_SIZE * (PAGE_CACHE_SIZE / mmc->max_blk_size) * mmc->max_segs;
+	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
+	mmc->max_seg_size = mmc->max_req_size;
+	
+	_host->native_hotplug = !(pdata->flags & GERDAC_MMC_USE_GPIO_CD ||
+				  mmc->caps & MMC_CAP_NEEDS_POLL ||
+				  mmc->caps & MMC_CAP_NONREMOVABLE ||
+				  mmc->slot.cd_irq >= 0);
+
+	_host->power = GERDAC_MMC_OFF_STOP;
+	pm_runtime_enable(&pdev->dev);
+	ret = pm_runtime_resume(&pdev->dev);
+	if( ret < 0 ){
+		goto pm_disable;
+	}
+	
+	if( gerdac_mmc_clk_update(mmc) < 0 ){
+		mmc->f_max = pdata->hclk;
+		mmc->f_min = mmc->f_max / 512;
+	}
+	
+//šƒRƒƒ“ƒg’ˆÓII
+	/*
+	 * There are 4 different scenarios for the card detection:
+	 *  1) an external gpio irq handles the cd (best for power savings)
+	 *  2) internal sdhi irq handles the cd
+	 *  3) a worker thread polls the sdhi - indicated by MMC_CAP_NEEDS_POLL
+	 *  4) the medium is non-removable - indicated by MMC_CAP_NONREMOVABLE
+	 *
+	 *  While we increment the runtime PM counter for all scenarios when
+	 *  the mmc core activates us by calling an appropriate set_ios(), we
+	 *  must additionally ensure that in case 2) the tmio mmc hardware stays
+	 *  powered on during runtime for the card detection to work.
+	 */
+	if( _host->native_hotplug ){
+		pm_runtime_get_noresume(&pdev->dev);
+	}
+	
+	gerdac_mmc_clk_stop(_host);
+	gerdac_mmc_reset(_host);
+	
+	_host->sdcard_irq_mask = sd_ctrl_read32(_host, CTL_IRQ_MASK);
+	gerdac_mmc_disable_mmc_irqs(_host, GERDAC_MASK_ALL);
+	
+	/* Unmask the IRQs we want to know about */
+	irq_mask |= GERDAC_MASK_READOP;
+	irq_mask |= GERDAC_MASK_WRITEOP;
+	if( !_host->native_hotplug ){
+		irq_mask &= ~(GERDAC_STAT_CARD_REMOVE | GERDAC_STAT_CARD_INSERT);
+	}
+	
+	_host->sdcard_irq_mask &= ~irq_mask;
+	
+	if( pdata->flags & GERDAC_MMC_SDIO_IRQ ){
+		gerdac_mmc_enable_sdio_irq(mmc, 0);
+	}
+	
+	spin_lock_init(&_host->lock);
+	mutex_init(&_host->ios_lock);
+	
+	/* Init delayed work for request timeouts */
+	INIT_DELAYED_WORK(&_host->delayed_reset_work, gerdac_mmc_reset_work);
+	INIT_WORK(&_host->done, gerdac_mmc_done_work);
+	
+	ret = mmc_add_host(mmc);
+	if( pdata->clk_disable ){
+		pdata->clk_disable(pdev);
+	}
+	if( ret < 0 ){
+		gerdac_mmc_host_remove(_host);
+		return ret;
+	}
+	
+	dev_pm_qos_expose_latency_limit(&pdev->dev, 100);
+	
+	*host = _host;
+	
+	return 0;
+	
+pm_disable:
+	pm_runtime_disable(&pdev->dev);
+	iounmap(_host->ctl);
+host_free:
+	mmc_free_host(mmc);
+	
+	return ret;
+}
+EXPORT_SYMBOL(gerdac_mmc_host_probe);
+
+void gerdac_mmc_host_remove(struct gerdac_mmc_host *host)
+{
+	struct platform_device *pdev = host->pdev;
+	struct mmc_host *mmc = host->mmc;
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+	
+	if( !host->native_hotplug ){
+		pm_runtime_get_sync(&pdev->dev);
+	}
+	
+	dev_pm_qos_hide_latency_limit(&pdev->dev);
+	
+	mmc_remove_host(mmc);
+	cancel_work_sync(&host->done);
+	cancel_delayed_work_sync(&host->delayed_reset_work);
+	
+	pm_runtime_put_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	
+	iounmap(host->ctl);
+	iounmap(host->sdma_ctl);
+	mmc_free_host(mmc);
+}
+EXPORT_SYMBOL(gerdac_mmc_host_remove);
+
+#ifdef CONFIG_PM
+int gerdac_mmc_host_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+	
+	gerdac_mmc_disable_mmc_irqs(host, GERDAC_MASK_ALL);
+	
+	return 0;
+}
+EXPORT_SYMBOL(gerdac_mmc_host_suspend);
+
+int gerdac_mmc_host_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+	
+	gerdac_mmc_enable_dma(host, true);
+	
+	/* The MMC core will perform the complete set up */
+	host->resuming = true;
+	
+	return 0;
+}
+EXPORT_SYMBOL(gerdac_mmc_host_resume);
+
+#endif	/* CONFIG_PM */
+
+int gerdac_mmc_host_runtime_suspend(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+	
+	return 0;
+}
+EXPORT_SYMBOL(gerdac_mmc_host_runtime_suspend);
+
+int gerdac_mmc_host_runtime_resume(struct device *dev)
+{
+	struct mmc_host *mmc = dev_get_drvdata(dev);
+	struct gerdac_mmc_host *host = mmc_priv(mmc);
+	
+	gerdac_mmc_debug_log(host,GERDAC_MMC_SEQ,"enter.\n" );
+	
+	gerdac_mmc_enable_dma(host, true);
+	
+	return 0;
+}
+EXPORT_SYMBOL(gerdac_mmc_host_runtime_resume);
+
+MODULE_LICENSE("GPL v2");
diff -uNr linux-3.14.19/drivers/mtd/devices/Kconfig linux-gerda/drivers/mtd/devices/Kconfig
--- linux-3.14.19/drivers/mtd/devices/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mtd/devices/Kconfig	2017-06-22 09:52:31.115039896 +0900
@@ -95,6 +95,11 @@
 	  if you want to specify device partitioning or to use a device which
 	  doesn't support the JEDEC ID instruction.
 
+config MTD_MN_NOR
+	tristate "Support Panasonic NOR Flash Controller"
+	help
+	  This enables NOR Flash support on Panasonic SOCs"
+
 config MTD_SPEAR_SMI
 	tristate "SPEAR MTD NOR Support through SMI controller"
 	depends on PLAT_SPEAR
diff -uNr linux-3.14.19/drivers/mtd/devices/Makefile linux-gerda/drivers/mtd/devices/Makefile
--- linux-3.14.19/drivers/mtd/devices/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/mtd/devices/Makefile	2017-06-22 09:52:31.119039896 +0900
@@ -16,6 +16,7 @@
 obj-$(CONFIG_MTD_SPEAR_SMI)	+= spear_smi.o
 obj-$(CONFIG_MTD_SST25L)	+= sst25l.o
 obj-$(CONFIG_MTD_BCM47XXSFLASH)	+= bcm47xxsflash.o
+obj-$(CONFIG_MTD_MN_NOR)	+= nor-mn.o
 
 
 CFLAGS_docg3.o			+= -I$(src)
diff -uNr linux-3.14.19/drivers/mtd/devices/nor-mn.c linux-gerda/drivers/mtd/devices/nor-mn.c
--- linux-3.14.19/drivers/mtd/devices/nor-mn.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/mtd/devices/nor-mn.c	2017-06-22 09:52:31.115039896 +0900
@@ -0,0 +1,1002 @@
+/*
+ * Panasonic SOCs NOR FLASH Driver
+ *
+ *  Copyright (C) 2015 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Derived from drivers/mtd/devices/m25p80.c
+ */
+
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/mutex.h>
+#include <linux/math64.h>
+#include <linux/slab.h>
+#include <linux/sched.h>
+#include <linux/mod_devicetable.h>
+
+#include <linux/mtd/cfi.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#include <linux/of_platform.h>
+#include <linux/of_address.h>
+
+#include <linux/spi/flash.h>
+
+
+#define MN_NOR_USE_LOG_MESSAGE
+
+#if 0   /* LOG */
+#define mn_nor_log	pr_debug
+#elif 0 /* RT3 */
+#include <asm/rt3.h>
+#define mn_nor_log(...)	_TRC_usr_log_ext(0, __LINE__)
+#undef MN_NOR_USE_LOG_MESSAGE
+#elif 0 /* FTRACE */
+#define mn_nor_log	trace_printk
+#else
+#define mn_nor_log(...)	do { } while (0)
+#undef MN_NOR_USE_LOG_MESSAGE
+#endif
+
+#define MAX_NUMCHIPS		2
+
+/* Flash opcodes. */
+#define OPCODE_WREN		0x06	/* Write enable */
+#define OPCODE_RDSR		0x05	/* Read status register */
+#define OPCODE_WRSR		0x01	/* Write status register 1 byte */
+#define OPCODE_NORM_READ	0x03	/* Read data bytes (low frequency) */
+#define OPCODE_FAST_READ	0x0b	/* Read data bytes (high frequency) */
+#define OPCODE_QUAD_READ	0x6b	/* Read data bytes */
+#define OPCODE_PP		0x02	/* Page program (up to 256 bytes) */
+#define OPCODE_BE_4K		0x20	/* Erase 4KiB block */
+#define OPCODE_BE_4K_PMC	0xd7	/* Erase 4KiB block on PMC chips */
+#define OPCODE_BE_32K		0x52	/* Erase 32KiB block */
+#define OPCODE_CHIP_ERASE	0xc7	/* Erase whole flash chip */
+#define OPCODE_SE		0xd8	/* Sector erase (usually 64KiB) */
+#define OPCODE_RDID		0x9f	/* Read JEDEC ID */
+#define OPCODE_RDCR		0x35	/* Read configuration register */
+
+/* 4-byte address opcodes - used on Spansion and some Macronix flashes. */
+#define OPCODE_NORM_READ_4B	0x13	/* Read data bytes (low frequency) */
+#define OPCODE_FAST_READ_4B	0x0c	/* Read data bytes (high frequency) */
+#define OPCODE_QUAD_READ_4B	0x6c	/* Read data bytes */
+#define OPCODE_PP_4B		0x12	/* Page program (up to 256 bytes) */
+#define OPCODE_SE_4B		0xdc	/* Sector erase (usually 64KiB) */
+
+/* Used for SST flashes only. */
+#define OPCODE_BP		0x02	/* Byte program */
+#define OPCODE_WRDI		0x04	/* Write disable */
+#define OPCODE_AAI_WP		0xad	/* Auto address increment word program */
+
+/* Used for Macronix and Winbond flashes. */
+#define OPCODE_EN4B		0xb7	/* Enter 4-byte mode */
+#define OPCODE_EX4B		0xe9	/* Exit 4-byte mode */
+
+/* Used for Spansion flashes only. */
+#define OPCODE_BRWR		0x17	/* Bank register write */
+
+/* Used for Panasonic flashes only. */
+#define OPCODE_AUTO_WREN	0x0100
+
+/* Status Register bits. */
+#define SR_WIP			1	/* Write in progress */
+#define SR_WEL			2	/* Write enable latch */
+/* meaning of other SR_* bits may differ between vendors */
+#define SR_BP0			4	/* Block protect 0 */
+#define SR_BP1			8	/* Block protect 1 */
+#define SR_BP2			0x10	/* Block protect 2 */
+#define SR_SRWD			0x80	/* SR write protect */
+
+#define SR_QUAD_EN_MX		0x40	/* Macronix Quad I/O */
+
+/* Configuration Register bits. */
+#define CR_QUAD_EN_SPAN		0x2	/* Spansion Quad I/O */
+
+#define MAX_CMD_SIZE		6
+
+#define JEDEC_MFR(_jedec_id)	((_jedec_id) >> 16)
+
+/* flm registers */
+#define FLMm_BUS_MODE(m)	(0x0004 + 0x200 * (m))
+#define FLMm_DEVICE_n(m, n)	(0x0008 + 0x200 * (m) + 0x04 * (n))
+#define FLMm_CSn_CERASE(m, n)	(0x0014 + 0x200 * (m) + 0x04 * (n))
+#define FLMm_CSn_SERASE(m, n)	(0x001c + 0x200 * (m) + 0x04 * (n))
+#define FLMm_SECTOR_ADDR(m)	(0x0024 + 0x200 * (m))
+#define FLMm_SFLASH_NUM(m)	(0x0030 + 0x200 * (m))
+#define FLMm_SFLASH_CLK(m)	(0x0034 + 0x200 * (m))
+#define FLMm_SFLASH_FAST(m)	(0x0038 + 0x200 * (m))
+#define FLMm_SFLASH_DUMMY(m)	(0x003c + 0x200 * (m))
+#define FLMm_FLASH_MONITOR(m)	(0x0050 + 0x200 * (m))
+#define FLMm_FLASH_IOCTRL(m)	(0x0054 + 0x200 * (m))
+#define FLMm_SFLASH_IOSEL(m)	(0x0058 + 0x200 * (m))
+#define FLMm_SFLASH_WCLK(m)	(0x005c + 0x200 * (m))
+#define FLMm_SFLASH_WRENCMD(m)	(0x009c + 0x200 * (m))
+#define FLMm_REG_SET(m)		(0x00f0 + 0x200 * (m))
+#define FLMm_SFLASH_MODE(m)	(0x0100 + 0x200 * (m))
+#define FLMm_SFLASH_TYPE(m)	(0x0104 + 0x200 * (m))
+#define FLMm_SFLASH_LNG(m)	(0x0108 + 0x200 * (m))
+#define FLMm_SFLASH_CMD(m)	(0x010c + 0x200 * (m))
+#define FLMm_SFLASH_WDT1(m)	(0x0118 + 0x200 * (m))
+#define FLMm_SFLASH_RDT1(m)	(0x0120 + 0x200 * (m))
+#define FLMm_SFLASH_CS(m)	(0x0128 + 0x200 * (m))
+#define FLMm_FLASH_MODE(m)	(0x0130 + 0x200 * (m))
+#define FLMm_SP_EMC_CTRL(m)	(0x0148 + 0x200 * (m))
+#define FLMm_SP_REG_SET(m)	(0x014c + 0x200 * (m))
+
+#define TYPE_CMDUSE		0x01
+#define TYPE_RDTUSE		0x08
+#define TYPE_WDTUSE		0x10
+#define TYPE_CONTINUE		0x80
+
+/* wss registers */
+#define WSS_CMD_SET		0x0000
+#define WSS_ADDR_SET		0x0008
+#define WSS_CTL			0x000c
+#define WSS_BWD(n)		(0x0100 + 0x04 * (n))		/* n = 0-127 */
+
+/* sys registers */
+#define NIC_WRFBDn_START(n)	(0x0170 + 0x08 * (n))		/* n = 0-2 */
+#define NIC_ACCFBDn_START(n)	(0x0190 + 0x04 * (n))		/* n = 0-2 */
+
+/****************************************************************************/
+
+enum read_type {
+	MN_NOR_NORMAL = 0,
+	MN_NOR_FAST,
+	MN_NOR_QUAD,
+};
+
+struct mn_nor {
+	struct device		*dev;
+	struct mtd_info		mtd;
+	phys_addr_t		phys_mem_base;
+	void __iomem		*mem_base;
+	void __iomem		*flm_base;
+	void __iomem		*wss_base;
+	void __iomem		*sys_base;
+	u32			cs;
+	u32			numchips;
+	u32			modifier;
+	u16			page_size;
+};
+
+#define MN_NOR_RX_QUAD		0x800	/* receive with 4 wires */
+
+static inline struct mn_nor *mtd_to_mn_nor(struct mtd_info *mtd)
+{
+	return container_of(mtd, struct mn_nor, mtd);
+}
+
+/****************************************************************************/
+
+static DEFINE_MUTEX(mn_nor_mutex);
+
+/*
+ * Internal helper functions
+ */
+
+#define flm_readl(flash, offset)	readl_relaxed((flash)->flm_base + (offset))
+#define flm_writel(flash, val, offset)	writel_relaxed(val, (flash)->flm_base + (offset))
+
+#define wss_readl(flash, offset)	readl_relaxed((flash)->wss_base + (offset))
+#define wss_writel(flash, val, offset)	writel_relaxed(val, (flash)->wss_base + (offset))
+
+#define sys_readl(flash, offset)	readl_relaxed((flash)->sys_base + (offset))
+#define sys_writel(flash, val, offset)	writel_relaxed(val, (flash)->sys_base + (offset))
+
+static inline void emc_bus_lock(struct mn_nor *flash)
+{
+	u32 cs = flash->cs;
+
+	flm_writel(flash, 1, FLMm_SP_EMC_CTRL(cs >> 1));
+
+	do {} while (!(flm_readl(flash, FLMm_SP_EMC_CTRL(cs >> 1)) & 0x10));
+}
+
+static inline void emc_bus_unlock(struct mn_nor *flash)
+{
+	u32 cs = flash->cs;
+
+	flm_writel(flash, 0, FLMm_SP_EMC_CTRL(cs >> 1));
+}
+
+/* don't use read data bytes and page program */
+static int mn_nor_write_then_read(struct mn_nor *flash,
+				  const u16 *txbuf, unsigned int n_tx,
+				  u8 *rwbuf, unsigned int n_rw)
+{
+	unsigned int write;
+	unsigned int i, j;
+
+	u32 cs = flash->cs;
+	u32 numchips = flash->numchips;
+	u32 cmd = txbuf[0];
+	u32 n = n_tx + n_rw;
+	u32 t, val = 0;
+	u8 *ptr8 = (u8 *)&val;
+
+	if (n_rw % numchips)
+		return -EINVAL;
+
+	emc_bus_lock(flash);
+
+	write = cmd & OPCODE_AUTO_WREN;
+
+	if (write) {
+		flm_writel(flash, 6, FLMm_SFLASH_WRENCMD(cs >> 1));
+		flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+	}
+
+	t = (n == 1) ? TYPE_CMDUSE : (TYPE_CONTINUE | TYPE_CMDUSE);
+	flm_writel(flash, t, FLMm_SFLASH_TYPE(cs >> 1));
+	flm_writel(flash, cmd, FLMm_SFLASH_CMD(cs >> 1));
+	flm_writel(flash, cs & 1, FLMm_SFLASH_CS(cs >> 1));
+
+	flm_writel(flash, 1, FLMm_SP_REG_SET(cs >> 1));
+	do {} while (flm_readl(flash, FLMm_SP_REG_SET(cs >> 1)) & 0x10);
+
+	flm_writel(flash, 0, FLMm_SFLASH_CMD(cs >> 1));
+	flm_writel(flash, 0, FLMm_SFLASH_LNG(cs >> 1));
+
+	t = (write) ? (TYPE_CONTINUE | TYPE_WDTUSE) : (TYPE_CONTINUE | TYPE_RDTUSE);
+
+	for (i = 1; i < n_tx; i++) {
+		if ((i == (n_tx - 1)) && !n_rw)
+			t &= ~TYPE_CONTINUE;
+
+		val = (txbuf[i] & 0xff) * flash->modifier;
+		flm_writel(flash, t, FLMm_SFLASH_TYPE(cs >> 1));
+		flm_writel(flash, val, FLMm_SFLASH_WDT1(cs >> 1));
+
+		flm_writel(flash, 1, FLMm_SP_REG_SET(cs >> 1));
+		do {} while (flm_readl(flash, FLMm_SP_REG_SET(cs >> 1)) & 0x10);
+	}
+
+	for (i = 0; i < n_rw; i += numchips) {
+		if (i == (n_rw - numchips))
+			t &= ~TYPE_CONTINUE;
+		flm_writel(flash, t, FLMm_SFLASH_TYPE(cs >> 1));
+
+		if (write) {
+			for (j = 0; j < numchips; j++)
+				ptr8[j] = rwbuf[i + j];
+			flm_writel(flash, val, FLMm_SFLASH_WDT1(cs >> 1));
+		}
+
+		flm_writel(flash, 1, FLMm_SP_REG_SET(cs >> 1));
+		do {} while (flm_readl(flash, FLMm_SP_REG_SET(cs >> 1)) & 0x10);
+
+		if (!write) {
+			val = flm_readl(flash, FLMm_SFLASH_RDT1(cs >> 1));
+			for (j = 0; j < numchips; j++)
+				rwbuf[i + j] = ptr8[j];
+		}
+	}
+
+	if (write) {
+		flm_writel(flash, 4, FLMm_SFLASH_WRENCMD(cs >> 1));
+		flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+	}
+
+	emc_bus_unlock(flash);
+
+	return 0;
+}
+
+
+
+static void wait_cond_adaptive(struct mn_nor *flash,
+			       unsigned int uwait, unsigned int min_uwait,
+			       loff_t offset, unsigned int val)
+{
+	unsigned int tmp_uwait;
+
+	do {
+		if (20 * USEC_PER_MSEC < uwait) {
+			tmp_uwait = uwait / USEC_PER_MSEC;
+			mn_nor_log("msleep(%u)\n", tmp_uwait);
+			msleep(tmp_uwait);
+		} else {
+			tmp_uwait = uwait - (min_uwait / 2);
+			mn_nor_log("usleep_range(%u, %u)\n", tmp_uwait, uwait);
+			usleep_range(tmp_uwait, uwait);
+		}
+
+		tmp_uwait = uwait >> 1;
+		if (min_uwait < tmp_uwait)
+			uwait = tmp_uwait;
+		else
+			uwait = min_uwait;
+	} while (flm_readl(flash, offset) != val);
+
+	mn_nor_log("wait end\n");
+}
+
+/*
+ * Erase the whole flash memory
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_chip(struct mn_nor *flash)
+{
+	u32 cs = flash->cs;
+	u32 size = flash->mtd.size >> (flash->numchips - 1);
+
+	mn_nor_log("%s: %lldKiB\n", dev_name(flash->dev), (long long)(flash->mtd.size >> 10));
+
+	flm_writel(flash, 6, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, 1, FLMm_CSn_CERASE(cs >> 1, cs & 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	wait_cond_adaptive(flash, size / 4096 * 3 * USEC_PER_MSEC, USEC_PER_SEC / HZ,
+			   FLMm_CSn_CERASE(cs >> 1, cs & 1), 0);
+
+	flm_writel(flash, 4, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	return 0;
+}
+
+/*
+ * Erase one sector of flash memory at offset ``offset'' which is any
+ * address within the sector which should be erased.
+ *
+ * Returns 0 if successful, non-zero otherwise.
+ */
+static int erase_sector(struct mn_nor *flash, u32 offset)
+{
+	u32 cs = flash->cs;
+	u32 addr;
+	u32 size = flash->mtd.erasesize >> (flash->numchips - 1);
+
+	addr = (offset & 0x1fffffff) >> (flash->numchips - 1);
+
+	mn_nor_log("%s: %dKiB at 0x%08x(0x%08x)\n", dev_name(flash->dev),
+		   flash->mtd.erasesize / 1024, addr, offset);
+
+	flm_writel(flash, 6, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, addr, FLMm_SECTOR_ADDR(cs >> 1));
+	flm_writel(flash, 1, FLMm_CSn_SERASE(cs >> 1, cs & 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	wait_cond_adaptive(flash, size / 4096 * 3 * USEC_PER_MSEC, USEC_PER_SEC / HZ,
+			   FLMm_CSn_SERASE(cs >> 1, cs & 1), 0);
+
+	flm_writel(flash, 4, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	return 0;
+}
+
+/****************************************************************************/
+
+/*
+ * MTD implementation
+ */
+
+/*
+ * Erase an address range on the flash chip.  The address range may extend
+ * one or more erase sectors.  Return an error is there is a problem erasing.
+ */
+static int mn_nor_erase(struct mtd_info *mtd, struct erase_info *instr)
+{
+	struct mn_nor *flash = mtd_to_mn_nor(mtd);
+	u32 addr, len;
+	uint32_t rem;
+
+	mn_nor_log("%s: at 0x%llx, len %lld\n", dev_name(flash->dev),
+		   (long long)instr->addr, (long long)instr->len);
+
+	div_u64_rem(instr->len, mtd->erasesize, &rem);
+	if (rem)
+		return -EINVAL;
+
+	addr = instr->addr;
+	len = instr->len;
+
+	instr->state = MTD_ERASING;
+
+	mutex_lock(&mn_nor_mutex);
+
+	/* whole-chip erase? */
+	if (len == flash->mtd.size) {
+		if (erase_chip(flash)) {
+			instr->state = MTD_ERASE_FAILED;
+			mutex_unlock(&mn_nor_mutex);
+			return -EIO;
+		}
+
+	/* REVISIT in some cases we could speed up erasing large regions
+	 * by using OPCODE_SE instead of OPCODE_BE_4K.  We may have set up
+	 * to use "small sector erase", but that's not always optimal.
+	 */
+
+	/* "sector"-at-a-time erase */
+	} else {
+		while (len) {
+			if (erase_sector(flash, addr)) {
+				instr->state = MTD_ERASE_FAILED;
+				mutex_unlock(&mn_nor_mutex);
+				return -EIO;
+			}
+
+			addr += mtd->erasesize;
+			len -= mtd->erasesize;
+		}
+	}
+
+	mutex_unlock(&mn_nor_mutex);
+
+	instr->state = MTD_ERASE_DONE;
+	mtd_erase_callback(instr);
+
+	return 0;
+}
+
+/*
+ * Read an address range from the flash chip.  The address range
+ * may be any size provided it is within the physical boundaries.
+ */
+static int mn_nor_read(struct mtd_info *mtd, loff_t from, size_t len,
+		       size_t *retlen, u_char *buf)
+{
+	struct mn_nor *flash = mtd_to_mn_nor(mtd);
+	void __iomem *read_base;
+
+	mn_nor_log("%s: from 0x%08x, len 0x%x\n", dev_name(flash->dev), (u32)from, (u32)len);
+
+	mutex_lock(&mn_nor_mutex);
+
+	read_base = from + flash->mem_base;
+	memcpy(buf, read_base, len);
+
+	*retlen = len;
+
+	mutex_unlock(&mn_nor_mutex);
+
+	return 0;
+}
+
+/*
+ * Write an address range to the flash chip.  Data must be written in
+ * FLASH_PAGESIZE chunks.  The address range may be any size provided
+ * it is within the physical boundaries.
+ */
+
+#define BASE_WSS_UNIT_SIZE	8U
+#define MIN_WSS_UNIT_SIZE	32U
+#define MAX_WSS_UNIT_SIZE	512U
+
+static int mn_nor_aligned_write(struct mn_nor *flash, loff_t to, size_t len,
+				size_t *retlen, const u_char *buf)
+{
+	u32 cs = flash->cs;
+	phys_addr_t addr = to + flash->phys_mem_base;
+	u32 *data = (u32 *)buf;
+	unsigned int unit; /* 512, 256, 128, 64, 32 */
+	unsigned int order, i;
+
+	while (MIN_WSS_UNIT_SIZE <= len) {
+		/*
+		 * find the best unit size to satisfy restrictions of
+		 * dst(addr) alignment and src(len) size.
+		 */
+		order = min(__ffs(addr), __fls(len));
+		unit = 1U << order;
+		unit = min(unit, MAX_WSS_UNIT_SIZE);
+
+		mn_nor_log("to 0x%08x, len 0x%x, unit %d\n", addr, (u32)len, unit);
+
+		wss_writel(flash, (cs << 8) + ((unit >> 3) & 0x3f), WSS_CMD_SET);
+		wss_writel(flash, addr, WSS_ADDR_SET);
+		for (i = 0; i < (unit >> 2); i++)
+			wss_writel(flash, *data++, WSS_BWD(i));
+		wss_writel(flash, 1, WSS_CTL);
+
+		addr += unit;
+		len -= unit;
+		*retlen += unit;
+
+		do {
+			cond_resched();
+		} while (wss_readl(flash, WSS_CTL));
+	}
+
+	do {
+		cond_resched();
+	} while ((flm_readl(flash, FLMm_FLASH_MONITOR(cs >> 1)) & 0x0f) != 0);
+
+	return 0;
+}
+
+static int mn_nor_unaligned_write(struct mn_nor *flash, loff_t to, size_t len,
+				  size_t *retlen, const u_char *buf)
+{
+	u32 cs = flash->cs;
+	phys_addr_t addr = to + flash->phys_mem_base;
+	const unsigned int unit = BASE_WSS_UNIT_SIZE;
+	unsigned int bytes;
+
+	u64 tmp64;
+	u32 *ptr32 = (u32 *)&tmp64;
+	u8 *ptr8 = (u8 *)&tmp64;
+	unsigned int front_size;
+
+	unsigned int i;
+
+#ifdef MN_NOR_USE_LOG_MESSAGE
+	void __iomem *write_base = to + flash->mem_base;
+#endif
+
+	if ((addr & 0x03) || ((uintptr_t)buf & 0x03))
+		mn_nor_log("[CAUTION] unaligned\n");
+
+	while (len && ((addr & (MIN_WSS_UNIT_SIZE - 1)) ||
+		       ((uintptr_t)buf & 0x03) ||
+		       (len < MIN_WSS_UNIT_SIZE))) {
+#ifdef MN_NOR_USE_LOG_MESSAGE
+		volatile u64 *ptr64 = (volatile u64 *)((uintptr_t)write_base & ~((uintptr_t)(unit - 1)));
+#endif
+		mn_nor_log("to 0x%08x, len 0x%x, buf 0x%08x\n", addr, (u32)len, (u32)buf);
+
+		front_size = addr & (unit - 1);
+		bytes = unit - front_size;
+
+		if (len < bytes)
+			bytes = len;
+
+		tmp64 = ~0ULL;
+		memcpy(ptr8 + front_size, buf, bytes);
+
+		mn_nor_log("data:   0x%016llx\n", __swab64(tmp64));
+		mn_nor_log("before: 0x%016llx\n", __swab64(*ptr64));
+
+		wss_writel(flash, (cs << 8) + ((unit >> 3) & 0x3f), WSS_CMD_SET);
+		wss_writel(flash, addr & ~(unit - 1), WSS_ADDR_SET);
+		for (i = 0; i < (unit >> 2); i++)
+			wss_writel(flash, ptr32[i], WSS_BWD(i));
+		wss_writel(flash, 1, WSS_CTL);
+
+#ifdef MN_NOR_USE_LOG_MESSAGE
+		write_base += bytes;
+#endif
+		buf += bytes;
+		addr += bytes;
+		len -= bytes;
+		*retlen += bytes;
+
+		do {
+			cond_resched();
+		} while (wss_readl(flash, WSS_CTL));
+
+		mn_nor_log("after:  0x%016llx\n", __swab64(*ptr64));
+	}
+
+	do {
+		cond_resched();
+	} while ((flm_readl(flash, FLMm_FLASH_MONITOR(cs >> 1)) & 0x0f) != 0);
+
+	return 0;
+}
+
+static int mn_nor_write(struct mtd_info *mtd, loff_t to, size_t len,
+			size_t *retlen, const u_char *buf)
+{
+	struct mn_nor *flash = mtd_to_mn_nor(mtd);
+	u32 cs = flash->cs;
+
+	mn_nor_log("%s: to 0x%08x, len 0x%x\n", dev_name(flash->dev), (u32)to, (u32)len);
+
+	mutex_lock(&mn_nor_mutex);
+
+	flm_writel(flash, 6, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, 1, FLMm_FLASH_MODE(cs >> 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	mn_nor_unaligned_write(flash, to, len, retlen, buf);
+
+	if (len - *retlen)
+		mn_nor_aligned_write(flash, to + *retlen, len - *retlen, retlen, buf + *retlen);
+
+	if (len - *retlen)
+		mn_nor_unaligned_write(flash, to + *retlen, len - *retlen, retlen, buf + *retlen);
+
+	flm_writel(flash, 4, FLMm_SFLASH_WRENCMD(cs >> 1));
+	flm_writel(flash, 1, FLMm_REG_SET(cs >> 1));
+
+	mutex_unlock(&mn_nor_mutex);
+
+	mn_nor_log("%s: to 0x%08x, retlen 0x%x\n", dev_name(flash->dev), (u32)to, *retlen);
+
+	return 0;
+}
+
+/****************************************************************************/
+
+/*
+ * device driver setup and teardown
+ */
+
+struct flash_info {
+	/* JEDEC id zero means "no ID" (most older chips); otherwise it has
+	 * a high byte of zero plus three data bytes: the manufacturer id,
+	 * then a two byte device id.
+	 */
+	u32		jedec_id;
+	u16		ext_id;
+
+	/* The size listed here is what works with OPCODE_SE, which isn't
+	 * necessarily called a "sector" by the vendor.
+	 */
+	unsigned	sector_size;
+	u16		n_sectors;
+
+	u16		page_size;
+	u16		addr_width;
+
+	u16		flags;
+#define SECT_4K			0x01	/* OPCODE_BE_4K works uniformly */
+#define MN_NOR_NO_ERASE		0x02	/* No erase command needed */
+#define SST_WRITE		0x04	/* use SST byte programming */
+#define MN_NOR_NO_FR		0x08	/* Can't do fastread */
+#define SECT_4K_PMC		0x10	/* OPCODE_BE_4K_PMC works uniformly */
+#define MN_NOR_QUAD_READ	0x20	/* Flash supports Quad Read */
+};
+
+#define MN_NOR_NAME_SIZE	32
+
+struct mn_nor_device_id {
+	char name[MN_NOR_NAME_SIZE];
+	kernel_ulong_t driver_data;	/* Data private to the driver */
+};
+
+#define INFO(_jedec_id, _ext_id, _sector_size, _n_sectors, _flags)	\
+	((kernel_ulong_t)&(struct flash_info) {				\
+		.jedec_id = (_jedec_id),				\
+		.ext_id = (_ext_id),					\
+		.sector_size = (_sector_size),				\
+		.n_sectors = (_n_sectors),				\
+		.page_size = 256,					\
+		.flags = (_flags),					\
+	})
+
+#define CAT25_INFO(_sector_size, _n_sectors, _page_size, _addr_width, _flags)	\
+	((kernel_ulong_t)&(struct flash_info) {				\
+		.sector_size = (_sector_size),				\
+		.n_sectors = (_n_sectors),				\
+		.page_size = (_page_size),				\
+		.addr_width = (_addr_width),				\
+		.flags = (_flags),					\
+	})
+
+/* NOTE: double check command sets and memory organization when you add
+ * more flash chips.  This current list focusses on newer chips, which
+ * have been converging on command sets which including JEDEC ID.
+ */
+static const struct mn_nor_device_id mn_nor_ids[] = {
+	/* Macronix */
+	{ "mx25l25635e", INFO(0xc22019, 0, 64 * 1024, 512, 0) },
+
+	/* Spansion -- single (large) sector size only, at least
+	 * for the chips listed here (without boot sectors).
+	 */
+	{ "s25fl256s0", INFO(0x010219, 0x4d00, 256 * 1024, 128, 0) },
+	{ },
+};
+MODULE_DEVICE_TABLE(mn_nor, mn_nor_ids);
+
+static const struct mn_nor_device_id *mn_nor_read_id(struct mn_nor *flash)
+{
+	int tmp;
+	u16 code = OPCODE_RDID;
+	u8 id[5 * MAX_NUMCHIPS];
+	u32 jedec;
+	u16 ext_jedec;
+	struct flash_info *info;
+
+	u32 numchips = flash->numchips;
+
+	/* JEDEC also defines an optional "extended device information"
+	 * string for after vendor-specific data, after the three bytes
+	 * we use here.  Supporting some chips might require using it.
+	 */
+	tmp = mn_nor_write_then_read(flash, &code, 1, id, 5 * numchips);
+	if (tmp < 0) {
+		mn_nor_log("%s: error %d reading JEDEC ID\n", dev_name(flash->dev), tmp);
+		return ERR_PTR(tmp);
+	}
+
+	/* don't check chips are same. get first only */
+	jedec = id[0 * numchips];
+	jedec = jedec << 8;
+	jedec |= id[1 * numchips];
+	jedec = jedec << 8;
+	jedec |= id[2 * numchips];
+
+	ext_jedec = id[3 * numchips] << 8 | id[4 * numchips];
+
+	for (tmp = 0; tmp < ARRAY_SIZE(mn_nor_ids) - 1; tmp++) {
+		info = (void *)mn_nor_ids[tmp].driver_data;
+		if (info->jedec_id == jedec) {
+			if (info->ext_id != 0 && info->ext_id != ext_jedec)
+				continue;
+			return &mn_nor_ids[tmp];
+		}
+	}
+	dev_err(flash->dev, "unrecognized JEDEC id %06x\n", jedec);
+	return ERR_PTR(-ENODEV);
+}
+
+
+static int mn_nor_probe(struct platform_device *pdev)
+{
+	const struct mn_nor_device_id *id = NULL, *tmp_id;
+	struct mn_nor *flash;
+	struct flash_info *info;
+	unsigned int i;
+	struct mtd_part_parser_data ppdata;
+	struct device_node *np = pdev->dev.of_node;
+	int ret;
+
+	static const char *part_probe_types[] = { "ofpart", NULL };
+
+	const char *name;
+	struct resource *mem_regs;
+	unsigned int cs;
+
+	u32 clk = 0;	/* clock 0:100MHz, 1:50MHz, 2:25MHz */
+	u32 rc = 0;	/* cmd   0:fast read, 1:normal read */
+	u32 at = 7;	/* mode  0:Single, 5:Dual, 7:Quad */
+
+	flash = devm_kzalloc(&pdev->dev, sizeof(*flash), GFP_KERNEL);
+	if (!flash)
+		return -ENOMEM;
+
+
+	flash->dev = &pdev->dev;
+	platform_set_drvdata(pdev, flash);
+
+	if (of_property_read_u32(np, "num-cs", &cs))
+		return -ENOENT;
+	flash->cs = cs;
+
+	mutex_lock(&mn_nor_mutex);
+
+	/* devm_ioremap_resource() can't map the memory multiple times,
+	 * so call of_iomap()
+	 */
+	flash->flm_base = of_iomap(np, 1);
+	if (!flash->flm_base) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	flash->wss_base = of_iomap(np, 2);
+	if (!flash->wss_base) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	flash->sys_base = of_iomap(np, 3);
+	if (!flash->sys_base) {
+		ret = -EIO;
+		goto fail;
+	}
+
+
+	flash->numchips = flm_readl(flash, FLMm_SFLASH_NUM(cs >> 1));
+	flash->modifier = (flash->numchips == 2) ? 0x0101 : 0x0001;
+
+	/* search nor flash chip */
+	name = of_get_property(np, "type", NULL);
+	if (!name) {
+		ret = -ENOENT;
+		goto fail;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(mn_nor_ids) - 1; i++) {
+		tmp_id = &mn_nor_ids[i];
+		if (strcmp(name, tmp_id->name))
+			continue;
+		id = tmp_id;
+		break;
+	}
+
+	if (!id) {
+		ret = -ENOENT;
+		goto fail;
+	}
+
+	info = (void *)id->driver_data;
+
+	if (info->jedec_id) {
+		const struct mn_nor_device_id *jid;
+
+		jid = mn_nor_read_id(flash);
+		if (IS_ERR(jid)) {
+			ret = PTR_ERR(jid);
+			goto fail;
+		} else if (jid != id) {
+			/*
+			 * JEDEC knows better, so overwrite platform ID. We
+			 * can't trust partitions any longer, but we'll let
+			 * mtd apply them anyway, since some partitions may be
+			 * marked read-only, and we don't want to lose that
+			 * information, even if it's not 100% accurate.
+			 */
+			dev_err(&pdev->dev, "found %s, expected %s\n",
+				jid->name, id->name);
+			ret = -EINVAL;
+			goto fail;
+		}
+	}
+
+	flash->mtd.name = dev_name(&pdev->dev);
+	flash->mtd.type = MTD_NORFLASH;
+#if 1
+	flash->mtd.writesize = 1;
+	flash->mtd.flags = MTD_CAP_NORFLASH;
+#else /* make jffs2 use w_buf */
+	flash->mtd.writesize = info->page_size * flash->numchips;
+	flash->mtd.flags = MTD_WRITEABLE;
+#endif
+	flash->mtd.size = info->sector_size * flash->numchips * info->n_sectors;
+	flash->mtd._erase = mn_nor_erase;
+	flash->mtd._read = mn_nor_read;
+	flash->mtd._write = mn_nor_write;
+	flash->mtd.erasesize = info->sector_size * flash->numchips;
+
+	ppdata.of_node = pdev->dev.of_node;
+	flash->mtd.dev.parent = &pdev->dev;
+	flash->page_size = info->page_size * flash->numchips;
+	/* FIXME: right? 512? ubi uses this. */
+	flash->mtd.writebufsize = flash->page_size * flash->numchips;
+
+	clk = flm_readl(flash, FLMm_SFLASH_CLK(cs >> 1));
+	clk = (clk == 3) ? 2 : clk;
+	rc = flm_readl(flash, FLMm_SFLASH_FAST(cs >> 1));
+	at = flm_readl(flash, FLMm_SFLASH_MODE(cs >> 1));
+
+#if 0
+	/* FIXME: head.S or bootloader or uITRON or stay? */
+	/* disable memory write */
+	u32 tmp = sys_readl(flash, NIC_WRFBDn_START(cs));
+	tmp &= ~0x80000000;
+	sys_writel(flash, tmp, NIC_WRFBDn_START(cs));
+#endif
+
+	mem_regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!mem_regs) {
+		ret = -ENOENT;
+		goto fail;
+	}
+	flash->phys_mem_base = mem_regs->start;
+
+	if (flash->mtd.size < resource_size(mem_regs)) {
+		dev_err(&pdev->dev, "flash->mtd.size (0x%08x) < resource_size(mem_regs) (0x%08x)\n",
+			(u32)flash->mtd.size, (u32)resource_size(mem_regs));
+		ret = -EINVAL;
+		goto fail;
+	}
+	if (flash->mtd.size != resource_size(mem_regs)) {
+		dev_info(&pdev->dev, "flash->mtd.size (0x%08x) != resource_size(mem_regs) (0x%08x)\n",
+			 (u32)flash->mtd.size, (u32)resource_size(mem_regs));
+	}
+
+	flash->mem_base = of_iomap(np, 0);
+	if (!flash->mem_base) {
+		ret = -EIO;
+		goto fail;
+	}
+
+	mutex_unlock(&mn_nor_mutex);
+
+	dev_info(&pdev->dev, "%s (%lld Kbytes), clk=%d, rc=%d, at=%d\n",
+		 id->name, (long long)flash->mtd.size >> 10, clk, rc, at);
+
+	pr_debug("mtd .name = %s, .size = 0x%llx (%lldMiB) "
+			".erasesize = 0x%.8x (%uKiB) .numeraseregions = %d\n",
+		flash->mtd.name,
+		(long long)flash->mtd.size, (long long)(flash->mtd.size >> 20),
+		flash->mtd.erasesize, flash->mtd.erasesize / 1024,
+		flash->mtd.numeraseregions);
+
+	if (flash->mtd.numeraseregions)
+		for (i = 0; i < flash->mtd.numeraseregions; i++)
+			pr_debug("mtd.eraseregions[%d] = { .offset = 0x%llx, "
+				".erasesize = 0x%.8x (%uKiB), "
+				".numblocks = %d }\n",
+				i, (long long)flash->mtd.eraseregions[i].offset,
+				flash->mtd.eraseregions[i].erasesize,
+				flash->mtd.eraseregions[i].erasesize / 1024,
+				flash->mtd.eraseregions[i].numblocks);
+
+
+	/* partitions should match sector boundaries; and it may be good to
+	 * use readonly partitions for writeprotected sectors (BP2..BP0).
+	 */
+	ret = mtd_device_parse_register(&flash->mtd, part_probe_types, &ppdata, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to add partitions with error %d\n", ret);
+		goto fail_unlocked;
+	}
+
+	return 0;
+
+fail:
+	mutex_unlock(&mn_nor_mutex);
+
+fail_unlocked:
+	if (flash->mem_base)
+		iounmap(flash->mem_base);
+
+	if (flash->flm_base)
+		iounmap(flash->flm_base);
+
+	if (flash->wss_base)
+		iounmap(flash->wss_base);
+
+	if (flash->sys_base)
+		iounmap(flash->sys_base);
+
+	return ret;
+}
+
+
+static int mn_nor_remove(struct platform_device *pdev)
+{
+	struct mn_nor	*flash = platform_get_drvdata(pdev);
+
+	iounmap(flash->mem_base);
+	iounmap(flash->flm_base);
+	iounmap(flash->wss_base);
+	iounmap(flash->sys_base);
+
+	/* Clean up MTD stuff. */
+	return mtd_device_unregister(&flash->mtd);
+}
+
+
+static const struct of_device_id mn_nor_of_dt_ids[] = {
+	{.compatible = "panasonic,mn-nor", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mn_nor_of_dt_ids);
+
+static struct platform_driver mn_nor_driver = {
+	.driver = {
+		.name	= "mn-nor",
+		.of_match_table = mn_nor_of_dt_ids,
+		.owner	= THIS_MODULE,
+	},
+	.probe	= mn_nor_probe,
+	.remove	= mn_nor_remove,
+
+	/* REVISIT: many of these chips have deep power-down modes, which
+	 * should clearly be entered on suspend() to minimize power use.
+	 * And also when they're otherwise idle...
+	 */
+};
+
+module_platform_driver(mn_nor_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Panasonic Corporation");
+MODULE_DESCRIPTION("Panasonic SOCs NOR FLASH Driver");
diff -uNr linux-3.14.19/drivers/net/ethernet/smsc/smsc911x.c linux-gerda/drivers/net/ethernet/smsc/smsc911x.c
--- linux-3.14.19/drivers/net/ethernet/smsc/smsc911x.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/net/ethernet/smsc/smsc911x.c	2017-06-22 09:52:49.963039335 +0900
@@ -1628,9 +1628,11 @@
 	dev->stats.rx_dropped += smsc911x_reg_read(pdata, RX_DROP);
 	smsc911x_tx_update_txcounters(dev);
 
+#ifndef CONFIG_MACH_GERDAC /* smsc is always powered */
 	/* Bring the PHY down */
 	if (pdata->phy_dev)
 		phy_stop(pdata->phy_dev);
+#endif
 
 	SMSC_TRACE(pdata, ifdown, "Interface stopped");
 	return 0;
@@ -2318,6 +2320,138 @@
 	.tx_writefifo = smsc911x_tx_writefifo_shift,
 };
 
+#ifdef CONFIG_MACH_GERDAC
+
+#define FLM2_PFLASH_ACC	(0x130)
+#define FLM2_PFLASH_ADR	(0x134)
+#define FLM2_PFLASH_WDT	(0x13c)
+#define FLM2_PFLASH_RDT	(0x140)
+#define FLM2_SP_REG_SET (0x148)
+
+static inline u16 _gerdac_smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)
+{
+	unsigned int timeout;
+
+	/* set read operation */
+	writel(0x0,pdata->ioaddr + FLM2_PFLASH_ACC);
+
+	/* set reg address */
+	writel(reg,pdata->ioaddr + FLM2_PFLASH_ADR);
+
+	/* issu read command */
+	writel(0x1,pdata->ioaddr + FLM2_SP_REG_SET);
+
+	timeout = 10;
+	while (timeout--){
+		if (readl(pdata->ioaddr + FLM2_SP_REG_SET) == 0)
+			break;
+		mdelay(1);
+	}
+
+	if (timeout <= 0){
+		SMSC_WARN(pdata, hw, "Timeout reading regsiter.");
+		return 0;
+	}else {
+		return readw(pdata->ioaddr + FLM2_PFLASH_RDT);
+	}
+}
+
+static inline void _gerdac_smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg, u16 val)
+{
+	unsigned int timeout;
+
+	/* set write operation */
+	writel(0x1,pdata->ioaddr + FLM2_PFLASH_ACC);
+
+	/* set reg address */
+	writel(reg,pdata->ioaddr + FLM2_PFLASH_ADR);
+
+	/* set write data*/
+	writel(val,pdata->ioaddr + FLM2_PFLASH_WDT);
+
+	/* issu write command */
+	writel(0x1,pdata->ioaddr + FLM2_SP_REG_SET);
+
+	timeout = 10;
+	while (timeout--){
+		if (readl(pdata->ioaddr + FLM2_SP_REG_SET) == 0)
+			break;
+		mdelay(1);
+	}
+
+	if (timeout <=0 )
+		SMSC_WARN(pdata, hw, "Timeout writing regsiter.");
+
+	return;
+}
+
+
+static inline u32 gerdac_smsc911x_reg_read(struct smsc911x_data *pdata, u32 reg)
+{
+	if (pdata->config.flags & SMSC911X_USE_16BIT) {
+		return ((_gerdac_smsc911x_reg_read(pdata,reg) & 0xFFFF ) | 
+			((_gerdac_smsc911x_reg_read(pdata,reg + 2) & 0xFFFF) << 16));
+	}
+
+	BUG();
+	return 0;
+}
+
+static inline void gerdac_smsc911x_reg_write(struct smsc911x_data *pdata, u32 reg, u32 val)
+{
+	if (pdata->config.flags & SMSC911X_USE_16BIT) {
+		_gerdac_smsc911x_reg_write(pdata,reg,val & 0xFFFF);	
+		_gerdac_smsc911x_reg_write(pdata,reg + 2, (val >> 16 ) & 0xFFFF);	
+
+		return;
+	}
+	BUG();
+}
+
+static inline void gerdac_smsc911x_rx_readfifo(struct smsc911x_data *pdata, unsigned int *buf,
+		     unsigned int wordcount)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pdata->dev_lock, flags);
+
+	if (pdata->config.flags & SMSC911X_USE_16BIT) {
+		while (wordcount--)
+			*buf++ = gerdac_smsc911x_reg_read(pdata, RX_DATA_FIFO);
+		goto out;
+	}
+
+	BUG();
+out:
+	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+}
+
+static inline void gerdac_smsc911x_tx_writefifo(struct smsc911x_data *pdata, unsigned int *buf,
+		      unsigned int wordcount)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pdata->dev_lock, flags);
+
+	if (pdata->config.flags & SMSC911X_USE_16BIT) {
+		while (wordcount--)
+			gerdac_smsc911x_reg_write(pdata, TX_DATA_FIFO, *buf++);
+		goto out;
+	}
+
+	BUG();
+out:
+	spin_unlock_irqrestore(&pdata->dev_lock, flags);
+}
+
+static const struct smsc911x_ops gerdac_smsc911x_ops = {
+	.reg_read = gerdac_smsc911x_reg_read,
+	.reg_write = gerdac_smsc911x_reg_write,
+	.rx_readfifo = gerdac_smsc911x_rx_readfifo,
+	.tx_writefifo = gerdac_smsc911x_tx_writefifo,
+};
+#endif /* CONFIG_MACH_GERDAC */
+
 #ifdef CONFIG_OF
 static int smsc911x_probe_config_dt(struct smsc911x_platform_config *config,
 				    struct device_node *np)
@@ -2448,11 +2582,16 @@
 		goto out_disable_resources;
 	}
 
+#ifndef CONFIG_MACH_GERDAC
 	/* assume standard, non-shifted, access to HW registers */
 	pdata->ops = &standard_smsc911x_ops;
 	/* apply the right access if shifting is needed */
 	if (pdata->config.shift)
 		pdata->ops = &shifted_smsc911x_ops;
+#else
+	/* assume non-shifted, access to HW registers */
+	pdata->ops = &gerdac_smsc911x_ops;
+#endif
 
 	retval = smsc911x_init(dev);
 	if (retval < 0)
diff -uNr linux-3.14.19/drivers/tty/serial/8250/8250.h linux-gerda/drivers/tty/serial/8250/8250.h
--- linux-3.14.19/drivers/tty/serial/8250/8250.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/8250.h	2017-06-22 09:52:45.859039457 +0900
@@ -13,6 +13,9 @@
 
 #include <linux/serial_8250.h>
 #include <linux/dmaengine.h>
+#ifdef CONFIG_SERIAL_8250_MN
+#include "8250_mn.h"
+#endif
 
 struct uart_8250_dma {
 	dma_filter_fn		fn;
@@ -40,6 +43,8 @@
 	size_t			tx_size;
 
 	unsigned char		tx_running:1;
+	unsigned char		tx_err: 1;
+	unsigned char           rx_running:1;
 };
 
 struct old_serial_port {
@@ -186,3 +191,9 @@
 }
 static inline void serial8250_release_dma(struct uart_8250_port *p) { }
 #endif
+
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+extern void serial8250_mn_set_dsize(void *port, u32 dsize);
+extern u32 serial8250_mn_get_dsize(void *port);
+extern void serial8250_mn_timeout(unsigned long data);
+#endif
diff -uNr linux-3.14.19/drivers/tty/serial/8250/8250_core.c linux-gerda/drivers/tty/serial/8250/8250_core.c
--- linux-3.14.19/drivers/tty/serial/8250/8250_core.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/8250_core.c	2017-06-22 09:52:45.859039457 +0900
@@ -46,6 +46,7 @@
 #include <asm/irq.h>
 
 #include "8250.h"
+#include <asm/rt3.h>
 
 /*
  * Configuration:
@@ -323,6 +324,20 @@
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
 		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
 	},
+	[PORT_MN] = {
+		.name		= "Panasonic SOCs",
+		.fifo_size	= 8,
+		.tx_loadsz	= 8,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01,
+		.flags		= UART_CAP_FIFO,
+	},
+	[PORT_MN_STRM] = {
+		.name		= "Panasonic SOCs STREAM UART",
+		.fifo_size	= 8,
+		.tx_loadsz	= 8,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
+		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
+	},
 };
 
 /* Uart divisor latch read */
@@ -655,7 +670,11 @@
 
 	old_lcr = serial_in(up, UART_LCR);
 	serial_out(up, UART_LCR, 0);
-	old_fcr = serial_in(up, UART_FCR);
+	if (up->port.type == PORT_MN_STRM)
+		old_fcr = serial_in(up, MN_UART_FCR);
+	else
+		old_fcr = serial_in(up, UART_FCR);
+
 	old_mcr = serial_in(up, UART_MCR);
 	serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO |
 		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
@@ -2172,6 +2191,15 @@
 		}
 	}
 
+	if (port->type == PORT_MN_STRM) {
+		up->iir = -1;
+		up->lsr = -1;
+		up->timer.function = serial8250_mn_timeout;
+		up->timer.data = (unsigned long)up;
+
+		mod_timer(&up->timer, jiffies + uart_poll_timeout(port));
+	}
+
 	/*
 	 * Finally, enable interrupts.  Note: Modem status interrupts
 	 * are set via set_termios(), which will be occurring imminently
@@ -2336,10 +2364,14 @@
 	 * have sufficient FIFO entries for the latency of the remote
 	 * UART to respond.  IOW, at least 32 bytes of FIFO.
 	 */
-	if (up->capabilities & UART_CAP_AFE && port->fifosize >= 32) {
+	if (up->capabilities & UART_CAP_AFE && port->fifosize >= ((port->type == PORT_MN_STRM) ? 8: 32)) {
 		up->mcr &= ~UART_MCR_AFE;
-		if (termios->c_cflag & CRTSCTS)
+		if (termios->c_cflag & CRTSCTS) {
 			up->mcr |= UART_MCR_AFE;
+			if (port->type == PORT_MN_STRM && (fcr & UART_FCR_TRIGGER_MASK) == UART_FCR_R_TRIG_00) {
+				fcr |= UART_FCR_R_TRIG_01;
+			}
+		}
 	}
 
 	/*
@@ -3268,6 +3300,7 @@
 		uart->port.fifosize	= up->port.fifosize;
 		uart->tx_loadsz		= up->tx_loadsz;
 		uart->capabilities	= up->capabilities;
+		uart->lsirevision	= up->lsirevision;
 
 		/* Take tx_loadsz from fifosize if it wasn't set separately */
 		if (uart->port.fifosize && !uart->tx_loadsz)
diff -uNr linux-3.14.19/drivers/tty/serial/8250/8250_dma.c linux-gerda/drivers/tty/serial/8250/8250_dma.c
--- linux-3.14.19/drivers/tty/serial/8250/8250_dma.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/8250_dma.c	2017-06-22 09:52:45.859039457 +0900
@@ -13,6 +13,7 @@
 #include <linux/serial_reg.h>
 #include <linux/dma-mapping.h>
 
+#include <asm/rt3.h>
 #include "8250.h"
 
 static void __dma_tx_complete(void *param)
@@ -53,10 +54,12 @@
 	dma_sync_single_for_cpu(dma->rxchan->device->dev, dma->rx_addr,
 				dma->rx_size, DMA_FROM_DEVICE);
 
+	dma->rx_running = 0;
 	dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
 	dmaengine_terminate_all(dma->rxchan);
 
 	count = dma->rx_size - state.residue;
+	_TRC_usr_log_ext(0xf1, count);
 
 	tty_insert_flip_string(tty_port, dma->rx_buf, count);
 	p->port.icount.rx += count;
@@ -84,7 +87,6 @@
 		return -EBUSY;
 
 	dma->tx_running = 1;
-
 	desc->callback = __dma_tx_complete;
 	desc->callback_param = p;
 
@@ -103,10 +105,6 @@
 {
 	struct uart_8250_dma		*dma = p->dma;
 	struct dma_async_tx_descriptor	*desc;
-	struct dma_tx_state		state;
-	int				dma_status;
-
-	dma_status = dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
 
 	switch (iir & 0x3f) {
 	case UART_IIR_RLSI:
@@ -117,7 +115,7 @@
 		 * If RCVR FIFO trigger level was not reached, complete the
 		 * transfer and let 8250_core copy the remaining data.
 		 */
-		if (dma_status == DMA_IN_PROGRESS) {
+		if (dma->rx_running) {
 			dmaengine_pause(dma->rxchan);
 			__dma_rx_complete(p);
 		}
@@ -126,7 +124,7 @@
 		break;
 	}
 
-	if (dma_status)
+	if (dma->rx_running)
 		return 0;
 
 	desc = dmaengine_prep_slave_single(dma->rxchan, dma->rx_addr,
@@ -135,6 +133,7 @@
 	if (!desc)
 		return -EBUSY;
 
+	dma->rx_running = 1;
 	desc->callback = __dma_rx_complete;
 	desc->callback_param = p;
 
@@ -158,6 +157,11 @@
 	dma->rxconf.direction		= DMA_DEV_TO_MEM;
 	dma->rxconf.src_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
 	dma->rxconf.src_addr		= p->port.mapbase + UART_RX;
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	dma->rxconf.setsize		= serial8250_mn_set_dsize;
+	dma->rxconf.getsize		= serial8250_mn_get_dsize;
+	dma->rxconf.size_param		= p;
+#endif
 
 	dma->txconf.direction		= DMA_MEM_TO_DEV;
 	dma->txconf.dst_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
@@ -192,21 +196,29 @@
 
 	dma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev, dma->rx_size,
 					&dma->rx_addr, GFP_KERNEL);
-	if (!dma->rx_buf) {
-		dma_release_channel(dma->rxchan);
-		dma_release_channel(dma->txchan);
-		return -ENOMEM;
-	}
+	if (!dma->rx_buf)
+		goto err;
 
 	/* TX buffer */
 	dma->tx_addr = dma_map_single(dma->txchan->device->dev,
 					p->port.state->xmit.buf,
 					UART_XMIT_SIZE,
 					DMA_TO_DEVICE);
+	dma->tx_running = 0;
 
+	if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
+		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
+				  dma->rx_buf, dma->rx_addr);
+		goto err;
+	}
 	dev_dbg_ratelimited(p->port.dev, "got both dma channels\n");
 
 	return 0;
+err:
+	dma_release_channel(dma->rxchan);
+	dma_release_channel(dma->txchan);
+
+	return -ENOMEM;
 }
 EXPORT_SYMBOL_GPL(serial8250_request_dma);
 
@@ -223,6 +235,7 @@
 			  dma->rx_addr);
 	dma_release_channel(dma->rxchan);
 	dma->rxchan = NULL;
+	dma->rx_running = 0;
 
 	/* Release TX resources */
 	dmaengine_terminate_all(dma->txchan);
diff -uNr linux-3.14.19/drivers/tty/serial/8250/8250_mn.c linux-gerda/drivers/tty/serial/8250/8250_mn.c
--- linux-3.14.19/drivers/tty/serial/8250/8250_mn.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/8250_mn.c	2017-06-22 09:52:45.859039457 +0900
@@ -0,0 +1,1045 @@
+/*
+ * Panasonic SOCs 8250 Driver
+ *
+ *  Copyright (C) 2014 Panasonic Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Derived from drivers/tty/serial/8250/8250_em.c
+ */
+
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+#include <linux/slab.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+
+#include "8250.h"
+#include <asm/rt3.h>
+
+#define MN_UART_HWCTRL_ENABLE		1
+#define MN_UART_HWCTRL_DISABLE		0
+
+#if 0
+#define DEBUG_INTR(fmt...)      printk(fmt)
+#else
+#define DEBUG_INTR(fmt...)      do { } while (0)
+#endif
+
+struct serial8250_mn_priv {
+	struct clk *clk;
+	int line;
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	struct uart_8250_dma dma;
+	int dma_type;
+	int hw_ctrl;
+#endif
+};
+
+#define DIV_ROUND_CLOSEST_ULL(x, divisor)(              \
+{                                                       \
+        typeof(divisor) __d = divisor;                  \
+        unsigned long long _tmp = (x) + (__d) / 2;      \
+        do_div(_tmp, __d);                              \
+        _tmp;                                           \
+}                                                       \
+)
+
+
+static void serial8250_mn_serial_out(struct uart_port *p, int offset, int value);
+static unsigned int serial8250_mn_serial_in(struct uart_port *p, int offset);
+static int serial8250_mn_serial_dl_read(struct uart_8250_port *up);
+static void serial8250_mn_serial_dl_write(struct uart_8250_port *up, int value);
+static int serial8250_mn_es2_serial_dl_read(struct uart_8250_port *up);
+static void serial8250_mn_es2_serial_dl_write(struct uart_8250_port *up, int value);
+static int of_platform_serial_setup(struct platform_device *ofdev, int type,
+				    struct uart_port *port, struct serial8250_mn_priv *priv);
+static int serial8250_mn_probe(struct platform_device *pdev);
+static int serial8250_mn_remove(struct platform_device *pdev);
+static int serial8250_mn_get_lsirevision(struct platform_device *pdev);
+
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+static void serial8250_mn_setup_dma(struct uart_port *port,
+			struct serial8250_mn_priv *priv);
+void serial8250_mn_set_dsize(void *port, u32 dsize);
+u32 serial8250_mn_get_dsize(void *port);
+static bool serial8250_mn_dma_filter(struct dma_chan *chan, void *param);
+static void serial8250_mn_serial_out_dma(struct uart_8250_port *up, u32 offset, u32 value);
+static unsigned int serial8250_mn_serial_in_dma(struct uart_8250_port *up, u32 offset);
+static int serial8250_mn_handle_irq(struct uart_port *port, unsigned int iir);
+#endif
+/**
+ * Reading of CHIPREVST register
+ *
+ * @param ofdev         Platform device
+ * @retval 0            Success
+ * @retval -ENOMEM      Memory map could not be acquired
+ */
+static int serial8250_mn_get_lsirevision(struct platform_device *ofdev)
+{
+	unsigned char __iomem   *revreg;
+	int	lsiver;
+
+	revreg = ioremap(CHIPREVST_ADDR, CHIPREVST_SIZE);
+	if (revreg == 0) {
+		dev_err(&ofdev->dev, "[mn] failed to ioremap CHIPREVST\n");
+		return  -ENOMEM;
+	}
+
+	lsiver = __raw_readl(revreg);
+
+	iounmap(revreg);
+
+	return lsiver;
+}
+
+/**
+ * Set value to UART register
+ *
+ * @param p       UART port
+ * @param offset  UART register offset
+ * @param value   Set value
+ *
+ * @attention The argument offset is to be converted to match the specification
+ *            of the UART registers.
+ */
+static void serial8250_mn_serial_out(struct uart_port *p, int offset, int value)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+
+	switch (offset) {
+	case UART_TX:
+		writeb_relaxed(value, p->membase);
+		break;
+	case UART_IER:
+		writel_relaxed(value, p->membase + MN_UART_IER);
+		break;
+	case UART_FCR:
+		writel_relaxed(value, p->membase + MN_UART_FCR);
+		break;
+	case UART_LCR:
+		value = (value & ~UART_LCR_DLAB) << 8U;
+		value |= readl_relaxed(p->membase + MN_UART_LCR) & 0x00ffU;
+		writel_relaxed(value, p->membase + MN_UART_LCR);
+		break;
+	case UART_MCR:
+		value &= ~(UART_MCR_DTR | UART_MCR_OUT1 | UART_MCR_OUT2);
+		value |= readl_relaxed(p->membase + MN_UART_MCR) & 0xff00U;
+		writel_relaxed(value, p->membase + MN_UART_MCR);
+		break;
+	case UART_SCR:
+		break;
+#if 1
+	case MN_UART_DSIZL:
+	case MN_UART_DSIZH:
+	case MN_UART_TFD:
+	case MN_UART_RFD:
+	case MN_UART_DMACR:
+	case MN_UART_DDIR:
+	case MN_UART_WBUFNUM:
+	case MN_UART_RBUFNUM:
+		serial8250_mn_serial_out_dma(up, offset, value);
+		break;
+#endif
+	default:
+		break;
+	}
+}
+
+/**
+ * Get value from UART register
+ *
+ * @param p       UART port
+ * @param offset  UART register offset
+ * @return        Get value
+ *
+ * @attention The argument offset is to be converted to match the specification
+ *            of the UART registers.
+ */
+static unsigned int serial8250_mn_serial_in(struct uart_port *p, int offset)
+{
+	struct uart_8250_port *up =
+		container_of(p, struct uart_8250_port, port);
+
+	switch (offset) {
+	case UART_RX:
+		return readb_relaxed(p->membase);
+	case UART_IIR:
+		if (up->iir == -1) {
+			return readb_relaxed(p->membase + (offset << 2U));
+		} else {
+			unsigned int iir = readb_relaxed(p->membase + (offset << 2U));
+			iir &= ~UART_IIR_NO_INT;
+			iir |= up->iir;
+			up->iir = -1;
+			return iir;
+		}
+	case UART_LSR:
+		if (up->lsr == -1) {
+			return readb_relaxed(p->membase + (offset << 2U));
+		} else {
+			unsigned int lsr = readb_relaxed(p->membase + (offset << 2U));
+			lsr |= up->lsr;
+			up->lsr = -1;
+			return lsr;
+		}
+	case UART_MSR:
+	case UART_IER:
+		return readl_relaxed(p->membase + (offset << 2U));
+	case UART_LCR:
+		return readl_relaxed(p->membase + MN_UART_LCR) >> 8U;
+	case UART_MCR:
+		return readl_relaxed(p->membase + MN_UART_MCR) & 0x00ffU;
+	case UART_SCR:
+		return (unsigned int)p->membase;
+#if 1
+	case MN_UART_FCR:
+	case MN_UART_LCR:
+	case MN_UART_RX_LG:
+	case MN_UART_TFD:
+	case MN_UART_RFD:
+	case MN_UART_DMACR:
+	case MN_UART_DDIR:
+	case MN_UART_DSIZL:
+	case MN_UART_DSIZH:
+	case MN_UART_WBUFNUM:
+	case MN_UART_RBUFNUM:
+		return serial8250_mn_serial_in_dma(up, offset);
+#endif
+	default:
+		return 0;
+	}
+}
+
+/**
+ * Read from UART DL register
+ *
+ * @param up  UART port
+ * @return    Read value
+ */
+static int serial8250_mn_serial_dl_read(struct uart_8250_port *up)
+{
+	return readl_relaxed(up->port.membase + MN_UART_DLL);
+}
+
+/**
+ * Write to UART DL register
+ *
+ * @param up     UART port
+ * @param value  Write value
+ */
+static void serial8250_mn_serial_dl_write(struct uart_8250_port *up, int value)
+{
+	writel_relaxed(value, up->port.membase + MN_UART_DLL);
+}
+
+/**
+ * Read from UART DL register
+ *
+ * @param up  UART port
+ * @return    Read value
+ */
+static int serial8250_mn_es2_serial_dl_read(struct uart_8250_port *up)
+{
+	u32	dll;
+
+	dll = readl_relaxed(up->port.membase + MN_UART_DLL);
+	dll &= 0x00000FFF;
+
+	return dll;
+}
+
+/**
+ * Write to UART DL register
+ *
+ * @param up     UART port
+ * @param value  Write value
+ */
+static void serial8250_mn_es2_serial_dl_write(struct uart_8250_port *up, int value)
+{
+	struct uart_port *port = &up->port;
+	struct ktermios		termios;
+	int	lpc, mindiff;
+	int	baud;
+	int	oval;
+	u64	tmp;
+	int	ldlr[DIVMODE_NUMB], lmod[DIVMODE_NUMB], ldlt[DIVMODE_NUMB];
+	const int divmode[] = {
+		0,
+		500,
+		250,
+		125,
+	};
+		
+
+	oval = value;
+	if (~MN_UART_DLR_MASK & value) {
+		printk(KERN_ERR	"setting the minute period failed\n");
+		return;
+	}
+
+	value &= MN_UART_DLR_MASK;
+	termios.c_cflag = port->cons->cflag;
+	if (port->state->port.tty && termios.c_cflag == 0) {
+		termios.c_cflag = port->state->port.tty->termios.c_cflag;
+		termios.c_ispeed = port->state->port.tty->termios.c_ispeed;
+		termios.c_ospeed = port->state->port.tty->termios.c_ospeed;
+	}
+	baud = uart_get_baud_rate(port, &termios, NULL,
+				  port->uartclk / 16 / 0xfff,
+				  port->uartclk / 16);
+	if (value > 2) {
+		tmp = (u64)((u64)(port->uartclk / 16) * FIXED_DEC);
+		ldlr[0] = DIV_ROUND_CLOSEST_ULL(tmp, baud);
+		for(lpc = 0; lpc < DIVMODE_NUMB; lpc++) {
+			ldlr[lpc] = ldlr[0] - divmode[lpc];
+			lmod[lpc] = ldlr[lpc] % FIXED_DEC;
+			ldlt[lpc] = min(lmod[lpc],FIXED_DEC-lmod[lpc]);
+		}
+
+		for(lpc = mindiff = 0; lpc < DIVMODE_NUMB; lpc++) {
+			if (ldlt[mindiff] > ldlt[lpc])
+				mindiff = lpc;
+		}
+		value = DIV_ROUND_CLOSEST(ldlr[mindiff], 1000);
+	} else {
+		mindiff = 0;
+	}
+	switch(mindiff) {
+	case 1:
+		value |= 0x00006000;
+		break;
+	case 2:
+		value |= 0x00005000;
+		break;
+	case 3:
+		value |= 0x00003000;
+		break;
+	default:
+		value |= 0x00007000;
+	}
+	dev_info(up->port.dev, "baud(%d)old(%04x)new(%04x)\n", baud, oval, value);
+	writel_relaxed(value, up->port.membase + MN_UART_DLL);
+}
+
+/**
+ * poring timer intterrupt handler
+ *
+ * @param data   8250 UART port
+ */
+void serial8250_mn_timeout(unsigned long data)
+{
+	struct uart_8250_port	*up = (struct uart_8250_port *)data;
+	struct uart_8250_dma	*dma = up->dma;
+	struct dma_tx_state	state;
+	int	dmalen, nowlen;
+	unsigned int	msr;
+
+	local_irq_disable();
+
+restart:
+	nowlen = serial_in(up, MN_UART_RBUFNUM);
+	if (dma != NULL) {
+		if (dma->rx_running == 0) {
+			up->iir = serial_in(up, UART_IIR);
+			up->iir &= ~UART_IIR_NO_INT;
+			up->iir |= UART_IIR_RDI;
+
+			serial8250_rx_dma(up, up->iir);
+
+			goto exit;
+		}
+
+		dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
+		dmalen = nowlen + (dma->rx_size - state.residue);
+	} else {
+		dmalen = nowlen;
+	}
+
+	msr = serial_in(up, UART_MSR);
+
+	if (dmalen != 0 || (msr & UART_MSR_ANY_DELTA)) {
+		if (up->msr_saved_flags == 0)
+			up->msr_saved_flags = msr;
+
+		if (dmalen != 0) {
+			up->iir = serial_in(up, UART_IIR);
+			up->iir = (up->iir & ~UART_IIR_NO_INT) |
+				UART_IIR_RX_TIMEOUT | UART_IIR_RDI;
+			up->lsr = serial_in(up, UART_LSR);
+			up->lsr = up->lsr | UART_LSR_DR | UART_LSR_BI;
+			_TRC_usr_log_ext(0xF3, dmalen);
+
+			serial8250_mn_handle_irq(&up->port, serial_in(up, UART_IIR));
+		} else {
+			up->iir = serial_in(up, UART_IIR);
+			up->iir &= ~UART_IIR_NO_INT;
+
+			serial8250_mn_handle_irq(&up->port, serial_in(up, UART_IIR));
+		}
+#ifdef ENABLE_RX_DMA	/* RX_DMA enable */
+		if (up->port.type == PORT_MN_STRM &&
+		    dma->rx_running == 0) {
+			goto restart;
+		}
+#endif
+	} else {
+		dev_dbg(up->port.dev, "%s: exit(%d)\n" ,__func__, 0);
+	}
+
+exit:
+	local_irq_enable();
+
+	mod_timer(&up->timer, jiffies + uart_poll_timeout(&up->port));
+}
+
+/**
+ * 1 copy of the letter the loaded data to the tty buffer
+ *
+ * @param up   8250 UART port
+ * @param lsr  line status register
+ * @param ch   read charactor
+ */
+static unsigned char
+serial8250_mn_rx_char(struct uart_8250_port *up,
+		      unsigned char lsr, unsigned char ch)
+{
+	struct uart_port *port = &up->port;
+	char flag;
+
+	{
+		flag = TTY_NORMAL;
+		port->icount.rx++;
+
+		lsr |= up->lsr_saved_flags;
+		up->lsr_saved_flags = 0;
+
+		if (unlikely(lsr & UART_LSR_BRK_ERROR_BITS)) {
+			if (!(lsr & UART_LSR_BI)) {
+//				printk("%s:error lsr(%x)\n",__func__ , lsr);
+				_TRC_usr_log_ext(0x0E, (int)lsr);
+			}
+			if (lsr & UART_LSR_BI) {
+				lsr &= ~(UART_LSR_FE | UART_LSR_PE);
+				port->icount.brk++;
+				/*
+				 * We do the SysRQ and SAK checking
+				 * here because otherwise the break
+				 * may get masked by ignore_status_mask
+				 * or read_status_mask.
+				 */
+				if (uart_handle_break(port)) {
+					printk("%s:uart_handle_break\n", __func__);
+					goto ignore_char;
+				}
+			} else if (lsr & UART_LSR_PE)
+				port->icount.parity++;
+			else if (lsr & UART_LSR_FE)
+				port->icount.frame++;
+			if (lsr & UART_LSR_OE)
+				port->icount.overrun++;
+
+			/*
+			 * Mask off conditions which should be ignored.
+			 */
+			lsr &= port->read_status_mask;
+
+			if (lsr & UART_LSR_BI) {
+				dev_dbg(up->port.dev, "handling break....");
+				flag = TTY_BREAK;
+			} else if (lsr & UART_LSR_PE)
+				flag = TTY_PARITY;
+			else if (lsr & UART_LSR_FE)
+				flag = TTY_FRAME;
+		}
+		if (uart_handle_sysrq_char(port, ch)) {
+			dev_dbg(up->port.dev, "%s:uart_handle_sysrq_char(%x)\n", __func__, ch);
+			goto ignore_char;
+		}
+
+		uart_insert_char(port, lsr, UART_LSR_OE, ch, flag);
+
+ignore_char:
+		lsr = serial_in(up, UART_LSR);
+	}
+	return lsr;
+}
+
+/*
+ * serial8250_rx_chars: processes according to the passed in LSR
+ * value, and returns the remaining LSR bits not handled
+ * by this Rx routine.
+ */
+static unsigned char
+serial8250_mn_rx_chars(struct uart_8250_port *up, unsigned char lsr)
+{
+	struct uart_port *port = &up->port;
+	unsigned char ch;
+	unsigned int	ch4;
+	int rxlen;
+	int i;
+	int count;
+	unsigned int	lcntr;
+
+	count = port->icount.rx;
+	port->ignore_status_mask = 0;	/* FIXME */
+
+	lcntr = serial_in(up, MN_UART_DMACR);
+	serial_out(up, MN_UART_DMACR, (lcntr & ~MN_UART_DMACR_RXDMAE));
+
+	while((rxlen = serial_in(up, MN_UART_RBUFNUM)) == MN_UART_CONBUF_MAX) {
+		ch4 = serial_in(up, MN_UART_RX_LG);
+
+		lcntr = serial_in(up, MN_UART_DMACR);
+		serial_out(up, MN_UART_DMACR, (lcntr | MN_UART_DMACR_RXDMAE));
+
+//		_TRC_usr_log_ext(0xFE, ch4);
+		for (i = 0; i < MN_UART_CONBUF_MAX; i++) {
+			ch = (ch4 >> 8*i) & 0x000000FF;
+			lsr = serial8250_mn_rx_char(up, lsr, ch);
+		}
+
+		lcntr = serial_in(up, MN_UART_DMACR);
+		serial_out(up, MN_UART_DMACR, (lcntr & ~MN_UART_DMACR_RXDMAE));
+
+	}
+#if 1	/* The one character at a time reading four or more characters */
+	while((rxlen = serial_in(up, MN_UART_RBUFNUM))) {
+		serial_out(up, MN_UART_DSIZL, rxlen);
+		for (i = 0; i < rxlen; i++) {
+			ch = serial_in(up, UART_RX);
+//			_TRC_usr_log_ext(0xfe,ch);
+			lsr = serial8250_mn_rx_char(up, lsr, ch);
+		}
+
+		lcntr = serial_in(up, MN_UART_DMACR);
+		serial_out(up, MN_UART_DMACR, (lcntr | MN_UART_DMACR_RXDMAE));
+		udelay( 1 );
+		lcntr = serial_in(up, MN_UART_DMACR);
+		serial_out(up, MN_UART_DMACR, (lcntr & ~MN_UART_DMACR_RXDMAE));
+	}
+#else	/* max 4char read */
+	serial_out(up, MN_UART_DSIZL, rxlen);
+
+	for (i = 0; i < rxlen; i++) {
+		ch = serial_in(up, UART_RX);
+//		_TRC_usr_log_ext(0xfe,ch);
+		lsr = serial8250_mn_rx_char(up, lsr, ch);
+	}
+#endif
+	lcntr = serial_in(up, MN_UART_DMACR);
+	serial_out(up, MN_UART_DMACR, (lcntr | MN_UART_DMACR_RXDMAE));
+	count = port->icount.rx - count;
+
+	_TRC_usr_log_ext(0xFF,count);
+
+	if (up->dma)
+		serial_out(up, MN_UART_DSIZL, up->dma->rx_size);
+	else
+		serial_out(up, MN_UART_DSIZL, PAGE_SIZE);
+
+	spin_unlock(&port->lock);
+	tty_flip_buffer_push(&port->state->port);
+	spin_lock(&port->lock);
+	return lsr;
+}
+
+/*
+ * This handles the interrupt from one port.
+ */
+static int serial8250_mn_handle_irq(struct uart_port *port, unsigned int iir)
+{
+	unsigned char status;
+	unsigned long flags;
+	struct uart_8250_port *up =
+		container_of(port, struct uart_8250_port, port);
+	int	dma_err = 0;
+	unsigned int	lcntr;
+#ifdef FORCE_MANUAL_FLOW_CONTROL
+	unsigned int	mcr, oafe = 0;
+#endif
+
+	if (iir & UART_IIR_NO_INT)
+		return 0;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+#ifndef ENABLE_RX_DMA		/* RX_DMA enable */
+	dma = up->dma;
+	up->dma = NULL;
+#endif
+
+#ifdef FORCE_MANUAL_FLOW_CONTROL
+	/* Effectively it can be in Garda-C ES2 later. */
+	mcr = serial_port_in(port, UART_MCR);
+	dev_dbg(port->dev, "%s: ent iir(%x),mcr(%x)\n", __func__, (u32)iir, (u32)mcr);
+	oafe = mcr & UART_MCR_AFE;
+	if (oafe == UART_MCR_AFE &&
+	    up->lsirevision == CHIPREVST_CHIPREV_ES2) {
+		u32	fcr = serial_port_in(port, MN_UART_FCR);
+		fcr |= MN_UART_FCR_RTSMODE0;
+		serial_out(up, UART_FCR, fcr);
+	} else {
+		lcntr = serial_port_in(port, UART_MCR);
+		lcntr &= ~(UART_MCR_AFE | UART_MCR_RTS);
+		serial_out(up, UART_MCR, lcntr);
+	}
+#endif
+
+	lcntr = serial_port_in(port, UART_IER);
+	serial_out(up, UART_IER, lcntr & ~UART_IER_RDI);
+
+	status = serial_port_in(port, UART_LSR);
+
+	DEBUG_INTR("status = %x...", status);
+	_TRC_usr_log_ext(0xD1, (int)status);
+
+	if (status & (UART_LSR_DR | UART_LSR_BI)) {
+		if (up->dma) {
+			lcntr = serial_in(up, MN_UART_DMACR);
+			serial_out(up, MN_UART_DMACR, (lcntr & ~MN_UART_DMACR_RXDMAE));
+			dma_err = serial8250_rx_dma(up, iir);
+			lcntr = serial_in(up, MN_UART_DMACR);
+			serial_out(up, MN_UART_DMACR, (lcntr | MN_UART_DMACR_RXDMAE));
+		}
+		if (!up->dma || dma_err)
+			status = serial8250_mn_rx_chars(up, status);
+	}
+	serial8250_modem_status(up);
+#ifndef ENABLE_RX_DMA 	/* enable rx_dma */
+	up->dma = dma;
+#endif
+	if (!up->dma && (status & UART_LSR_THRE))
+		serial8250_tx_chars(up);
+
+	lcntr = serial_port_in(port, UART_IER);
+	serial_out(up, UART_IER, lcntr | UART_IER_RDI);
+
+#ifdef FORCE_MANUAL_FLOW_CONTROL
+	/* manual RTS on */
+	/* Effectively it can be in Garda-C ES2 later. */
+	if (oafe == UART_MCR_AFE &&
+	    up->lsirevision == CHIPREVST_CHIPREV_ES2) {
+		u32	fcr = serial_port_in(port, MN_UART_FCR);
+		fcr &= ~MN_UART_FCR_RTSMODE0;
+		serial_out(up, UART_FCR, fcr);
+	} else {
+		lcntr = serial_port_in(port, UART_MCR);
+		lcntr |= oafe | UART_MCR_RTS;
+		serial_out(up, UART_MCR, lcntr);
+	}
+#endif
+
+	spin_unlock_irqrestore(&port->lock, flags);
+	return 1;
+}
+
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+/**
+ * Setting for using of the DMA control registers.
+ *
+ * @param port   8250 UART port
+ */
+static void serial8250_mn_setup_dma(struct uart_port *port,
+	struct serial8250_mn_priv *priv)
+{
+	u32  dmacr, ddir;
+
+	/* set rx/tx DMA control enable */
+	dmacr = MN_UART_DMACR_TXDMAE | MN_UART_DMACR_RXDMAE;
+	writel_relaxed(dmacr, port->membase + MN_UART_DMACR);
+
+	/* set DMA Transfer direction auto control */
+	ddir = readl_relaxed(port->membase + MN_UART_DDIR);
+	ddir |= MN_UART_DDIR_ADDIR;
+	writel_relaxed(ddir, port->membase + MN_UART_DDIR);
+}
+
+/**
+ * This handles the interrupt from one port.
+ *
+ * @param port   UART port
+ */
+static int serial8250_mn_default_handle_irq(struct uart_port *port)
+{
+	unsigned int iir = serial_port_in(port, UART_IIR);
+
+	return serial8250_mn_handle_irq(port, iir);
+}
+
+/**
+ * Write to UART DSIZL/DSIZH register.
+ *
+ * @param port   8250 UART port
+ * @param dsize  Transfer data size
+ */
+void serial8250_mn_set_dsize(void *port, u32 dsize)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	u32 value;
+
+	value = (dsize & MN_UART_DSIZL_MASK);
+	writel_relaxed(value, up->port.membase + MN_UART_DSIZL);
+	value = ((dsize >> MN_UART_DSIZH_SHIFT) & MN_UART_DSIZH_MASK);
+	writel_relaxed(value, up->port.membase + MN_UART_DSIZH);
+}
+
+/**
+ * Read to UART DSIZL/DSIZH register.
+ *
+ * @param port   8250 UART port
+ * @param dsize  Transfer data size
+ */
+u32 serial8250_mn_get_dsize(void *port)
+{
+	struct uart_8250_port *up = (struct uart_8250_port *)port;
+	u32 valuel, valueh;
+
+	valuel = readl_relaxed(up->port.membase + MN_UART_DSIZL);
+	valueh = readl_relaxed(up->port.membase + MN_UART_DSIZH);
+
+	return(valueh << MN_UART_DSIZH_SHIFT | valuel);
+}
+
+/**
+ * Collation of DMA device.
+ *
+ * @param chan   DMA channel data
+ * @param param  Private data address
+ */
+static bool serial8250_mn_dma_filter(struct dma_chan *chan, void *param)
+{
+	struct serial8250_mn_priv *data = param;
+
+	return chan->chan_id == data->dma.tx_chan_id ||
+	       chan->chan_id == data->dma.rx_chan_id;
+}
+
+/**
+ * Set value to UART register for DMA-related
+ *
+ * @paramu up      UART port
+ * @param offset  UART register offset
+ * @param value   Set value
+ *
+ * @attention The argument offset is to be converted to match the specification
+ *            of the UART registers.
+ */
+static void serial8250_mn_serial_out_dma(
+	struct uart_8250_port *up, u32 offset, u32 value)
+{
+	u32 tmp_val;
+
+	switch (offset) {
+	case MN_UART_DSIZL:
+		tmp_val = (value & MN_UART_DSIZL_MASK);
+		writel_relaxed(tmp_val, up->port.membase + offset);
+		break;
+	case MN_UART_DSIZH:
+		tmp_val = ((value >> MN_UART_DSIZH_SHIFT) & MN_UART_DSIZH_MASK);
+		writel_relaxed(tmp_val, up->port.membase + offset);
+		break;
+	case MN_UART_TFD:
+	case MN_UART_RFD:
+	case MN_UART_DMACR:
+	case MN_UART_DDIR:
+	case MN_UART_WBUFNUM:
+	case MN_UART_RBUFNUM:
+		writel_relaxed(value, up->port.membase + offset);
+		break;
+	default:
+		break;
+	}
+}
+
+/**
+ * Get value from UART register for DMA-related
+ *
+ * @param up      UART port
+ * @param offset  UART register offset
+ * @return        Get value
+ *
+ * edttention The argument offset is to be converted to match the specification
+ *            of the UART registers.
+ */
+static unsigned int serial8250_mn_serial_in_dma(struct uart_8250_port *up, u32 offset)
+{
+	switch (offset) {
+	case MN_UART_RX_LG:
+		return readl_relaxed(up->port.membase);
+	case MN_UART_FCR:
+	case MN_UART_LCR:
+	case MN_UART_TFD:
+	case MN_UART_RFD:
+	case MN_UART_DMACR:
+	case MN_UART_DDIR:
+	case MN_UART_DSIZL:
+	case MN_UART_DSIZH:
+	case MN_UART_WBUFNUM:
+	case MN_UART_RBUFNUM:
+		return readl_relaxed(up->port.membase + offset);
+	default:
+		return 0;
+	}
+}
+#endif
+
+/**
+ * Fill a struct uart_port for a given device node
+ *
+ * @param ofdev  Platform device
+ * @param type   UART type
+ * @param port   UART port
+ * @param priv   Driver private data
+ * @retval 0        Success
+ * @retval -EINVAL  The resource definition is incorrectly
+ * @retval -ENOENT  The clk definition is incorrectly
+ */
+static int of_platform_serial_setup(struct platform_device *ofdev,
+			int type, struct uart_port *port,
+			struct serial8250_mn_priv *priv)
+{
+	struct resource *regs = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	struct resource *irq = platform_get_resource(ofdev, IORESOURCE_IRQ, 0);
+
+	struct device_node *np = ofdev->dev.of_node;
+	u32 prop;
+
+	if ((regs == NULL) || (irq == NULL)) {
+		dev_err(&ofdev->dev, "missing registers or irq\n");
+		return -EINVAL;
+	}
+
+	port->irq = irq->start;
+
+	/* Get clk rate through clk driver if present */
+	priv->clk = clk_get(&ofdev->dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_warn(&ofdev->dev, "clk not defined\n");
+		return PTR_ERR(priv->clk);
+	}
+	clk_prepare_enable(priv->clk);
+	port->uartclk = clk_get_rate(priv->clk);
+
+	port->mapbase = regs->start;
+
+	/* Check for fifo size */
+	if (of_property_read_u32(np, "fifo-size", &prop) == 0)
+		port->fifosize = prop;
+
+	port->iotype = UPIO_MEM32;
+	port->type = type;
+	port->flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP
+		| UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SKIP_TEST;
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	if (of_device_is_compatible(np, "panasonic,mn-uart-sdma")) {
+		port->type = PORT_MN_STRM;
+		/* DMA type set to be used */
+		if (of_property_read_u32(np, "dma-type", &prop) == 0)
+			priv->dma_type = prop;
+
+		priv->dma.rx_param = priv;
+		priv->dma.tx_param = priv;
+		priv->dma.fn = serial8250_mn_dma_filter;
+
+		if (of_property_read_u32(np, "hw-ctrl", &prop) == 0)
+			priv->hw_ctrl = prop;
+	} else {
+		priv->dma_type = 0;
+		priv->dma.rx_param = NULL;
+		priv->dma.tx_param = NULL;
+		priv->dma.fn = NULL;
+	}
+#endif
+	return 0;
+}
+
+/**
+ * Probe UART driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ * @retval -ENOMEM  Failed to kzalloc
+ * @retval -EINVAL  The resource definition is incorrectly
+ * @retval -ENOENT  The clk definition is incorrectly
+ */
+static int serial8250_mn_probe(struct platform_device *pdev)
+{
+	struct serial8250_mn_priv *priv;
+	struct uart_8250_port up;
+	int ret;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "unable to allocate private data\n");
+		return -ENOMEM;
+	}
+
+	memset(&up, 0, sizeof(up));
+
+	spin_lock_init(&up.port.lock);
+
+	ret = of_platform_serial_setup(pdev, PORT_MN, &up.port, priv);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to setup 8250 port\n");
+		return ret;
+	}
+
+	up.port.flags &= ~UPF_IOREMAP;
+	up.port.membase = ioremap_nocache(up.port.mapbase, MN_UART_REG_SIZE);
+	if (!up.port.membase) {
+		dev_err(&pdev->dev, "ioremap failed \n");
+		ret = -ENOMEM;
+		goto fail;
+	}
+
+	up.port.dev = &pdev->dev;
+	up.port.private_data = priv;
+	up.port.serial_in = serial8250_mn_serial_in;
+	up.port.serial_out = serial8250_mn_serial_out;
+	up.port.timeout = 1;
+
+	switch(up.port.type) {
+	case PORT_MN:
+		up.dl_read = serial8250_mn_serial_dl_read;
+		up.dl_write = serial8250_mn_serial_dl_write;
+		break;
+	case PORT_MN_STRM:
+		up.lsirevision = serial8250_mn_get_lsirevision(pdev);
+		if (up.lsirevision < 0) {
+			dev_err(&pdev->dev, "[mn] unable to read LSI revision\n");
+			ret = up.lsirevision;
+			goto fail;
+		}
+		/* DMA and FIFO use settings to register */
+		serial8250_mn_setup_dma(&up.port, priv);
+		up.port.handle_irq = serial8250_mn_default_handle_irq;
+		if (up.lsirevision == CHIPREVST_CHIPREV_ES2) {
+			up.dl_read = serial8250_mn_es2_serial_dl_read;
+			up.dl_write = serial8250_mn_es2_serial_dl_write;
+		} else {
+			up.dl_read = serial8250_mn_serial_dl_read;
+			up.dl_write = serial8250_mn_serial_dl_write;
+		}
+		break;
+	default:
+		break;
+	}
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	if(priv->dma_type != 0){
+		up.dma = &priv->dma;
+	}
+#endif
+
+	ret = serial8250_register_8250_port(&up);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "unable to register 8250 port\n");
+		if (priv->clk != NULL)
+			clk_disable_unprepare(priv->clk);
+		goto fail;
+	}
+
+	priv->line = ret;
+	platform_set_drvdata(pdev, priv);
+	return 0;
+fail:
+	if (up.port.membase)
+		iounmap(up.port.membase);
+	return ret;
+}
+
+
+/**
+ * Remove UART driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ */
+static int serial8250_mn_remove(struct platform_device *pdev)
+{
+	struct serial8250_mn_priv *priv = platform_get_drvdata(pdev);
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	struct device_node *np = pdev->dev.of_node;
+	struct uart_port *port = platform_get_drvdata(pdev);
+#endif
+	serial8250_unregister_port(priv->line);
+	clk_disable_unprepare(priv->clk);
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	if (of_device_is_compatible(np, "panasonic,mn-uart-sdma")) {
+		/* DMA control information clear */
+		priv->dma_type = 0;
+		priv->dma.rx_chan_id = -1;
+		priv->dma.tx_chan_id = -1;
+
+		/* membase iounmap */
+		iounmap(port->membase);
+		port->membase = NULL;
+	}
+#endif
+	return 0;
+}
+
+static const struct of_device_id serial8250_mn_dt_ids[] = {
+	{ .compatible = "panasonic,mn-uart", },
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+	{ .compatible = "panasonic,mn-uart-sdma", },
+#endif
+	{},
+};
+MODULE_DEVICE_TABLE(of, serial8250_mn_dt_ids);
+
+static struct platform_driver serial8250_mn_platform_driver = {
+	.driver = {
+		.name		= "mn-uart",
+		.of_match_table = serial8250_mn_dt_ids,
+		.owner		= THIS_MODULE,
+	},
+	.probe			= serial8250_mn_probe,
+	.remove			= serial8250_mn_remove,
+};
+
+module_platform_driver(serial8250_mn_platform_driver);
+
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+static struct platform_driver serial8250_mn_dma_platform_driver = {
+	.driver = {
+		.name		= "mn-uart-sdma",
+		.of_match_table = serial8250_mn_dt_ids,
+		.owner		= THIS_MODULE,
+	},
+	.probe			= serial8250_mn_probe,
+	.remove			= serial8250_mn_remove,
+};
+
+module_platform_driver(serial8250_mn_dma_platform_driver);
+#endif
+
+MODULE_AUTHOR("Panasonic Corporation");
+MODULE_DESCRIPTION("Panasonic SOCs 8250 Driver");
+MODULE_LICENSE("GPL v2");
diff -uNr linux-3.14.19/drivers/tty/serial/8250/8250_mn.h linux-gerda/drivers/tty/serial/8250/8250_mn.h
--- linux-3.14.19/drivers/tty/serial/8250/8250_mn.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/8250_mn.h	2017-06-22 09:52:45.863039457 +0900
@@ -0,0 +1,99 @@
+/*
+ * 8250 UART serial registers
+ * drivers/tty/serial/8250/8250_mn.h
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#ifndef _LINUX_8250_SERIAL_MN_H
+#define _LINUX_8250_SERIAL_MN_H
+
+#ifdef __KERNEL__
+
+/* Register offset address */
+#define MN_UART_RX	0x0000UL	/* receive data register */
+#define MN_UART_TX	0x0000UL	/* transmit data register */
+#define MN_UART_IER	0x0004UL	/* interrupt enable register */
+#define MN_UART_IIR	0x0008UL	/* interrupt identification register */
+#define MN_UART_FCR	0x000cUL	/* FIFO control register */
+#define MN_UART_LCR	0x0010UL	/* line control register */
+#define MN_UART_MCR	0x0010UL	/*  */
+#define MN_UART_LSR	0x0014UL	/* Line status register */
+#define MN_UART_MSR	0x0018UL	/* modem status register */
+#define MN_UART_DLL	0x0024UL	/* Divisor latch register */
+#ifdef CONFIG_SERIAL_8250_MN_SDMA
+#define MN_UART_RX_LG	0x00FFUL	/* receive data register(long read) */
+#define MN_UART_TFD	0x001CUL	/* transmit data register(Private) */
+#define MN_UART_RFD	0x0020UL	/* receive data register(Private) */
+#define MN_UART_TOCLR	0x0020UL	/* TIMEOUT clear register */
+#define MN_UART_DMACR	0x0028UL	/* DMA controller register */
+#define MN_UART_DDIR	0x002CUL	/* DMA direction control register */
+#define MN_UART_DSIZL	0x0030UL	/* DMA trans size lower register */
+#define MN_UART_DSIZH	0x0034UL	/* DMA trans size upper register */
+#define MN_UART_WBUFNUM	0x0038UL	/* TX remaining number of data register */
+#define MN_UART_RBUFNUM	0x003CUL	/* RX remaining number of data register */
+#endif	/* CONFIG_SERIAL_8250_MN_SDMA */
+
+#define MN_UART_REG_SIZE	0x0100UL	/* UART ioremap size */
+
+/* MN_UARTFCR Register bit data */
+#define MN_UART_FCR_RTL_NRTS_1	0x0040UL	/* NRTS trigger lvl one */
+#define MN_UART_FCR_RTL_NRTS_3	0x0080UL	/* NRTS trigger lvl three */
+#define MN_UART_FCR_RTL_NRTS_7	0x00C0UL	/* NRTS trigger lvl seven */
+#define MN_UART_FCR_RTSMODE1	0x0020UL	/* Auto NRTS control timeout */
+#define MN_UART_FCR_RTSMODE0	0x0010UL	/* NRTS or control */
+#define MN_UART_FCR_FEN_ENABLE	0x0001UL	/* FIFO mode of use enable */
+
+/* MN_UART_LCR Register bit data */
+#define MN_UART_LCR_AEF_ENABLE	0x0020UL	/* Auto flow control enable */
+#define MN_UART_LCR_RTS_ENABLE	0x0002UL	/* Auto NRTS control enable */
+#define MN_UART_LCR_TOMODE	0x0001UL	/* Timeout interrupt generation condition switching */
+
+/* MN_UART_DMACR Register bit data */
+#define MN_UART_DMACR_TXDMAE	0x0002UL	/* Transmit DMA ope enable */
+#define MN_UART_DMACR_RXDMAE	0x0001UL	/* Receive DMA ope enable */
+#define MN_UART_DMACR_NONDMA	0x0000UL	/* DMA ope disable */
+
+/* MN_UART_DDIR Register bit data */
+#define MN_UART_DDIR_ADDIR	0x0002UL	/* transfer direction       *
+						 *        automatic control */
+#define MN_UART_DDIR_TX		0x0001UL
+/* MN_UART_DSIZL Register */
+#define MN_UART_DSIZL_MASK	0xFFFFUL	/* Lower size mask bit */
+
+/* MN_UART_DSIZH Register */
+#define MN_UART_DSIZH_SHIFT	16		/* Upper size shift count */
+#define MN_UART_DSIZH_MASK	0x00FFUL	/* Upper size mask bit  */
+
+/* MN_UART_DLL Register */
+#define MN_UART_DLR_MASK	0x00000FFFUL	/* ES2 dlr mask */
+
+/* */
+#define MN_UART_CONBUF_MAX	4		/* Conversion buffer maximum */
+
+/* Stream device interrupt number */
+#if defined(CONFIG_MACH_GERDAC)
+#define UART_IRQ_NO		129		/* CH0:129  CH1:130 */
+#elif defined(CONFIG_MACH_GERDA3)
+#define UART_IRQ_NO		122		/* CH0:121  CH1:122 */
+#endif
+
+/* CHIPREVST register bit assignment */
+#define CHIPREVST_ADDR                  0x9C010344      /* registar address */
+#define CHIPREVST_SIZE                  0x00000100      /* map size */
+#define CHIPREVST_CHIPREV_ES1           0x00000000      /* Chip revision ES1 */
+#define CHIPREVST_CHIPREV_ES2           0x00000001      /* Chip revision ES2 */
+
+#define DIVMODE_NUMB (4)
+#define FIXED_DEC 1000
+
+#define ENABLE_RX_DMA	1
+#undef	USE_HW_TIMEOUT		/* not use hw error */
+#undef	FORCE_MANUAL_FLOW_CONTROL
+
+#endif /* __KERNEL_ */
+#endif /* _LINUX_8250_SERIAL_MN_H */
diff -uNr linux-3.14.19/drivers/tty/serial/8250/Kconfig linux-gerda/drivers/tty/serial/8250/Kconfig
--- linux-3.14.19/drivers/tty/serial/8250/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/Kconfig	2017-06-22 09:52:45.859039457 +0900
@@ -295,6 +295,28 @@
 	  port hardware found on the Emma Mobile line of processors.
 	  If unsure, say N.
 
+config SERIAL_8250_MN
+	tristate "Support for Panasonic SOCs integrated serial port"
+	select SERIAL_8250_MN_SDMA
+	select SERIAL_8250_DMA
+	select DMADEVICES
+	depends on SERIAL_8250 && ARM && HAVE_CLK
+	help
+	  Selecting this option will add support for the integrated serial
+	  port hardware found on the Panasonic SOCs.
+	  If unsure, say N.
+
+if SERIAL_8250_MN
+config SERIAL_8250_MN_SDMA
+        depends on SERIAL_8250_MN && SERIAL_8250_DMA && ARM
+        bool "Panasonic SOCs SDMA support"
+        default "y"
+        help
+          select this option, you can add the stream DMA controller
+          of support found in the Panasonic SOCs for the transfer of data.
+          If unsure, say N.
+endif # SERIAL_8250_MN
+
 config SERIAL_8250_RT288X
 	bool "Ralink RT288x/RT305x/RT3662/RT3883 serial port support"
 	depends on SERIAL_8250 && (SOC_RT288X || SOC_RT305X || SOC_RT3883)
diff -uNr linux-3.14.19/drivers/tty/serial/8250/Makefile linux-gerda/drivers/tty/serial/8250/Makefile
--- linux-3.14.19/drivers/tty/serial/8250/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/8250/Makefile	2017-06-22 09:52:45.859039457 +0900
@@ -20,3 +20,4 @@
 obj-$(CONFIG_SERIAL_8250_FSL)		+= 8250_fsl.o
 obj-$(CONFIG_SERIAL_8250_DW)		+= 8250_dw.o
 obj-$(CONFIG_SERIAL_8250_EM)		+= 8250_em.o
+obj-$(CONFIG_SERIAL_8250_MN)		+= 8250_mn.o
diff -uNr linux-3.14.19/drivers/tty/serial/Kconfig linux-gerda/drivers/tty/serial/Kconfig
--- linux-3.14.19/drivers/tty/serial/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/Kconfig	2017-06-22 09:52:45.847039457 +0900
@@ -1507,6 +1507,21 @@
 	depends on SERIAL_ST_ASC=y
 	select SERIAL_CORE_CONSOLE
 
+config SERIAL_SIOEXT_MN
+	bool "Support for Panasonic SOCs SIOEXT serial port"
+	depends on ARM && HAVE_CLK
+	help
+	  Selecting this option will add support for the integrated serial
+	  port hardware found on the Panasonic SOCs.
+	  If unsure, say N.
+
+config SERIAL_SIOEXT_MN_CTS
+	bool "Support for Panasonic SOCs SIOEXT CTS"
+	depends on SERIAL_SIOEXT_MN
+        default "y"
+	help
+	  Serial port driver by setting this option will support the CTS.
+
 endmenu
 
 endif # TTY
diff -uNr linux-3.14.19/drivers/tty/serial/Makefile linux-gerda/drivers/tty/serial/Makefile
--- linux-3.14.19/drivers/tty/serial/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/tty/serial/Makefile	2017-06-22 09:52:45.675039463 +0900
@@ -87,3 +87,4 @@
 obj-$(CONFIG_SERIAL_ARC)	+= arc_uart.o
 obj-$(CONFIG_SERIAL_RP2)	+= rp2.o
 obj-$(CONFIG_SERIAL_FSL_LPUART)	+= fsl_lpuart.o
+obj-$(CONFIG_SERIAL_SIOEXT_MN) += mn_sioext.o
\ ãƒ•ã‚¡ã‚¤ãƒ«æœ«å°¾ã«æ”¹è¡ŒãŒã‚ã‚Šã¾ã›ã‚“
diff -uNr linux-3.14.19/drivers/tty/serial/mn_sioext.c linux-gerda/drivers/tty/serial/mn_sioext.c
--- linux-3.14.19/drivers/tty/serial/mn_sioext.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/tty/serial/mn_sioext.c	2017-06-22 09:52:45.855039457 +0900
@@ -0,0 +1,1413 @@
+/*
+ * SIOEXT On-chip serial port UART driver
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+#define pr_fmt(fmt)	KBUILD_MODNAME ":%s: " fmt, __func__
+
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/tty.h>
+#include <linux/tty_flip.h>
+#include <linux/console.h>
+#include <linux/serial_core.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/clk.h>
+
+#ifdef CONFIG_HIGH_RES_TIMERS
+#define USE_HRTIMER
+#endif
+#ifdef CONFIG_SERIAL_SIOEXT_MN_CTS
+#define USE_SOFTWARE_CTS
+#endif
+#undef USE_ADAPTED_WAIT
+#undef USE_MULTIPOINT_TRANSMIT
+
+#include "mn_sioext.h"
+
+/* Import from 4.1 kernel.h */
+#define DIV_ROUND_CLOSEST_ULL(x, divisor)(              \
+{                                                       \
+        typeof(divisor) __d = divisor;                  \
+        unsigned long long _tmp = (x) + (__d) / 2;      \
+        do_div(_tmp, __d);                              \
+        _tmp;                                           \
+}                                                       \
+)
+
+static void mn_sioext_console_write(struct console *co,
+				    const char *s, unsigned count);
+static int __init mn_sioext_console_setup(struct console *co, char *options);
+
+#define txfifo_can_transfer(scastr)	(((scastr) & SIOTOP_SCASTR_TBSY) == SIOTOP_SCASTR_TBSY_OK)
+#define txfifo_usable_size(txtva)	(txtva)
+#define txfifo_is_empty(uart, txtva)	((txtva) == (uart)->fifosize)
+
+static unsigned int mn_sioext_tx_empty(struct uart_port *uart);
+static void mn_sioext_set_mctrl(struct uart_port *uart, unsigned int mctrl);
+static unsigned int mn_sioext_get_mctrl(struct uart_port *uart);
+static void mn_sioext_stop_tx(struct uart_port *uart);
+static void mn_sioext_start_tx(struct uart_port *uart);
+static void mn_sioext_stop_rx(struct uart_port *uart);
+static void mn_sioext_enable_ms(struct uart_port *uart);
+static void mn_sioext_break_ctl(struct uart_port *uart, int ctl);
+static int mn_sioext_startup(struct uart_port *uart);
+static void mn_sioext_shutdown(struct uart_port *uart);
+static void mn_sioext_set_termios(struct uart_port *uart,
+				  struct ktermios *new,
+				  struct ktermios *old);
+static const char *mn_sioext_type(struct uart_port *uart);
+static void mn_sioext_release_port(struct uart_port *uart);
+static int mn_sioext_request_port(struct uart_port *uart);
+static void mn_sioext_config_port(struct uart_port *uart, int type);
+static int mn_sioext_verify_port(struct uart_port *uart,
+				 struct serial_struct *ss);
+static void mn_sioext_set_rtsctl(struct mn_sioext_port *port, int crtscts);
+
+const struct uart_ops mn_sioext_ops = {
+	.tx_empty	= mn_sioext_tx_empty,
+	.set_mctrl	= mn_sioext_set_mctrl,
+	.get_mctrl	= mn_sioext_get_mctrl,
+	.stop_tx	= mn_sioext_stop_tx,
+	.start_tx	= mn_sioext_start_tx,
+	.stop_rx	= mn_sioext_stop_rx,
+	.enable_ms	= mn_sioext_enable_ms,
+	.break_ctl	= mn_sioext_break_ctl,
+	.startup	= mn_sioext_startup,
+	.shutdown	= mn_sioext_shutdown,
+	.set_termios	= mn_sioext_set_termios,
+	.type		= mn_sioext_type,
+	.release_port	= mn_sioext_release_port,
+	.request_port	= mn_sioext_request_port,
+	.config_port	= mn_sioext_config_port,
+	.verify_port	= mn_sioext_verify_port,
+};
+
+static void mn_sioext_receive_interrupt(struct mn_sioext_port *port);
+static void mn_sioext_transmit_interrupt(struct mn_sioext_port *port);
+static irqreturn_t mn_sioext_interrupt(int irq, void *dev_id);
+static int mn_sioext_wait_for_enable_transfer(struct mn_sioext_port *port);
+static int mn_sioext_wait_for_tx_complete(struct mn_sioext_port *port);
+static void mn_sioext_dis_tx_intr(struct mn_sioext_port *port);
+static void mn_sioext_en_tx_intr(struct mn_sioext_port *port);
+static void mn_sioext_en_rx_intr(struct mn_sioext_port *port);
+static void mn_sioext_dis_rx_intr(struct mn_sioext_port *port);
+static void mn_sioext_console_putchar(struct uart_port *uart, int ch);
+
+static int mn_sioext_get_exclk(struct mn_sioext_port *, int, u32 *);
+static int mn_sioext_get_lsirevision(struct platform_device *);
+
+static u32	chiprevst;			/* lsi revision */
+
+
+static inline unsigned int serial_in(struct mn_sioext_port *up, int offset)
+{
+	return readl(up->uart.membase + offset);
+}
+
+static inline void serial_out(struct mn_sioext_port *up, int offset, int value)
+{
+	writel(value, up->uart.membase + offset);
+}
+
+/**
+ * Disable the transmit interrupt
+ *
+ * @param port  serial port
+ */
+static void mn_sioext_dis_tx_intr(struct mn_sioext_port *port)
+{
+	u32 contrl;
+
+	contrl = serial_in(port, SIOTOP_TXCNT);
+	contrl &= ~SIOTOP_TXCNT_EI;
+	serial_out(port, SIOTOP_TXCNT, contrl);
+}
+
+/**
+ * Enable the transmit interrupt
+ *
+ * @param port  serial port
+ */
+static void mn_sioext_en_tx_intr(struct mn_sioext_port *port)
+{
+	u32 contrl;
+
+	contrl = serial_in(port, SIOTOP_TXCNT);
+	contrl |= SIOTOP_TXCNT_EI;
+	serial_out(port, SIOTOP_TXCNT, contrl);
+}
+
+/**
+ * Disable the receive interrupt
+ *
+ * @param port  serial port
+ */
+static void __attribute__((__unused__)) mn_sioext_dis_rx_intr(struct mn_sioext_port *port)
+{
+	u32 contrl;
+
+	contrl = serial_in(port, SIOTOP_RXCNT);
+	contrl &= ~SIOTOP_RXCNT_EI;
+	serial_out(port, SIOTOP_RXCNT, contrl);
+}
+
+/**
+ * Enable the receive interrupt
+ *
+ * @param port  serial port
+ */
+static void __attribute__((__unused__)) mn_sioext_en_rx_intr(struct mn_sioext_port *port)
+{
+	u32 contrl;
+
+	contrl = serial_in(port, SIOTOP_RXCNT);
+	contrl |= SIOTOP_RXCNT_EI;
+	serial_out(port, SIOTOP_RXCNT, contrl);
+}
+
+static void mn_sioext_clear_receiving_error(struct mn_sioext_port *port, u32 status)
+{
+	u32 scactr;
+
+	if (status & (SIOTOP_STATUS_SCAPECLR | SIOTOP_STATUS_SCAFECLR)) {
+		scactr = serial_in(port, SIOTOP_SCACTR);
+		serial_out(port, SIOTOP_SCACTR,
+			   scactr & ~SIOTOP_SCACTR_SCAREN);
+	}
+
+	serial_out(port, SIOTOP_STATUS, status);
+	serial_out(port, SIOTOP_STATUS, status & ~(SIOTOP_STATUS_RXDFOR | SIOTOP_STATUS_SCAFECLR | SIOTOP_STATUS_SCAPECLR));
+
+	if (status & (SIOTOP_STATUS_SCAPECLR | SIOTOP_STATUS_SCAFECLR)) {
+		serial_out(port, SIOTOP_SCACTR, scactr);
+	}
+}
+
+#ifdef USE_SOFTWARE_CTS
+static int mn_sioext_read_gpidata(struct mn_sioext_port *port)
+{
+	int rtn = 0;
+	int gpiodiv, gpiomod;
+	if (port->cts_gpio != -1) {
+		gpiodiv = port->cts_gpio / 32;
+		gpiomod = port->cts_gpio % 32;
+		rtn = __raw_readl(port->gpio_membase + GPIDATA0 + gpiodiv * 4) & (1 << (port->cts_gpio % 32));
+	}
+	return rtn;
+}
+#endif
+
+static void mn_sioext_out_txdata(struct mn_sioext_port *port)
+{
+	struct circ_buf *xmit = &port->uart.state->xmit;
+	unsigned int count = serial_in(port, SIOTOP_TXTVA);
+	int	txintr = 1;
+	unsigned int	permsec;
+
+	/* Seek the number of possible transfer bytes in 1msec(max 64) */
+	permsec = (port->baudrate + 9999) / 10000;
+	count = min(count, permsec);
+
+	while (count > 0) {
+#ifdef USE_SOFTWARE_CTS
+		if (port->crtscts & CRTSCTS) {
+			if (mn_sioext_read_gpidata(port)) {
+				txintr = 0;
+				break;
+			}
+		}
+#endif
+		serial_out(port, SIOTOP_TXDATA, xmit->buf[xmit->tail]);
+		xmit->tail = (xmit->tail + 1) & (UART_XMIT_SIZE - 1);
+		port->uart.icount.tx++;
+		udelay(1);
+		if (uart_circ_empty(xmit)) {
+			txintr = 0;
+			break;
+		}
+#ifdef USE_SOFTWARE_CTS
+		if (port->crtscts & CRTSCTS)
+			while(serial_in(port, SIOTOP_TXTVA) != SIOEXT_FIFO_SIZE);
+#endif
+		count--;
+	}
+	if (txintr)
+		mn_sioext_en_tx_intr(port);
+	else
+		mn_sioext_dis_tx_intr(port);
+}
+
+/**
+ * Receive interrupt
+ *
+ * @param port  serial port
+ */
+static void mn_sioext_receive_interrupt(struct mn_sioext_port *port)
+{
+	struct uart_icount *icount = &port->uart.icount;
+	u32 status, rxtva;
+	int max_count = 256;
+	unsigned char ch;
+	char flag;
+
+	status = serial_in(port, SIOTOP_STATUS);
+	rxtva = serial_in(port, SIOTOP_RXTVA);
+	while ((rxtva > 0) && (max_count-- > 0)) {
+		ch = (unsigned char)serial_in(port, SIOTOP_RXDATA);
+		flag = TTY_NORMAL;
+		icount->rx++;
+
+		if (unlikely(status & (SIOTOP_STATUS_RXDFOR | SIOTOP_STATUS_SCAFECLR | SIOTOP_STATUS_SCAPECLR))) {
+			if (status & SIOTOP_STATUS_SCAFECLR) {
+				dev_err(port->uart.dev, "[mn] framing error\n");
+				icount->frame++;
+				flag = TTY_FRAME;
+			} else if (status & SIOTOP_STATUS_SCAPECLR) {
+				dev_dbg(port->uart.dev, "[mn] parity error\n");
+				icount->parity++;
+				flag = TTY_PARITY;
+			}
+			if (status & SIOTOP_STATUS_RXDFOR) {
+				dev_dbg(port->uart.dev, "[mn] overrun error\n");
+				icount->overrun++;
+			}
+
+			mn_sioext_clear_receiving_error(port, status);
+		}
+
+		if (uart_handle_sysrq_char(&port->uart, ch)) {
+			goto ignore_char;
+		}
+
+		uart_insert_char(&port->uart, status, SIOTOP_STATUS_RXDFOR, ch, flag);
+
+ignore_char:
+		status = serial_in(port, SIOTOP_STATUS);
+		rxtva = serial_in(port, SIOTOP_RXTVA);
+	}
+	spin_unlock(&port->uart.lock);
+	tty_flip_buffer_push(&port->uart.state->port);
+	spin_lock(&port->uart.lock);
+}
+
+/**
+ * Transmission interrupt
+ *
+ * @param port  serial port
+ */
+static void mn_sioext_transmit_interrupt(struct mn_sioext_port *port)
+{
+	struct circ_buf *xmit = &port->uart.state->xmit;
+#ifdef USE_ADAPTED_WAIT
+	int cnt = port->uart.icount.tx;
+#endif
+
+	if (port->tx_xchar) {
+		serial_out(port, SIOTOP_TXDATA, port->tx_xchar);
+		port->uart.icount.tx++;
+		port->tx_xchar = 0;
+		return;
+	}
+	if (uart_tx_stopped(&port->uart)) {
+		mn_sioext_stop_tx(&port->uart);
+		return;
+	}
+	if (uart_circ_empty(xmit)) {
+		mn_sioext_wait_for_tx_complete(port);
+		mn_sioext_stop_tx(&port->uart);
+		return;
+	}
+	mn_sioext_out_txdata(port);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS) {
+		uart_write_wakeup(&port->uart);
+	}
+#ifdef USE_ADAPTED_WAIT
+	/* At the time of change of the baud rate, it will return to the user context in the shortest. */
+	if ((port->uart.icount.tx - cnt) <= SIOEXT_ADAPTED_WAIT_THRESHOLD)
+#endif
+#ifdef USE_SOFTWARE_CTS
+		if (port->crtscts & CRTSCTS)
+#endif
+			if (uart_circ_empty(xmit)) {
+				mn_sioext_wait_for_tx_complete(port);
+				mn_sioext_stop_tx(&port->uart);
+			}
+}
+
+/**
+ * SIOEXT interrupt handler
+ *
+ * @param irq     interrupt number
+ * @param dev_id  device id
+ * @retval IRQ_HANDLED  the interrupt is handled
+ */
+static irqreturn_t mn_sioext_interrupt(int irq, void *dev_id)
+{
+	struct mn_sioext_port *port = dev_id;
+	unsigned long flags;
+	u32 txtva, rxtva;
+
+	spin_lock_irqsave(&port->uart.lock, flags);
+	rxtva = serial_in(port, SIOTOP_RXTVA);
+	if (rxtva != 0) {
+		mn_sioext_receive_interrupt(port);
+	}
+
+	txtva  = serial_in(port, SIOTOP_TXTVA);
+	if (txfifo_usable_size(txtva)) {
+		mn_sioext_transmit_interrupt(port);
+	}
+	spin_unlock_irqrestore(&port->uart.lock, flags);
+
+	if (port->uart.timeout) {
+#ifdef USE_HRTIMER
+		hrtimer_start(&port->timer, ktime_set(0, port->uart.timeout * NSEC_PER_MSEC),
+			      HRTIMER_MODE_REL);
+#else
+		mod_timer(&port->timer, jiffies + uart_poll_timeout(&port->uart));
+#endif
+	}
+
+	return IRQ_HANDLED;
+}
+
+/**
+ * Return indication of whether the hardware transmit buffer is empty
+ *
+ * @param uart  uart port
+ * @retval  0            transmit buffer is not empty
+ * @retval TIOCSER_TEMT  transmit buffer is empty
+ */
+static unsigned int mn_sioext_tx_empty(struct uart_port *uart)
+{
+	unsigned int ret = 0;
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	u32 scastr, txtva;
+
+	scastr = serial_in(port, SIOTOP_SCASTR);
+	txtva  = serial_in(port, SIOTOP_TXTVA);
+	if (txfifo_can_transfer(scastr) &&
+		txfifo_usable_size(txtva)) {
+		ret = TIOCSER_TEMT;
+	}
+	return ret;
+}
+
+/**
+ * Set the modem control lines (we don't have any)
+ *
+ * @param uart   uart port
+ * @param mctrl  modem control flag
+ */
+static void mn_sioext_set_mctrl(struct uart_port *uart, unsigned int mctrl)
+{
+}
+
+/**
+ * Get the modem control line statuses
+ *
+ * @param uart  uart port
+ * @return modem  control line status
+ */
+static unsigned int mn_sioext_get_mctrl(struct uart_port *uart)
+{
+	return TIOCM_CAR | TIOCM_CTS | TIOCM_DSR;
+}
+
+/**
+ * Stop transmitting characters
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_stop_tx(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+
+	mn_sioext_dis_tx_intr(port);
+}
+
+/**
+ * Start transmitting characters
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_start_tx(struct uart_port *uart)
+{
+#ifdef USE_MULTIPOINT_TRANSMIT
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	struct circ_buf *xmit = &port->uart.state->xmit;
+
+	/* At the time of change of the baud rate, it will return to the user context in the shortest. */
+	if (CIRC_CNT(xmit->head, xmit->tail, UART_XMIT_SIZE) > SIOEXT_ADAPTED_WAIT_THRESHOLD) {
+		mn_sioext_out_txdata(port);
+	}
+#endif
+}
+
+/**
+ * Stop receiving characters
+ * - called while the port is being closed
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_stop_rx(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	u32 control;
+
+	control = serial_in(port, SIOTOP_RXCNT);
+	control &= ~(SIOTOP_RXCNT_RXD_EN | SIOTOP_RXCNT_EI);
+	serial_out(port, SIOTOP_RXCNT, control);
+}
+
+/**
+ * Enable modem status interrupts
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_enable_ms(struct uart_port *uart)
+{
+}
+
+/**
+ * Transmit or cease transmitting a break signal
+ *
+ * @param port  uart port
+ * @param ctl   break control flag
+ *              1: break signal on
+ *              0: break signal off
+ */
+static void mn_sioext_break_ctl(struct uart_port *uart, int ctl)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	u32 control;
+
+	control = serial_in(port, SIOTOP_SCACTR);
+	if (ctl) {
+		port->tx_break = 1;
+		control |= SIOTOP_SCACTR_SCABRE;
+	} else {
+		port->tx_break = 0;
+		control &= ~SIOTOP_SCACTR_SCABRE;
+	}
+	serial_out(port, SIOTOP_SCACTR, control);
+#if 0
+	mn_sioext_en_tx_intr(port);
+#endif
+}
+
+/**
+ * Register interrupts and enable the port for reception
+ *
+ * @param uart  uart port
+ * @retval 0  Succeed
+ */
+static int mn_sioext_startup(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	u32 control, threshold;
+
+	if (request_irq(port->rx_irq, mn_sioext_interrupt,
+			IRQF_DISABLED, "sioext-rx", port) < 0) {
+		goto error1;
+	}
+	if (request_irq(port->tx_irq, mn_sioext_interrupt,
+			IRQF_DISABLED, "sioext-tx", port) < 0) {
+		goto error2;
+	}
+
+	/* set TX threshold */
+	threshold = uart->fifosize;
+	serial_out(port, SIOTOP_TXTRS, threshold);
+
+	/* send FIFO clear, intr enable */
+	control = serial_in(port, SIOTOP_TXCNT);
+	control &= ~SIOTOP_TXCNT_EI;
+	control |= (SIOTOP_TXCNT_TXD_EN | SIOTOP_TXCNT_FIFO_CLR);
+	serial_out(port, SIOTOP_TXCNT, control);
+
+	/* set RX threshold */
+	threshold = (uart->timeout) ? SIOEXT_RX_TIMEOUT_THRESHOLD : SIOEXT_RX_DEFAULT_THRESHOLD;
+	serial_out(port, SIOTOP_RXTRS, threshold);
+
+	/* receive FIFO clear, intr enable */
+	control = serial_in(port, SIOTOP_RXCNT);
+	control |= (SIOTOP_RXCNT_RXD_EN | SIOTOP_RXCNT_EI | SIOTOP_RXCNT_FIFO_CLR);
+	serial_out(port, SIOTOP_RXCNT, control);
+
+	if (uart->timeout) {
+#ifdef USE_HRTIMER
+		hrtimer_start(&port->timer, ktime_set(0, port->uart.timeout * NSEC_PER_MSEC),
+			      HRTIMER_MODE_REL);
+#else
+		mod_timer(&port->timer, jiffies + uart_poll_timeout(&port->uart));
+#endif
+	}
+
+	return 0;
+
+error2:
+	free_irq(port->rx_irq, port);
+error1:
+	return -EBUSY;
+}
+
+/**
+ * Shutdown the port and release interrupts
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_shutdown(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	u32 control, config;
+
+	/* IP reset */
+	config = serial_in(port, SIOTOP_CNFIG);
+	config |= SIOTOP_CNFIG_RESET;
+	serial_out(port, SIOTOP_CNFIG, config);
+
+	/* receve: intr disable / FIFO clear / function disable */
+	control = serial_in(port, SIOTOP_RXCNT);
+	control &= ~(SIOTOP_RXCNT_EI | SIOTOP_RXCNT_RXD_EN);
+	control |= SIOTOP_RXCNT_FIFO_CLR;
+	serial_out(port, SIOTOP_RXCNT, control);
+
+	/* send: intr disable / FIFO clear / function disable */
+	control = serial_in(port, SIOTOP_TXCNT);
+	control &= ~(SIOTOP_TXCNT_EI | SIOTOP_TXCNT_TXD_EN);
+	control |= SIOTOP_TXCNT_FIFO_CLR;
+	serial_out(port, SIOTOP_TXCNT, control);
+
+	control = serial_in(port, SIOTOP_SCACTR);
+	control &= (~SIOTOP_SCACTR_SCATEN & ~SIOTOP_SCACTR_SCAREN);
+	serial_out(port, SIOTOP_SCACTR, control);
+
+	if (uart->timeout) {
+#ifdef USE_HRTIMER
+		hrtimer_cancel(&port->timer);
+#else
+		del_timer_sync(&port->timer);
+#endif
+	}
+
+	/* Intr Handler unregister */
+	free_irq(port->rx_irq, port);
+	free_irq(port->tx_irq, port);
+}
+
+/**
+ * According to the specified baudrate value, the update of the minute cycle register value.
+ *
+ * @param port		serial port
+ * @param baudrate	change the baudrate value
+ * @param exclk		SIOTOP_CYCLE register value
+ * @retval 0		Success
+ * @retval -EINVAL  	baudrate is illegality
+ */
+static int mn_sioext_get_exclk(struct mn_sioext_port *port, int baudrate, u32 *exclk)
+{
+	int	i, mindiff;
+	u64	tmp;
+	int	cycle[DIVMODE_NUMB], dmode[DIVMODE_NUMB], ldlt[DIVMODE_NUMB];
+	const int divmode[] = {
+		10000,
+		5000,
+		2500,
+		1250,
+		625,
+	};
+
+	if (DIV_ROUND_CLOSEST(port->uart.uartclk/8, 0xFFF+1) > baudrate ||
+	    baudrate > DIV_ROUND_CLOSEST(port->uart.uartclk/8, 2))
+		return -EINVAL;
+	tmp = (u64)((u64)port->uart.uartclk/8 * FIXED_DEC);
+	cycle[0] = DIV_ROUND_CLOSEST_ULL(tmp, baudrate);
+	for(i = 0; i < DIVMODE_NUMB; i++) {
+		cycle[i] = cycle[0] - divmode[i];
+		dmode[i] = cycle[i] % FIXED_DEC;
+		if ((cycle[i]-FIXED_DEC) >= 0)
+			ldlt[i] = min(dmode[i], FIXED_DEC-dmode[i]);
+		else
+			ldlt[i] = dmode[i];
+	}
+	for(i = mindiff = 0; i < DIVMODE_NUMB; i++) {
+		if (ldlt[mindiff] > ldlt[i])
+			mindiff = i;
+	}
+	*exclk = DIV_ROUND_CLOSEST(cycle[mindiff], FIXED_DEC);
+	if (mindiff != 0)
+		*exclk |= 0x00001000 << (mindiff - 1);
+
+	return 0;
+}
+
+/**
+ * Set the terminal I/O parameters
+ *
+ * @param uart  uart port
+ * @param new   termios to be set up from now on
+ * @param old   termios before a setup
+ */
+static void mn_sioext_set_termios(struct uart_port *uart,
+				  struct ktermios *new,
+				  struct ktermios *old)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	unsigned cflag;
+	int baud, bits, xdiv;
+	u32 cycle, scactr, tmp, cnfig, exclk = 0;
+	unsigned long flags;
+
+	/* IP reset */
+	cnfig = serial_in(port, SIOTOP_CNFIG);
+	cnfig |= SIOTOP_CNFIG_RESET;
+	serial_out(port, SIOTOP_CNFIG, cnfig);
+
+	/* Set byte size */
+	cflag = new->c_cflag;
+	switch (cflag & CSIZE) {
+	case CS7:
+		scactr = SIOTOP_SCACTR_CLN_7BIT;
+		bits = 9;
+		break;
+	case CS8:
+		scactr = SIOTOP_SCACTR_CLN_8BIT;
+		bits = 10;
+		break;
+	default:
+		scactr = SIOTOP_SCACTR_CLN_8BIT;
+		bits = 10;
+		break;
+	}
+
+	/* Set stop bit mode */
+	if (cflag & CSTOPB) {
+		scactr |= SIOTOP_SCACTR_STB_2BIT;
+		bits++;
+	}
+
+	/* Set parity bit mode */
+	if (cflag & PARENB) {
+		bits++;
+		if (cflag & PARODD) {
+			scactr |= SIOTOP_SCACTR_ODD;
+		} else if (cflag & CMSPAR) {
+			scactr |= SIOTOP_SCACTR_FIXED0;
+		} else {
+			scactr |= SIOTOP_SCACTR_EVEN;
+		}
+	}
+
+	/* change protocol start-stop transmission */
+	scactr |= (SIOTOP_SCACTR_SCAPTL_SYNC | SIOTOP_SCACTR_CK_IOCLK_16);
+
+	/* Determine divisor based on baud rate */
+	baud = uart_get_baud_rate(&port->uart, new, old, 0,
+				  port->uart.uartclk/8);
+	if (!baud) {
+		baud = 9600;	/* B0 transition handled in rs_set_termios */
+	}
+
+	if (chiprevst == CHIPREVST_CHIPREV_ES2) {
+		cycle = __raw_readl(port->uart.membase + SIOTOP_CYCLE);
+		if (baud != port->baudrate) {
+			if(mn_sioext_get_exclk(port, baud, &exclk) != 0)
+				dev_err(port->uart.dev,
+					"setting the minute period failed\n");
+			else {
+				cycle = exclk;
+				port->baudrate = baud;
+			}
+		}
+	} else {
+		xdiv = 1;
+		if (baud == 134) {
+			baud = 269;	/* 134 is really 134.5 */
+			xdiv = 2;
+		}
+
+		/* round(uartclk / (baud / xdiv) / 2 - 1) */
+		cycle = (port->uart.uartclk / 8 / (baud / xdiv) - 1) / 2;
+		port->baudrate = baud;
+	}
+	dev_info(port->uart.dev, "baudrate(%d)SIOTOP_CYCLE(%04x)\n",
+		 baud, cycle);
+
+	/* make the changes */
+	spin_lock_irqsave(&port->uart.lock, flags);
+
+#ifdef USE_SOFTWARE_CTS
+	if (port->capabilities & UART_CAP_AFE) {
+		if (port->frtscts == 1) {
+			port->crtscts = CRTSCTS;
+			mn_sioext_set_rtsctl(port, CRTSCTS);
+		} else {
+			if (cflag & CRTSCTS) {
+				port->crtscts = CRTSCTS;
+			} else {
+				port->crtscts = 0;
+			}
+			mn_sioext_set_rtsctl(port, cflag & CRTSCTS);
+		}
+	} else {
+		mn_sioext_set_rtsctl(port, CRTSCTS);
+	}
+#else
+	mn_sioext_set_rtsctl(port, CRTSCTS);
+#endif
+
+	/* set prescaler */
+	while(serial_in(port, SIOTOP_SCASTR) &
+	      (SIOTOP_SCASTR_TBSY | SIOTOP_SCASTR_RBSY));
+	serial_out(port, SIOTOP_CYCLE, cycle);
+
+	tmp = 0 | SIOTOP_SCACTR_CK_IOCLK_16;
+	serial_out(port, SIOTOP_SCACTR, tmp);
+
+	/* set up parity check flag */
+	port->uart.read_status_mask = (1 << TTY_NORMAL) | (1 << TTY_OVERRUN);
+	if (new->c_iflag & INPCK) {
+		port->uart.read_status_mask |=
+			(1 << TTY_PARITY) | (1 << TTY_FRAME);
+	}
+	if (new->c_iflag & (BRKINT | PARMRK)) {
+		port->uart.read_status_mask |= (1 << TTY_BREAK);
+	}
+
+	/* characters to ignore */
+	port->uart.ignore_status_mask = 0;
+	if (new->c_iflag & IGNPAR) {
+		port->uart.ignore_status_mask |=
+			(1 << TTY_PARITY) | (1 << TTY_FRAME);
+	}
+	if (new->c_iflag & IGNBRK) {
+		port->uart.ignore_status_mask |= (1 << TTY_BREAK);
+		/*
+		 * If we're ignoring parity and break indicators,
+		 * ignore overruns to (for real raw support).
+		 */
+		if (new->c_iflag & IGNPAR) {
+			port->uart.ignore_status_mask |= (1 << TTY_OVERRUN);
+		}
+	}
+
+	/* Ignore all characters if CREAD is not set */
+	if ((new->c_cflag & CREAD) == 0) {
+		port->uart.ignore_status_mask |= (1 << TTY_NORMAL);
+	}
+
+	tmp = serial_in(port, SIOTOP_SCACTR);
+	scactr |= (tmp | (SIOTOP_SCACTR_SCATEN | SIOTOP_SCACTR_SCAREN));
+	serial_out(port, SIOTOP_SCACTR, scactr);
+
+	cnfig = serial_in(port, SIOTOP_CNFIG);
+	cnfig |= (SIOTOP_CNFIG_RXC_TXC | SIOTOP_CNFIG_DIR_DI | SIOTOP_CNFIG_DOE);
+	serial_out(port, SIOTOP_CNFIG, cnfig);
+
+	spin_unlock_irqrestore(&port->uart.lock, flags);
+}
+
+/**
+ * Return description of port type
+ *
+ * @param uart  uart port
+ * @return  port description
+ */
+static const char *mn_sioext_type(struct uart_port *uart)
+{
+	return "MN-SIOEXT";
+}
+
+/**
+ * Request I/O and memory regions for port
+ *
+ * @param uart  uart port
+ * @retval  0  success
+ * @retval <0  failure
+ */
+static int mn_sioext_request_port(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	void *map_adr;
+
+	if (!uart->mapbase) {
+		return 0;
+	}
+	map_adr = ioremap_nocache(port->uart.mapbase, SIOTOP_REG_SIZE);
+	if (!map_adr) {
+		return -ENOMEM;
+	}
+	uart->membase = (void *)map_adr;
+
+	request_mem_region((unsigned long)port->uart.mapbase, SIOTOP_REG_SIZE, port->name);
+	return 0;
+}
+
+/**
+ * Configure the type and reserve the ports
+ *
+ * @param uart  uart port
+ * @param type
+ */
+static void mn_sioext_config_port(struct uart_port *uart, int type)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+
+	port->uart.type = PORT_MN_SIOEXT;
+
+	mn_sioext_request_port(uart);
+}
+
+/**
+ * Release I/O and memory regions in use by port
+ *
+ * @param uart  uart port
+ */
+static void mn_sioext_release_port(struct uart_port *uart)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+
+	iounmap(port->uart.membase);
+
+	release_mem_region((unsigned long)port->uart.mapbase, SIOTOP_REG_SIZE);
+}
+
+/**
+ * Verify serial parameters are suitable for this port type
+ *
+ * @param uart  uart port
+ * @param ss    serial information
+ * @retval 0  success
+ * @retval <0 failure
+ */
+static int mn_sioext_verify_port(struct uart_port *uart,
+				 struct serial_struct *ss)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+	void *mapbase = (void *) (unsigned long) port->uart.mapbase;
+
+	/* these things may not be changed */
+	if (ss->irq		!= port->uart.irq	||
+	    ss->port		!= port->uart.iobase	||
+	    ss->io_type		!= port->uart.iotype	||
+	    ss->iomem_base	!= mapbase ||
+	    ss->iomem_reg_shift	!= port->uart.regshift	||
+	    ss->hub6		!= port->uart.hub6	||
+	    ss->xmit_fifo_size	!= port->uart.fifosize) {
+		return -EINVAL;
+	}
+
+	if (ss->type != port->uart.type) {
+		return -EINVAL;
+	}
+
+	if (ss->type != PORT_MN_SIOEXT) {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * It waits until transmission becomes possible
+ *
+ * @param port  serial port
+ * @retval 0           success
+ * @retval -EREMOTEIO  time out error
+ */
+static int mn_sioext_wait_for_enable_transfer(struct mn_sioext_port *port)
+{
+	int ret = 0;
+	unsigned int tmout = 10000;
+	u32 scastr, txtva;
+
+	scastr = serial_in(port, SIOTOP_SCASTR);
+	txtva  = serial_in(port, SIOTOP_TXTVA);
+	while (!(txfifo_can_transfer(scastr) &&
+		 txfifo_usable_size(txtva))) {
+		if (--tmout == 0) {
+			dev_dbg(port->uart.dev, "[mn] enable wait timeout\n");
+			ret = -EREMOTEIO;
+			break;
+		}
+		udelay(1);
+		scastr = serial_in(port, SIOTOP_SCASTR);
+		txtva  = serial_in(port, SIOTOP_TXTVA);
+	}
+	return ret;
+}
+
+/**
+ * It waits until transmission complete.
+ *
+ * @param port  serial port
+ * @retval 0           success
+ * @retval -EREMOTEIO  time out error
+ */
+static int mn_sioext_wait_for_tx_complete(struct mn_sioext_port *port)
+{
+	int ret = 0;
+	unsigned int tmout = 10000;
+	u32 scastr, txtva;
+
+	scastr = serial_in(port, SIOTOP_SCASTR);
+	txtva  = serial_in(port, SIOTOP_TXTVA);
+	while ((txfifo_is_empty(&port->uart, txtva) == 0) ||
+	       (txfifo_can_transfer(scastr) == 0)) {
+		if (--tmout == 0) {
+			dev_dbg(port->uart.dev, "[mn] tx wait timeout\n");
+			ret = -EREMOTEIO;
+			break;
+		}
+		udelay(1);
+		scastr = serial_in(port, SIOTOP_SCASTR);
+		txtva  = serial_in(port, SIOTOP_TXTVA);
+	}
+	return ret;
+}
+
+/**
+ * One character is outputted in console processing
+ *
+ * @param uart  uart port
+ * @param ch    output character
+ */
+static void mn_sioext_console_putchar(struct uart_port *uart, int ch)
+{
+	struct mn_sioext_port *port =
+		container_of(uart, struct mn_sioext_port, uart);
+
+	/* ch -> trans buffer */
+	if (!mn_sioext_wait_for_enable_transfer(port)) {
+		serial_out(port, SIOTOP_TXDATA, ch);
+	}
+}
+
+
+static struct uart_driver mn_sioext_driver;
+static struct console mn_sioext_console = {
+	.name		= "ttySM",
+	.write		= mn_sioext_console_write,
+	.device		= uart_console_device,
+	.setup		= mn_sioext_console_setup,
+	.flags		= CON_PRINTBUFFER,
+	.index		= -1,
+	.data		= &mn_sioext_driver,
+};
+
+static struct uart_driver mn_sioext_driver = {
+	.owner		= NULL,
+	.driver_name	= "sioext-serial",
+	.dev_name	= "ttySM",
+	.major		= TTY_MAJOR,
+	.minor		= 128,
+	.nr		= NR_PORTS,
+	.cons		= &mn_sioext_console,
+};
+
+/*
+ * list of available serial ports
+ */
+static struct mn_sioext_port mn_sioext_ports[NR_PORTS];
+
+/**
+ * Print a string to the serial port without disturbing the real user
+ * of the port too much
+ * - the console must be locked by the caller
+ *
+ * @param co     console
+ * @param s      pointer of output buffer
+ * @param count  ouput count
+ */
+static void mn_sioext_console_write(struct console *co,
+				    const char *s, unsigned count)
+{
+	struct mn_sioext_port *port;
+	unsigned long flags;
+	int locked = 1;
+	u32 control, tmp;
+
+	port = &mn_sioext_ports[co->index];
+
+	local_irq_save(flags);
+	if (port->uart.sysrq) {
+		locked = 0;
+	} else if (oops_in_progress) {
+		locked = spin_trylock(&port->uart.lock);
+	} else {
+		spin_lock(&port->uart.lock);
+	}
+
+	control = serial_in(port, SIOTOP_TXCNT);
+	tmp = control;
+	if (!(tmp & SIOTOP_TXCNT_TXD_EN)) {
+		tmp &= ~SIOTOP_TXCNT_EI;
+		tmp |= (SIOTOP_TXCNT_FIFO_CLR | SIOTOP_TXCNT_TXD_EN);
+		serial_out(port, SIOTOP_TXCNT, tmp);
+	}
+
+	uart_console_write(&port->uart, s, count, mn_sioext_console_putchar);
+
+	mn_sioext_wait_for_tx_complete(port);
+
+	serial_out(port, SIOTOP_TXCNT, control);
+
+	if (locked) {
+		spin_unlock(&port->uart.lock);
+	}
+	local_irq_restore(flags);
+}
+
+/**
+ * Set up a serial port as a console
+ * - construct a cflag setting for the first rs_open()
+ * - initialize the serial port
+ * - return non-zero if we didn't find a serial port.
+ *
+ * @param co       console
+ * @param options  configuration information of a console
+ * @retval 0   success
+ * @retval <0  failure
+ **/
+static int __init mn_sioext_console_setup(struct console *co, char *options)
+{
+	struct mn_sioext_port *port;
+	int parity = 'n', baud = 9600, bits = 8, flow = 0;
+
+	if ((co->index < 0) || (co->index > (NR_PORTS - 1))) {
+		return -ENODEV;
+	}
+
+	port = &mn_sioext_ports[co->index];
+	if (!port->uart.membase) {
+		return -ENODEV;
+	}
+
+	if (options)
+		uart_parse_options(options, &baud, &parity, &bits, &flow);
+
+	return uart_set_options(&port->uart, co, baud, parity, bits, flow);
+}
+
+/**
+ * Register console
+ *
+ * @return 0  success
+ */
+static int __init mn_sioext_console_init(void)
+{
+	register_console(&mn_sioext_console);
+	return 0;
+}
+
+console_initcall(mn_sioext_console_init);
+
+/**
+ * Reading of CHIPREVST register
+ *
+ * @param ofdev		Platform device
+ * @retval 0		Success
+ * @retval -ENOMEM	Memory map could not be acquired
+ */
+static int mn_sioext_get_lsirevision(struct platform_device *ofdev)
+{
+	unsigned char __iomem	*revreg;
+
+	revreg = ioremap(CHIPREVST_ADDR, CHIPREVST_SIZE);
+	if (revreg == 0) {
+		dev_err(&ofdev->dev, "failed to ioremap CHIPREVST\n");
+		return  -ENOMEM;
+	}
+
+	chiprevst = __raw_readl(revreg);
+
+	iounmap(revreg);
+
+	return 0;
+}
+
+#ifdef USE_HRTIMER
+static enum hrtimer_restart mn_sioext_timeout(struct hrtimer *data)
+{
+	struct mn_sioext_port *port = container_of(data, struct mn_sioext_port, timer);
+
+	mn_sioext_interrupt(port->rx_irq, port);
+
+	return HRTIMER_NORESTART;
+}
+#else
+static void mn_sioext_timeout(unsigned long data)
+{
+	struct mn_sioext_port *port = (struct mn_sioext_port *)data;
+
+	mn_sioext_interrupt(port->rx_irq, port);
+}
+#endif
+
+/**
+ * Fill a struct uart_port for a given device node
+ *
+ * @param ofdev  Platform device
+ * @param type   UART type
+ * @param port   UART port
+ * @param priv   Driver private data
+ * @retval 0        Success
+ * @retval -EINVAL  The resource definition is incorrectly
+ * @retval -ENOENT  The clk definition is incorrectly
+ */
+static int of_platform_serial_setup(struct platform_device *ofdev,
+				    int type, struct mn_sioext_port *port,
+				    struct mn_sioext_priv *priv)
+{
+	struct resource *regs = platform_get_resource(ofdev, IORESOURCE_MEM, 0);
+	int tx_irq = platform_get_irq_byname(ofdev, "tx");
+	int rx_irq = platform_get_irq_byname(ofdev, "rx");
+	struct device_node *np = ofdev->dev.of_node;
+	u32 prop;
+
+	if ((regs == NULL) || (rx_irq < 0) || (tx_irq < 0)) {
+		dev_err(&ofdev->dev, "[mn] missing registers or irq\n");
+		return -EINVAL;
+	}
+
+	port->uart.irq = rx_irq;
+	port->rx_irq = rx_irq;
+	port->tx_irq = tx_irq;
+
+	/* Get clk rate through clk driver if present */
+	priv->clk = clk_get(&ofdev->dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_warn(&ofdev->dev, "[mn] clk not defined\n");
+		return PTR_ERR(priv->clk);
+	}
+	clk_prepare_enable(priv->clk);
+	port->uart.uartclk = clk_get_rate(priv->clk) / 2;
+
+	port->uart.mapbase = regs->start;
+
+	/* Check for fifo size */
+	if (of_property_read_u32(np, "fifo-size", &prop) == 0) {
+		port->uart.fifosize = prop;
+	} else {
+		port->uart.fifosize = SIOEXT_FIFO_SIZE;
+	}
+
+	if (of_property_read_u32(np, "timeout", &prop) == 0) {
+#ifdef USE_HRTIMER
+		hrtimer_init(&port->timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+#else
+		init_timer(&port->timer);
+		port->timer.data = (unsigned long)port;
+#endif
+		port->uart.timeout = prop;
+		port->timer.function = mn_sioext_timeout;
+	}
+
+	port->uart.iotype = UPIO_MEM32;
+	port->uart.type = type;
+	port->uart.flags = UPF_SHARE_IRQ | UPF_BOOT_AUTOCONF | UPF_IOREMAP |
+		UPF_FIXED_PORT | UPF_FIXED_TYPE | UPF_SKIP_TEST;
+#ifdef USE_SOFTWARE_CTS
+	port->capabilities = 0;
+	port->crtscts = 0;
+	port->frtscts = 0;
+	port->cts_gpio = -1;
+	if (of_property_read_bool(np, "auto-flow-control")) {
+		port->capabilities = UART_CAP_AFE;
+	}
+	if (of_property_read_bool(np, "force-auto-flow-control")) {
+		port->frtscts = 1;
+	}
+	if (of_property_read_u32(np, "cts-gpio-number", &prop) == 0) {
+		if (0 <= prop && prop <= 194) {
+			port->cts_gpio = prop;
+		} else {
+			dev_err(&ofdev->dev, "cts-gpio-number is invalid parameter\n");
+			return -EINVAL;
+		}
+	}
+	if (port->capabilities == UART_CAP_AFE && port->cts_gpio == -1) {
+		dev_err(&ofdev->dev, "cts-gpio-number not specify.\n");
+		return -EINVAL;
+	}
+#endif
+
+	return 0;
+}
+
+static void mn_sioext_set_rtsctl(struct mn_sioext_port *port, int crts)
+{
+	u32 control;
+
+	/* set RTS control info */
+	control = SIOTOP_RTSCTL_READYTHR(3) | SIOTOP_RTSCTL_BUSYTHR(2) |
+		SIOTOP_RTSCTL_POLARITY;
+	if (crts & CRTSCTS)
+		control |= SIOTOP_RTSCTL_EN;
+	else
+		control &= ~SIOTOP_RTSCTL_EN;
+	/* RTS control register rewrite */
+	__raw_writel(control, port->uart.membase + SIOTOP_RTSCTL);
+}
+
+/**
+ * Probe UART driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ * @retval -ENOMEM  Failed to kzalloc
+ * @retval -EINVAL  The resource definition is incorrectly
+ * @retval -ENOENT  The clk definition is incorrectly
+ */
+static int mn_sioext_probe(struct platform_device *pdev)
+{
+	struct mn_sioext_priv *priv;
+	struct mn_sioext_port *up;
+	int ret;
+	int line = 0;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (priv == NULL) {
+		dev_err(&pdev->dev, "[mn] unable to allocate private data\n");
+		return -ENOMEM;
+	}
+
+	up = &mn_sioext_ports[line];
+
+	spin_lock_init(&up->uart.lock);
+
+	ret = of_platform_serial_setup(pdev, PORT_MN_SIOEXT, up, priv);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "[mn] unable to setup 8250 port\n");
+		return ret;
+	}
+
+
+	ret = mn_sioext_get_lsirevision(pdev);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "unable to read LSI revision\n");
+		return ret;
+	}
+
+
+	up->uart.dev = &pdev->dev;
+	up->uart.private_data = priv;
+
+	priv->line = line;
+	platform_set_drvdata(pdev, priv);
+
+	ret = uart_add_one_port(&mn_sioext_driver, &up->uart);
+
+	if (ret < 0) {
+		dev_err(&pdev->dev, "[mn] unable to register 8250 port\n");
+		if (priv->clk != NULL)
+			clk_disable_unprepare(priv->clk);
+		return ret;
+	}
+
+#ifdef USE_SOFTWARE_CTS
+	up->gpio_membase = ioremap_nocache(GPIO_ADDR, GPIO_SIZE);
+	if (!(up->gpio_membase)) {
+		return -ENOMEM;
+	}
+#else
+	mn_sioext_set_rtsctl(up, CRTSCTS);
+#endif
+
+	return 0;
+}
+
+/**
+ * Remove UART driver
+ *
+ * @param pdev  Platform device
+ * @retval 0        Success
+ */
+static int mn_sioext_remove(struct platform_device *pdev)
+{
+	struct mn_sioext_priv *priv = platform_get_drvdata(pdev);
+#ifdef USE_SOFTWARE_CTS
+	struct mn_sioext_port *up;
+
+	up = &mn_sioext_ports[priv->line];
+	iounmap(up->gpio_membase);
+#endif
+	clk_disable_unprepare(priv->clk);
+	return 0;
+}
+
+static const struct of_device_id mn_sioext_dt_ids[] = {
+	{ .compatible = "panasonic,mn-sioext", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mn_sioext_dt_ids);
+
+static struct platform_driver mn_sioext_platform_driver = {
+	.driver = {
+		.name		= "mn-sioext",
+		.of_match_table = mn_sioext_dt_ids,
+		.owner		= THIS_MODULE,
+	},
+	.probe			= mn_sioext_probe,
+	.remove			= mn_sioext_remove,
+};
+
+/**
+ * Initialise the SIOEXT UARTs
+ *
+ * @retval 0   success
+ * @retval <0  failure
+ */
+static int __init mn_sioext_init(void)
+{
+	struct mn_sioext_port *port;
+	int ret, i;
+
+	ret = uart_register_driver(&mn_sioext_driver);
+	if (ret) {
+		pr_err("[mn] uart_register_driver failed: %d\n", ret);
+		goto error;
+	}
+	for (i = 0 ; i < NR_PORTS ; i++) {
+		port = &mn_sioext_ports[i];
+		port->name		= "ttySM";
+		port->type		= PORT_MN_SIOEXT;
+		port->uart.ops		= &mn_sioext_ops;
+		port->uart.line		= i;
+		port->uart.type		= PORT_MN_SIOEXT;
+	}
+
+	ret = platform_driver_register(&mn_sioext_platform_driver);
+	if (ret) {
+		pr_err("[mn] platform_driver_register failed: %d\n", ret);
+		uart_unregister_driver(&mn_sioext_driver);
+	}
+
+error:
+	return ret;
+}
+__initcall(mn_sioext_init);
diff -uNr linux-3.14.19/drivers/tty/serial/mn_sioext.h linux-gerda/drivers/tty/serial/mn_sioext.h
--- linux-3.14.19/drivers/tty/serial/mn_sioext.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/tty/serial/mn_sioext.h	2017-06-22 09:52:45.855039457 +0900
@@ -0,0 +1,72 @@
+/*
+ * SIOEXT serial port driver definitions
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+#ifndef MN_SIOEXT_H_
+#define MN_SIOEXT_H_
+
+#include "mn_sioext_regs.h"
+
+#ifdef CONFIG_ARCH_GERDA
+#define SIOEXT_FIFO_SIZE		64
+#define SIOEXT_RX_DEFAULT_THRESHOLD	1
+#define SIOEXT_RX_TIMEOUT_THRESHOLD	60
+#define SIOEXT_ADAPTED_WAIT_THRESHOLD	8
+#else
+#error need to implement an architecture specific drivers/tty/serial/mn_sioext.h
+#endif
+#define DIVMODE_NUMB 5
+#define FIXED_DEC    10000
+
+struct mn_sioext_port {
+	const char		*name;		/* name of serial port */
+	unsigned short		type;		/* type of serial port */
+
+	struct uart_port	uart;
+#ifdef USE_HRTIMER
+	struct hrtimer		timer;
+#else
+	struct timer_list	timer;
+#endif
+
+	u8			tx_xchar;	/* high-priority XON/XOFF buffer */
+	unsigned short		tx_break;	/* current break reception status */
+	int			rx_irq;		/* reception IRQ */
+	int			tx_irq;		/* transmission IRQ */
+	unsigned int		baudrate;	/* private baudrate */
+#ifdef USE_SOFTWARE_CTS
+	int			capabilities;	/* auto flow control */
+	int			crtscts;	/* RTS/CTS on/off */
+	int			frtscts;	/* force RTS/CTS on */
+	void __iomem		*gpio_membase;	/* ioremap cookie or NULL */
+	int			cts_gpio;	/* specify gpio number */
+#endif
+};
+
+struct mn_sioext_priv {
+	struct clk *clk;
+	int line;
+};
+
+struct mn_sioext_baudrate_table {
+	unsigned int		baudrate;	/* baudrate */
+	unsigned short		mode;		/* EXCLK divemode */
+	unsigned short		period;		/* Minute period */
+};
+
+void mn_sioext_direct_console_write(struct mn_sioext_port *,
+					const char *, unsigned);
+void mn_sioext_fifo_console_write(struct mn_sioext_port *,
+					const char *, unsigned);
+int mn_sioext_ioremap(struct mn_sioext_port *port);
+
+extern const struct uart_ops mn_sioext_direct_ops;
+extern const struct uart_ops mn_sioext_fifo_ops;
+
+#endif /* MN_SIOEXT_H_ */
diff -uNr linux-3.14.19/drivers/tty/serial/mn_sioext_regs.h linux-gerda/drivers/tty/serial/mn_sioext_regs.h
--- linux-3.14.19/drivers/tty/serial/mn_sioext_regs.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/tty/serial/mn_sioext_regs.h	2017-06-22 09:52:45.675039463 +0900
@@ -0,0 +1,149 @@
+/*
+ * SIOEXT serial registers
+ *
+ * Copyright (C) 2015 Panasonic Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public Licence
+ * as published by the Free Software Foundation; either version
+ * 2 of the Licence, or (at your option) any later version.
+ */
+#ifndef MN_SIOEXT_REGS_H_
+#define MN_SIOEXT_REGS_H_
+
+#ifdef __KERNEL__
+
+#define NR_PORTS                1
+#define SIOTOP_REG_SIZE		0x00000100
+
+/* register offset address */
+#define SIOTOP_CNFIG		0x00000000	/* config */
+#define SIOTOP_CYCLE		0x00000004	/* EXCLK */
+#define SIOTOP_RXDATA		0x00000008	/* receive buffer */
+#define SIOTOP_RXTVA		0x0000000C	/* receive buffer remain */
+#define SIOTOP_RXTRS		0x00000010	/* receive buffer threshold */
+#define SIOTOP_RXCNT		0x00000014	/* receive control */
+#define SIOTOP_TXDATA		0x00000018	/* transmit buffer */
+#define SIOTOP_TXTVA		0x0000001C	/* transmit buffer remain */
+#define SIOTOP_TXTRS		0x00000020	/* transmit buffer threshold */
+#define SIOTOP_TXFIN		0x00000024	/* transmit buffer set remain */
+#define SIOTOP_TXCNT		0x00000028	/* transmit control */
+#ifdef CONFIG_ARCH_GERDA
+#define SIOTOP_SCACTR		0x00000040	/* control */
+#define SIOTOP_SCASTR		0x00000044	/* store */
+#define SIOTOP_STATUS		0x00000050	/* status */
+#else
+#error need to implement an architecture specific drivers/tty/serial/mn_sioext_regs.h
+#endif
+
+/* SIOTOP_CNFIG register bit assignment */
+#define SIOTOP_CNFIG_BYPASS	0x8000		/* bypas switch */
+#define SIOTOP_CNFIG_MODEM	0x3000		/* trans mode */
+#define SIOTOP_CNFIG_MODEM_ASC	0x0000		/* - start-stop synchronous */
+#define SIOTOP_CNFIG_MODEM_SSC	0x1000		/* - clock synchronous  */
+#define SIOTOP_CNFIG_RESET	0x0100		/* IP reset */
+#define SIOTOP_CNFIG_CLK	0x0010		/* SSC receive signal */
+#define SIOTOP_CNFIG_CLK_DOWN	0x0000		/* - down edge signal */
+#define SIOTOP_CNFIG_CLK_UP	0x0010		/* - up edge signal */
+#define SIOTOP_CNFIG_RXC	0x0008		/* rxc input select */
+#define SIOTOP_CNFIG_RXC_GIO	0x0000		/* - GIO_CK_I */
+#define SIOTOP_CNFIG_RXC_TXC	0x0008		/* - txc */
+#define SIOTOP_CNFIG_COE	0x0004		/* SIO_CK_O output enable */
+#define SIOTOP_CNFIG_COE_IN	0x0000		/* - input */
+#define SIOTOP_CNFIG_COE_PUT	0x0004		/* - output */
+#define SIOTOP_CNFIG_DIR	0x0002		/* data input setting */
+#define SIOTOP_CNFIG_DIR_DO	0x0000		/* - GIO_DO_I */
+#define SIOTOP_CNFIG_DIR_DI	0x0002		/* - GIO_DI_I */
+#define SIOTOP_CNFIG_DOE	0x0001		/* data output enable */
+
+/* SIOTOP_RXCNT register bit assignment */
+#define SIOTOP_RXCNT_RXD_FLAG	0x1000		/* check receive interrupt */
+#define SIOTOP_RXCNT_EI		0x0080		/* interrupt enable */
+#define SIOTOP_RXCNT_FIFO_CLR	0x0002		/* FIFO clear */
+
+/* SIOTOP_CYCLE reg bit */
+#define SIOTOP_CYCLE_DIVMODE_MODE0	0x0000	/* EXCLK division setting mode of 0 */
+#define SIOTOP_CYCLE_DIVMODE_MODE1	0x1000	/* EXCLK division setting mode of 1 */
+#define SIOTOP_CYCLE_DIVMODE_MODE2	0x2000	/* EXCLK division setting mode of 2 */
+#define SIOTOP_CYCLE_DIVMODE_MODE4	0x4000	/* EXCLK division setting mode of 4 */
+#define SIOTOP_CYCLE_DIVMODE_MODE8	0x8000	/* EXCLK division setting mode of 8 */
+#define SIOTOP_RXCNT_RXD_EN	0x0001		/* receive enable */
+
+/* SIOTOP_TXCNT register bit assignment */
+#define SIOTOP_TXCNT_EI_FIN	0x8000		/* interrupt enable bit for bug fix */
+#define SIOTOP_TXCNT_TXD_FLAG	0x1000		/* check transmit interrupt */
+#define SIOTOP_TXCNT_EI		0x0080		/* interrupt enable */
+#define SIOTOP_TXCNT_FIFO_CLR	0x0002		/* FIFO clear */
+#define SIOTOP_TXCNT_TXD_EN	0x0001		/* transmit enable */
+
+/* SIOTOP_SCACTR register bit assignment */
+#define SIOTOP_SCACTR_SCATEN		0x8000		/* transmit enable */
+#define SIOTOP_SCACTR_SCAREN		0x4000		/* receive enable */
+#define SIOTOP_SCACTR_SCABRE		0x2000		/* break transmit enable */
+#define SIOTOP_SCACTR_SCAPTL		0x0800		/* mode select */
+#define SIOTOP_SCACTR_SCAPTL_SYNC	0x0000		/* - start-stop synchronous */
+#define SIOTOP_SCACTR_SCAPTL_CLOCK_SYNC	0x0800		/* - clock synchronous */
+#define SIOTOP_SCACTR_SCAOB		0x0200		/* bit order select */
+#define SIOTOP_SCACTR_SCAOB_LSB		0x0000		/* - LSB first */
+#define SIOTOP_SCACTR_SCAOB_MSB		0x0200		/* - MSB first */
+#define SIOTOP_SCACTR_CLN		0x0080		/* character length */
+#define SIOTOP_SCACTR_CLN_7BIT		0x0000		/* - 7 bit chars */
+#define SIOTOP_SCACTR_CLN_8BIT		0x0080		/* - 8 bit chars */
+#define SIOTOP_SCACTR_SCAPTY		0x0070		/* parity bit select */
+#define SIOTOP_SCACTR_NONE		0x0000		/* - no parity */
+#define SIOTOP_SCACTR_FIXED0		0x0040		/* - fixed at 0 */
+#define SIOTOP_SCACTR_FIXED1		0x0050		/* - fixed at 1 */
+#define SIOTOP_SCACTR_EVEN		0x0060		/* - even parity */
+#define SIOTOP_SCACTR_ODD		0x0070		/* - odd parity */
+#define SIOTOP_SCACTR_STB		0x0008		/* stop bit select */
+#define SIOTOP_SCACTR_STB_1BIT		0x0000		/* - 1 stop bit */
+#define SIOTOP_SCACTR_STB_2BIT		0x0008		/* - 2 stop bits */
+#define SIOTOP_SCACTR_CK		0x0003		/* clock source select */
+#define SIOTOP_SCACTR_CK_IOCLK_2	0x0001		/* - 1/2 IOCLK */
+#define SIOTOP_SCACTR_CK_IOCLK_16	0x0003		/* - 1/16 IOCLK */
+
+/* SIOTOP_SCASTR register bit assignment */
+#define SIOTOP_SCASTR_TBSY		0x8000		/* transmit state */
+#define SIOTOP_SCASTR_TBSY_OK		0x0000		/* - transmit enable */
+#define SIOTOP_SCASTR_TBSY_BSY		0x8000		/* - busy */
+#define SIOTOP_SCASTR_RBSY		0x4000		/* receive state */
+#define SIOTOP_SCASTR_RBSY_OK		0x0000		/* - receive enable */
+#define SIOTOP_SCASTR_RBSY_BSY		0x4000		/* - busy */
+#define SIOTOP_SCASTR_RXA		0x1000		/* receive buffer status */
+#define SIOTOP_SCASTR_RXA_NONE		0x0000		/* - not receive data */
+#define SIOTOP_SCASTR_RXA_AVAIL		0x1000		/* - available receive data */
+#define SIOTOP_SCASTR_SCAFE		0x0400		/* framing error */
+#define SIOTOP_SCASTR_SCAPE		0x0200		/* parity error */
+#define SIOTOP_SCASTR_SCAOE		0x0100		/* overrun error */
+
+/* SIOTOP_STATUS register bit assignment */
+#define SIOTOP_STATUS_TXDIR_FIN		0x0400		/* transmit finished interrupt */
+#define SIOTOP_STATUS_TXDIR		0x0200		/* transmit interrupt */
+#define SIOTOP_STATUS_RXDIR		0x0100		/* receive interrupt */
+#define SIOTOP_STATUS_RXDFOR		0x0040		/* overrun error */
+#define SIOTOP_STATUS_SCAFECLR		0x0008		/* framing error */
+#define SIOTOP_STATUS_SCAPECLR		0x0004		/* parity error */
+
+/* SIOTOP_RTSCTL reg bit */
+#define SIOTOP_RTSCTL_READYTHR(n)	(((n) << 24) & 0x7f000000)	/* ready threshold */
+#define SIOTOP_RTSCTL_BUSYTHR(n)	(((n) << 16) & 0x007f0000)	/* busy threshold */
+#define SIOTOP_RTSCTL_POLARITY		0x00000010	/* polarity control */
+#define SIOTOP_RTSCTL_EN		0x00000001	/* hardware flow control */
+#define SIOTOP_RTSCTL			0x00000054	/* RTS flow control reg */
+
+
+/* CHIPREVST register bit */
+#define CHIPREVST_ADDR			0x9C010344	/* registar address */
+#define CHIPREVST_SIZE			0x00000100	/* map size */
+#define CHIPREVST_CHIPREV_ES1		0x00000000	/* Chip revision ES1 */
+#define CHIPREVST_CHIPREV_ES2		0x00000001	/* Chip revision ES2 */
+
+/* GPIO register bit */
+#define GPIO_ADDR			0x9C016000	/* registar address */
+#define GPIO_SIZE			0x00001000	/* map size */
+#define GPIDATA0			0x40UL		/* GPIDATA0 offset no */
+#define UART_CAP_AFE			(1 << 11)	/* MCR-based hw flow control */
+
+#endif
+
+#endif /* MN_SIOEXT_REGS_H_ */
diff -uNr linux-3.14.19/drivers/usb/Kconfig linux-gerda/drivers/usb/Kconfig
--- linux-3.14.19/drivers/usb/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/Kconfig	2017-06-22 09:52:54.951039187 +0900
@@ -86,6 +86,92 @@
 
 if USB
 
+menuconfig USB_PANASONIC_HOST
+	bool "Panasonic USB Host support"
+	depends on USB_ARCH_HAS_HCD
+	select USB_PANASONIC_EHCI_IOREMAP if USB_EHCI_HCD
+	default y
+
+choice
+        prompt "System LSI Model Select"
+        default USB_PANASONIC_GERDAC if GERDAC
+        depends on USB_PANASONIC_HOST
+        help
+          This option determines the Panasonic System LSI model.
+
+config USB_PANASONIC_GERDAC
+        bool "GerdaC"
+
+endchoice
+
+config USB_PANASONIC_SINGLE_HOST
+        bool "Panasonic Host Support USB0 only"
+        depends on USB_PANASONIC_HOST
+        default y
+        ---help---
+          If unsure, say N.
+
+
+config USB_PANASONIC_GPIO_FOR_VBUS
+        bool "Panasonic Host Vbus Contorl by GPIO"
+        depends on USB_PANASONIC_HOST
+        default n
+        ---help---
+          If unsure, say N.
+
+
+config USB_PANASONIC_OC_DETECT
+        bool "Panasonic Host OverCurrent Detection and Disable auto recovery"
+        depends on USB_PANASONIC_HOST
+        default y
+        ---help---
+          If unsure, say N.
+
+
+config USB_PANASONIC_PORT_CONTROL
+        bool "Panasonic Host Port Control Support(Sysfs)"
+        depends on USB_PANASONIC_HOST
+        default y
+        ---help---
+          If unsure, say N.
+
+config USB_PANASONIC_EHCI_EXPORT
+        bool "Panasonic Host export ehci init/exit function"
+        depends on USB_PANASONIC_HOST && ( USB_EHCI_HCD = y )
+        default y
+        ---help---
+          If unsure, say N.
+
+config USB_PANASONIC_EHCI_IOREMAP
+        bool "Panasonic USB EHCI Host use ioremap"
+        depends on USB_EHCI_HCD && USB_PANASONIC_HOST 
+        default n
+        ---help---
+          If unsure, say N.
+
+config USB_PANASONIC_HOST_INTRMEM
+        bool "Panasonic Host internal memory support"
+        depends on USB_EHCI_HCD && USB_PANASONIC_HOST 
+        default n
+        ---help---
+          The Panasonic Host has a memory for Panasonic EHCI
+           host controller. Enable this option if you want to use this function.
+          If unsure, say Y.
+
+config USB_PANASONIC_HOST_RELATIVE_ADDRESS
+        bool "Panasonic USB EHCI Host use relative address"
+        depends on USB_EHCI_HCD && USB_PANASONIC_HOST 
+        default y
+        ---help---
+          If unsure, say N.
+
+config USB_PANASONIC_CABLE_STATUS
+        bool "Panasonic Host Cable Status Support"
+        depends on USB_PANASONIC_HOST
+        default y
+        ---help---
+          If unsure, say N.
+
 source "drivers/usb/core/Kconfig"
 
 source "drivers/usb/mon/Kconfig"
diff -uNr linux-3.14.19/drivers/usb/core/Makefile linux-gerda/drivers/usb/core/Makefile
--- linux-3.14.19/drivers/usb/core/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/Makefile	2017-06-22 09:52:55.043039184 +0900
@@ -7,7 +7,16 @@
 usbcore-y += devio.o notify.o generic.o quirks.o devices.o
 usbcore-y += port.o
 
+usbcore-$(CONFIG_USB_PANASONIC_HOST) += usb-panasonic.o
+
 usbcore-$(CONFIG_PCI)		+= hcd-pci.o
 usbcore-$(CONFIG_ACPI)		+= usb-acpi.o
 
+### oc_ind ###
+usbcore-$(CONFIG_USB_PANASONIC_OC_DETECT) += sysfs_oc_ind.o
+
+### port_ctrl, port_status ###
+usbcore-$(CONFIG_USB_PANASONIC_PORT_CONTROL) += sysfs_port.o
+
+
 obj-$(CONFIG_USB)		+= usbcore.o
diff -uNr linux-3.14.19/drivers/usb/core/buffer.c linux-gerda/drivers/usb/core/buffer.c
--- linux-3.14.19/drivers/usb/core/buffer.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/buffer.c	2017-06-22 09:52:55.039039184 +0900
@@ -16,6 +16,9 @@
 #include <linux/usb.h>
 #include <linux/usb/hcd.h>
 
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+#include "usb.h"
+#endif
 
 /*
  * DMA-Coherent Buffers
@@ -118,9 +121,17 @@
 
 	for (i = 0; i < HCD_BUFFER_POOLS; i++) {
 		if (size <= pool_max[i])
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			return usb_dma_pool_alloc(hcd->pool[i], mem_flags, dma);
+#else
 			return dma_pool_alloc(hcd->pool[i], mem_flags, dma);
+#endif
 	}
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	return usb_dma_alloc_coherent(hcd->self.controller, size, dma, mem_flags);
+#else
 	return dma_alloc_coherent(hcd->self.controller, size, dma, mem_flags);
+#endif
 }
 
 void hcd_buffer_free(
@@ -144,9 +155,17 @@
 
 	for (i = 0; i < HCD_BUFFER_POOLS; i++) {
 		if (size <= pool_max[i]) {
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			usb_dma_pool_free(hcd->pool[i], addr, dma);
+#else
 			dma_pool_free(hcd->pool[i], addr, dma);
+#endif
 			return;
 		}
 	}
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	usb_dma_free_coherent(hcd->self.controller, size, addr, dma);
+#else
 	dma_free_coherent(hcd->self.controller, size, addr, dma);
+#endif
 }
diff -uNr linux-3.14.19/drivers/usb/core/driver.c linux-gerda/drivers/usb/core/driver.c
--- linux-3.14.19/drivers/usb/core/driver.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/driver.c	2017-06-22 09:52:55.043039184 +0900
@@ -330,10 +330,13 @@
 	 * runtime-PM-enabled only if the driver has autosuspend support.
 	 * They are sensitive to their children's power states.
 	 */
+/* ç„¡åŠ¹ @20120229 for usb debug *//*_ GerdaC 2015/1/5 _*/
+#ifndef CONFIG_USB_PANASONIC_HOST 
 	pm_runtime_set_active(dev);
 	pm_suspend_ignore_children(dev, false);
 	if (driver->supports_autosuspend)
 		pm_runtime_enable(dev);
+#endif
 
 	/* If the new driver doesn't allow hub-initiated LPM, and we can't
 	 * disable hub-initiated LPM, then fail the probe.
@@ -386,12 +389,14 @@
 	if (!lpm_disable_error)
 		usb_unlocked_enable_lpm(udev);
 
-	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
+/* ç„¡åŠ¹ @20120229 for usb debug *//*_ GerdaC 2015/1/5 _*/
+#ifndef CONFIG_USB_PANASONIC_HOST 	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
 	if (driver->supports_autosuspend)
 		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
 
 	usb_autosuspend_device(udev);
+#endif
 	return error;
 }
 
@@ -453,10 +458,12 @@
 	if (!lpm_disable_error)
 		usb_unlocked_enable_lpm(udev);
 
-	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
+/* ç„¡åŠ¹ @20120229 for usb debug *//*_ GerdaC 2015/1/5 _*/
+#ifndef CONFIG_USB_PANASONIC_HOST	/* Unbound interfaces are always runtime-PM-disabled and -suspended */
 	if (driver->supports_autosuspend)
 		pm_runtime_disable(dev);
 	pm_runtime_set_suspended(dev);
+#endif
 
 	/* Undo any residual pm_autopm_get_interface_* calls */
 	for (r = atomic_read(&intf->pm_usage_cnt); r > 0; --r)
@@ -524,11 +531,14 @@
 	 * device from being autosuspended, but left disabled.  In either
 	 * case they are sensitive to their children's power states.
 	 */
+/* ç„¡åŠ¹ @20120229 for usb debug *//*_ GerdaC 2015/1/5 _*/
+#ifndef CONFIG_USB_PANASONIC_HOST 
 	pm_suspend_ignore_children(dev, false);
 	if (driver->supports_autosuspend)
 		pm_runtime_enable(dev);
 	else
 		pm_runtime_set_active(dev);
+#endif
 
 	/* if interface was already added, bind now; else let
 	 * the future device_add() bind it, bypassing probe()
diff -uNr linux-3.14.19/drivers/usb/core/generic.c linux-gerda/drivers/usb/core/generic.c
--- linux-3.14.19/drivers/usb/core/generic.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/generic.c	2017-06-22 09:52:55.039039184 +0900
@@ -50,6 +50,14 @@
 	if (usb_device_is_owned(udev))
 		return 0;
 
+#if CONFIG_USB_PANASONIC_GERDAC
+	/*iPod certification support
+	 *Pass "SetConfiguration" for iAP device
+	 */
+	if((udev->descriptor.idVendor == 0x05AC) && ((udev->descriptor.idProduct & 0xFF00) == 0x1200)){
+		return -1;
+	}
+#endif
 	best = NULL;
 	c = udev->config;
 	num_configs = udev->descriptor.bNumConfigurations;
diff -uNr linux-3.14.19/drivers/usb/core/hcd.c linux-gerda/drivers/usb/core/hcd.c
--- linux-3.14.19/drivers/usb/core/hcd.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/hcd.c	2017-06-22 09:52:55.035039184 +0900
@@ -1357,10 +1357,17 @@
 void usb_hcd_unmap_urb_setup_for_dma(struct usb_hcd *hcd, struct urb *urb)
 {
 	if (urb->transfer_flags & URB_SETUP_MAP_SINGLE)
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		usb_dma_unmap_single(hcd->self.controller,
+				urb->setup_dma,
+				sizeof(struct usb_ctrlrequest),
+				DMA_TO_DEVICE);
+#else
 		dma_unmap_single(hcd->self.controller,
 				urb->setup_dma,
 				sizeof(struct usb_ctrlrequest),
 				DMA_TO_DEVICE);
+#endif
 	else if (urb->transfer_flags & URB_SETUP_MAP_LOCAL)
 		hcd_free_coherent(urb->dev->bus,
 				&urb->setup_dma,
@@ -1394,15 +1401,29 @@
 				urb->num_sgs,
 				dir);
 	else if (urb->transfer_flags & URB_DMA_MAP_PAGE)
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		usb_dma_unmap_page(hcd->self.controller,
+				urb->transfer_dma,
+				urb->transfer_buffer_length,
+				dir);
+#else
 		dma_unmap_page(hcd->self.controller,
 				urb->transfer_dma,
 				urb->transfer_buffer_length,
 				dir);
+#endif
 	else if (urb->transfer_flags & URB_DMA_MAP_SINGLE)
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		usb_dma_unmap_single(hcd->self.controller,
+				urb->transfer_dma,
+				urb->transfer_buffer_length,
+				dir);
+#else
 		dma_unmap_single(hcd->self.controller,
 				urb->transfer_dma,
 				urb->transfer_buffer_length,
 				dir);
+#endif
 	else if (urb->transfer_flags & URB_MAP_LOCAL)
 		hcd_free_coherent(urb->dev->bus,
 				&urb->transfer_dma,
@@ -1441,11 +1462,19 @@
 		if (hcd->self.uses_pio_for_control)
 			return ret;
 		if (hcd->self.uses_dma) {
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			urb->setup_dma = usb_dma_map_single(
+					hcd->self.controller,
+					urb->setup_packet,
+					sizeof(struct usb_ctrlrequest),
+					DMA_TO_DEVICE);
+#else
 			urb->setup_dma = dma_map_single(
 					hcd->self.controller,
 					urb->setup_packet,
 					sizeof(struct usb_ctrlrequest),
 					DMA_TO_DEVICE);
+#endif
 			if (dma_mapping_error(hcd->self.controller,
 						urb->setup_dma))
 				return -EAGAIN;
@@ -1491,23 +1520,40 @@
 							URB_DMA_SG_COMBINED;
 			} else if (urb->sg) {
 				struct scatterlist *sg = urb->sg;
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+				urb->transfer_dma = usb_dma_map_page(
+						hcd->self.controller,
+						sg_page(sg),
+						sg->offset,
+						urb->transfer_buffer_length,
+						dir);
+#else
 				urb->transfer_dma = dma_map_page(
 						hcd->self.controller,
 						sg_page(sg),
 						sg->offset,
 						urb->transfer_buffer_length,
 						dir);
+#endif
 				if (dma_mapping_error(hcd->self.controller,
 						urb->transfer_dma))
 					ret = -EAGAIN;
 				else
 					urb->transfer_flags |= URB_DMA_MAP_PAGE;
 			} else {
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+				urb->transfer_dma = usb_dma_map_single(
+						hcd->self.controller,
+						urb->transfer_buffer,
+						urb->transfer_buffer_length,
+						dir);
+#else
 				urb->transfer_dma = dma_map_single(
 						hcd->self.controller,
 						urb->transfer_buffer,
 						urb->transfer_buffer_length,
 						dir);
+#endif
 				if (dma_mapping_error(hcd->self.controller,
 						urb->transfer_dma))
 					ret = -EAGAIN;
@@ -2656,7 +2702,9 @@
 	 * but drivers can override it in reset() if needed, along with
 	 * recording the overall controller's system wakeup capability.
 	 */
+#ifndef CONFIG_USB_PANASONIC_HOST	/*_ GerdaC 2015/1/5 _*/
 	device_set_wakeup_capable(&rhdev->dev, 1);
+#endif
 
 	/* HCD_FLAG_RH_RUNNING doesn't matter until the root hub is
 	 * registered.  But since the controller can die at any time,
diff -uNr linux-3.14.19/drivers/usb/core/hub.c linux-gerda/drivers/usb/core/hub.c
--- linux-3.14.19/drivers/usb/core/hub.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/hub.c	2017-06-22 09:52:55.039039184 +0900
@@ -5,6 +5,7 @@
  * (C) Copyright 1999 Johannes Erdfelt
  * (C) Copyright 1999 Gregory P. Smith
  * (C) Copyright 2001 Brad Hards (bhards@bigpond.net.au)
+ * (C) Copyright 2015 Panasonic Corporation
  *
  */
 
@@ -33,6 +34,10 @@
 
 #include "hub.h"
 
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+#include "../host/ehci-panasonic.h"
+#endif
+
 #define USB_VENDOR_GENESYS_LOGIC		0x05e3
 #define HUB_QUIRK_CHECK_PORT_AUTOSUSPEND	0x01
 
@@ -106,6 +111,20 @@
 #define HUB_DEBOUNCE_STEP	  25
 #define HUB_DEBOUNCE_STABLE	 100
 
+#ifdef CONFIG_USB_PANASONIC_HOST
+#define USB_ENUMERATE_ERROR		1
+#define USB_OVERCURRENT_ERROR	2
+#define USB_PORT_RESET_ERROR	3
+static inline void usb_error_uevent_notifier(struct usb_device *ud, int port1, int error_type);
+#endif
+
+/*_ GerdaC 2015/1/5 _*/
+/*_ @LINUXHOST:V0210tx[12/02/29] HIDãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­æ™‚ã«ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ä¸å…·åˆå¯¾å¿œ _*/
+/*_                             (dnote LinuxHost(2.6.32) bug No.19)            _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+static struct workqueue_struct *hub_tt_wp;
+#endif
+
 static int usb_reset_and_verify_device(struct usb_device *udev);
 
 static inline char *portspeed(struct usb_hub *hub, int portstatus)
@@ -795,7 +814,14 @@
 	/* tell keventd to clear state for this TT */
 	spin_lock_irqsave (&tt->lock, flags);
 	list_add_tail (&clear->clear_list, &tt->clear_list);
+/*_ GerdaC 2015/1/5 _*/
+/*_ @LINUXHOST:V0210tx[12/02/29] HIDãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­æ™‚ã«ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ä¸å…·åˆå¯¾å¿œ _*/
+/*_                             (dnote LinuxHost(2.6.32) bug No.19)            _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+	queue_work(hub_tt_wp, &tt->clear_work);
+#else
 	schedule_work(&tt->clear_work);
+#endif
 	spin_unlock_irqrestore (&tt->lock, flags);
 	return 0;
 }
@@ -837,6 +863,16 @@
 	return delay;
 }
 
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/8 _*/
+static void hub_power_off(struct usb_hub *hub)
+{
+	int port1;
+	
+	for (port1 = 1; port1 <= hub->descriptor->bNbrPorts; port1++)
+		usb_clear_port_feature(hub->hdev, port1, USB_PORT_FEAT_POWER);
+}
+#endif
+
 static int hub_hub_status(struct usb_hub *hub,
 		u16 *status, u16 *change)
 {
@@ -1589,6 +1625,10 @@
 
 	usb_hub_adjust_deviceremovable(hdev, hub->descriptor);
 
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+	hcd->gpio_regs = ioremap_nocache( _REG_GPODATA[USB_ADDR_TO_CH(hcd->rsrc_start)][0], 4 );	/* GPIO/io */
+#endif
+
 	hub_activate(hub, HUB_INIT);
 	return 0;
 
@@ -1626,6 +1666,17 @@
 	hub->disconnected = 1;
 	spin_unlock_irq(&hub_event_lock);
 
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+	struct usb_hcd *hcd;
+	hcd = bus_to_hcd(hub->hdev->bus);
+	iounmap(hcd->gpio_regs);	/* GPIO/io */
+#endif
+
+#ifdef CONFIG_USB_PANASONIC_PORT_CONTROL	/*_ GerdaC 2015/1/8 _*/
+/*_ @LINUXHOST:V0203nx[11/03/18] port_ctrlã‚’ç”¨ã„ãŸPort Power OFF æ™‚ã«çŠ¶æ…‹æ¤œå‡ºã§ãã‚‹ã‚ˆã†å¤‰æ›´ _*/
+	hub->hdev->hubdev = NULL;
+#endif /* CONFIG_USB_PANASONIC_PORT_CONTROL */
+
 	/* Disconnect all children and quiesce the hub */
 	hub->error = 0;
 	hub_quiesce(hub, HUB_DISCONNECT);
@@ -1767,6 +1818,11 @@
 	INIT_DELAYED_WORK(&hub->init_work, NULL);
 	usb_get_intf(intf);
 
+#ifdef CONFIG_USB_PANASONIC_PORT_CONTROL	/*_ GerdaC 2015/1/8 _*/
+	/*_ @LINUXHOST:V0203nx[11/03/18] port_ctrlã‚’ç”¨ã„ãŸPort Power OFF æ™‚ã«çŠ¶æ…‹æ¤œå‡ºã§ãã‚‹ã‚ˆã†å¤‰æ›´ _*/
+	hdev->hubdev = hub;
+#endif /* CONFIG_USB_PANASONIC_PORT_CONTROL */
+
 	usb_set_intfdata (intf, hub);
 	intf->needs_remote_wakeup = 1;
 	pm_suspend_ignore_children(&intf->dev, true);
@@ -1968,6 +2024,117 @@
 }
 EXPORT_SYMBOL_GPL(usb_set_device_state);
 
+#ifdef CONFIG_USB_PANASONIC_PORT_CONTROL	/*_ GerdaC 2015/1/8 _*/
+/*_ sysfs_port.cã§ä½¿ç”¨ã™ã‚‹ã®ã§ã€å¤–éƒ¨å…¬é–‹ã‚’è¿½åŠ ã™ã‚‹ã€‚ _*/
+int usb_set_port_status(struct usb_device* udev_ptr, u32 index, u32 status)
+{
+	return set_port_feature(udev_ptr, index, (int)status);
+}
+
+/*_ @LINUXHOST:V0203nx[11/03/18] port_ctrlã‚’ç”¨ã„ãŸPort Power OFF æ™‚ã«çŠ¶æ…‹æ¤œå‡ºã§ãã‚‹ã‚ˆã†å¤‰æ›´ _*/
+int usb_clr_port_status(struct usb_device* udev_ptr, u32 index, u32 status)
+{
+
+	u32 ret;
+	struct usb_hub *hub;
+
+    /* set new port status */
+	ret = usb_clear_port_feature(udev_ptr, index, status);
+
+	/*_ HUBæ§‹é€ ä½“ã‚’å–ã‚Šå‡ºã™ _*/
+	hub = udev_ptr->hubdev;
+
+	/*_ ãƒãƒ¼ãƒˆé›»æºOFFè¦æ±‚ãªã‚‰ã°ã€change_bitã‚’ã‚»ãƒƒãƒˆã— hub_eventå‡¦ç†ã‚’ã‚­ãƒƒã‚¯ _*/
+	if( ( hub != NULL ) && ( ret == 0 ) && ( status == USB_PORT_FEAT_POWER ) ){
+		set_bit(index, hub->change_bits);
+	 	kick_khubd(hub);
+	}
+
+    /*_ çµ‚äº† _*/
+    return ret;
+}
+
+int usb_get_port_status(struct usb_device* udev_ptr, u32 index, u32* status_ptr)
+{
+	int result;
+    struct usb_port_status port_status;
+	
+    result = get_port_status(udev_ptr, index, &port_status);
+    *status_ptr = (u32)le16_to_cpu(port_status.wPortStatus);
+	
+	return result;
+}
+
+int usb_get_hub_status(struct usb_device* udev_ptr, u32 *data)
+{
+	int result;
+	struct usb_hub_status hubdata;
+	
+	result = get_hub_status( udev_ptr, &hubdata );
+	*data = (u32)hubdata.wHubStatus || ((u32)hubdata.wHubChange) << 16;
+	return result;
+}
+
+
+#define USB_BASE0								(0x9C000000)
+#define USB_BASE1								(0x9C030000)
+#define USB_PORTSC1								(0xA000)
+#define USB_PORTSC1_OFFSET						(0x0184)
+#define USB_PORTSC1_PTC_BIT						(0x000F0000)
+int usb_set_port_reset(struct usb_device* udev_ptr )
+{
+	int ret;
+	unsigned long		addr;
+	unsigned long		port_num;
+	void __iomem		*iobase;
+	unsigned long		reg_data;
+	struct usb_hub		*hub;
+	u16 portchange, portstatus;
+	
+	port_num = udev_ptr->bus->busnum - 1;
+	addr = (port_num == 0) ? USB_BASE0 : USB_BASE1;
+	
+	iobase = ioremap_nocache(addr + USB_PORTSC1, PAGE_SIZE);
+	if(!iobase){
+		dev_err(&udev_ptr->dev, "port %d : Error ioremap_nocache failed.\n", port_num);
+		return -EFAULT;
+	}
+	
+	/* port status check */
+	hub = usb_hub_to_struct_hub(udev_ptr);
+	ret = hub_port_status(hub, 1, &portstatus, &portchange);	/* index = 1 */
+	if(ret == 0 && 
+		!(portstatus & USB_PORT_STAT_CONNECTION)){	/* not connected  */
+		spin_lock_irq(&device_state_lock);
+		
+		/* PORTSC1 PTC RESET */
+		reg_data = readl(iobase + USB_PORTSC1_OFFSET);
+		dev_dbg(&udev_ptr->dev, "reg_data = 0x%lx\n", reg_data);
+		reg_data |= (USB_PORTSC1_PTC_BIT);
+		writel(reg_data, iobase + USB_PORTSC1_OFFSET);
+		
+		reg_data = readl(iobase + USB_PORTSC1_OFFSET);	/* re-read */
+		dev_dbg(&udev_ptr->dev, "reg_data = 0x%lx\n", reg_data);
+		mdelay(1);	/* 1msec wait */
+		
+		/* PORTSC1 PTC CLEAR */
+		reg_data = readl(iobase + USB_PORTSC1_OFFSET);
+		dev_dbg(&udev_ptr->dev, "reg_data = 0x%lx\n", reg_data);
+		reg_data &= ~(USB_PORTSC1_PTC_BIT);
+		writel(reg_data, iobase + USB_PORTSC1_OFFSET);
+		
+		reg_data = readl(iobase + USB_PORTSC1_OFFSET);	/* re-read */
+		dev_dbg(&udev_ptr->dev, "reg_data = 0x%lx\n", reg_data);
+		mdelay(1);	/* 1msec wait */
+		
+		spin_unlock_irq(&device_state_lock);
+	}
+	
+	iounmap(iobase);
+	return 0;
+}
+#endif
+
 /*
  * Choose a device number.
  *
@@ -2705,6 +2872,9 @@
 			dev_err(hub->intfdev,
 					"cannot %sreset port %d (err = %d)\n",
 					warm ? "warm " : "", port1, status);
+#ifdef CONFIG_USB_PANASONIC_HOST
+			usb_error_uevent_notifier(udev, port1, USB_PORT_RESET_ERROR);
+#endif
 		} else {
 			status = hub_port_wait_reset(hub, port1, udev, delay,
 								warm);
@@ -4441,6 +4611,75 @@
 	return remaining;
 }
 
+#ifdef CONFIG_USB_PANASONIC_HOST
+static inline void usb_error_uevent_notifier(struct usb_device *ud, int port1, int error_type){
+	char * envp[] = {NULL, NULL};
+	struct usb_device *udev;
+
+	switch (error_type){
+	case USB_ENUMERATE_ERROR:
+		/* reallocate usb_device using portnum */
+		udev = usb_alloc_dev(ud, ud->bus, port1);
+		if(udev){
+			envp[0] = "ERROR_EVENT=ENUMERATE_ERROR";
+			kobject_uevent_env(&(udev->dev.kobj), KOBJ_CHANGE, envp);
+			usb_ep0_reinit(udev);
+			release_devnum(udev);
+			hub_free_dev(udev);
+			usb_put_dev(udev);
+		}
+		break;
+
+	case USB_OVERCURRENT_ERROR:
+		envp[0] = "ERROR_EVENT=OVERCURRENT_ERROR";
+		kobject_uevent_env(&(ud->dev.kobj), KOBJ_CHANGE, envp);
+		break;
+
+	case USB_PORT_RESET_ERROR:
+		envp[0] = "ERROR_EVENT=PORT_RESET_ERROR";
+		kobject_uevent_env(&(ud->dev.kobj), KOBJ_CHANGE, envp);
+		break;
+
+	default:
+		break;
+	}
+}
+#endif
+
+#ifdef CONFIG_USB_PANASONIC_CABLE_STATUS
+#define USB_CONNECT_STATUS	1
+#define USB_DISCONNECT_STATUS	2
+static inline void usb_connect_status_uevent_notifier(struct usb_device *ud, int port1, int status_type){
+	char * envp[] = {NULL, NULL};
+	struct usb_device *udev;
+
+	/* reallocate usb_device using portnum */
+	udev = usb_alloc_dev(ud, ud->bus, port1);
+
+	if(udev){
+		switch (status_type){
+		case USB_CONNECT_STATUS:
+			envp[0] = "STATUS_EVENT=CONNECT_STATUS";
+			kobject_uevent_env(&(udev->dev.kobj),KOBJ_CHANGE,envp);
+			break;
+
+		case USB_DISCONNECT_STATUS:
+			envp[0] = "STATUS_EVENT=DISCONNECT_STATUS";
+			kobject_uevent_env(&(udev->dev.kobj),KOBJ_CHANGE,envp);
+			break;
+
+		default:
+			break;
+		}
+
+		usb_ep0_reinit(udev);
+		release_devnum(udev);
+		hub_free_dev(udev);
+		usb_put_dev(udev);
+	}
+}
+#endif
+
 /* Handle physical or logical connection change events.
  * This routine is called when:
  * 	a port connection-change occurs;
@@ -4455,8 +4694,10 @@
 	struct usb_device *hdev = hub->hdev;
 	struct device *hub_dev = hub->intfdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev->bus);
+#if !defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/8 _*/
 	unsigned wHubCharacteristics =
 			le16_to_cpu(hub->descriptor->wHubCharacteristics);
+#endif
 	struct usb_device *udev;
 	int status, i;
 	unsigned unit_load;
@@ -4465,6 +4706,14 @@
 		"port %d, status %04x, change %04x, %s\n",
 		port1, portstatus, portchange, portspeed(hub, portstatus));
 
+#ifdef CONFIG_USB_PANASONIC_CABLE_STATUS
+	if (portstatus & USB_PORT_STAT_CONNECTION) {
+		usb_connect_status_uevent_notifier(hdev, port1, USB_CONNECT_STATUS);
+	} else {
+		usb_connect_status_uevent_notifier(hdev, port1, USB_DISCONNECT_STATUS);
+	}
+#endif
+
 	if (hub->has_indicators) {
 		set_port_led(hub, port1, HUB_LED_AUTO);
 		hub->indicator[port1-1] = INDICATOR_AUTO;
@@ -4510,6 +4759,13 @@
 		if (hcd->phy && !hdev->parent &&
 				!(portstatus & USB_PORT_STAT_CONNECTION))
 			usb_phy_notify_disconnect(hcd->phy, udev->speed);
+#ifdef CONFIG_USB_PANASONIC_CABLE_STATUS
+		if (portstatus & USB_PORT_STAT_CONNECTION) {
+			/* USB_PORT_STAT_CONNECTIONãŒç«‹ã£ã¦ã„ã¦ã‚‚ã€æŽ¥ç¶šæ¸ˆã¿ãƒ‡ãƒã‚¤ã‚¹ãŒå­˜åœ¨ã™ã‚‹å ´åˆã¯	*/
+			/* åˆ‡æ–­ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§DISCONNECT_STATUSã‚’é€šçŸ¥ã™ã‚‹						*/
+			usb_connect_status_uevent_notifier(hdev, port1, USB_DISCONNECT_STATUS);
+		}
+#endif
 		usb_disconnect(&hub->ports[port1 - 1]->child);
 	}
 	clear_bit(port1, hub->change_bits);
@@ -4532,7 +4788,34 @@
 		} else {
 			portstatus = status;
 		}
+#ifdef CONFIG_USB_PANASONIC_CABLE_STATUS
+		if (portstatus & USB_PORT_STAT_CONNECTION) {
+			usb_connect_status_uevent_notifier(hdev, port1, USB_CONNECT_STATUS);
+		} else {
+			usb_connect_status_uevent_notifier(hdev, port1, USB_DISCONNECT_STATUS);
+		}
+#endif
 	}
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/8 _*/
+	
+	/*_ å…ƒã®Linuxã§ã¯ã‚«ãƒ¼ãƒãƒ«ãŒã€é›»æºã‚’å…¥ã‚Œç›´ã—ã¦ã—ã¾ã†ã€‚
+        éŽé›»æµæ¤œå‡ºæœ‰åŠ¹æ™‚ã¯ã€ãƒ¦ãƒ¼ã‚¶ã‚¢ãƒ—ãƒªãŒsysfsã®port_ctrlã‚’ä½¿ç”¨ã—ã¦é›»æºã‚’å†æŠ•å…¥ã™ã‚‹ã®ã§ã€
+        ã‚«ãƒ¼ãƒãƒ«ã§ã®è‡ªå‹•å¾©å¸°ã‚’æ­¢ã‚ã‚‹ã€‚  _*/
+	
+	/*_ éŽé›»æµãƒã‚§ãƒƒã‚¯ _*/
+	if ((portchange & USB_PORT_STAT_C_OVERCURRENT) || (portstatus & USB_PORT_STAT_OVERCURRENT)) 
+		goto done;
+
+/*_ Commit:253e05724f9230910344357b1142ad8642ff9f5a			USB: add a "remove hardware" sysfs attribute				2009/10/28 04:20 _*/
+	/*_ ãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­æ™‚ã«PORT_RESETå‡¦ç†ã‚’å®Ÿè¡Œã—ãªã„ã‚ˆã†å¤‰æ›´ _*/
+	if (!(portstatus & USB_PORT_STAT_CONNECTION) ||
+            test_bit(port1, hub->removed_bits)) {
+		if (portstatus & USB_PORT_STAT_ENABLE)	goto done;
+
+		return;
+	}
+#else
+
 
 	/* Return now if debouncing failed or nothing is connected or
 	 * the device was "removed".
@@ -4549,6 +4832,8 @@
 			goto done;
 		return;
 	}
+#endif
+
 	if (hub_is_superspeed(hub->hdev))
 		unit_load = 150;
 	else
@@ -4679,9 +4964,13 @@
 	if (hub->hdev->parent ||
 			!hcd->driver->port_handed_over ||
 			!(hcd->driver->port_handed_over)(hcd, port1)) {
-		if (status != -ENOTCONN && status != -ENODEV)
+		if (status != -ENOTCONN && status != -ENODEV){
 			dev_err(hub_dev, "unable to enumerate USB device on port %d\n",
 					port1);
+#ifdef CONFIG_USB_PANASONIC_HOST
+			usb_error_uevent_notifier(hdev, port1, USB_ENUMERATE_ERROR);
+#endif
+		}
 	}
 
 done:
@@ -4867,19 +5156,41 @@
 				connect_change = 1;
 
 			if (portchange & USB_PORT_STAT_C_OVERCURRENT) {
+#ifndef CONFIG_USB_PANASONIC_OC_DETECT	/*_ GerdaC 2015/1/8 _*/
 				u16 status = 0;
 				u16 unused;
+#endif
 
 				dev_dbg(hub_dev, "over-current change on port "
 					"%d\n", i);
 				usb_clear_port_feature(hdev, i,
 					USB_PORT_FEAT_C_OVER_CURRENT);
 				msleep(100);	/* Cool down */
+#ifdef CONFIG_USB_PANASONIC_OC_DETECT	/*_ GerdaC 2015/1/8 _*/
+				/*_ éŽé›»æµç™ºç”Ÿæ™‚ã€å…ƒã®Linuxã§ã¯ã€ã‚«ãƒ¼ãƒãƒ«å†…ã§è‡ªå‹•çš„ã«é›»æºã‚’å…¥ã‚ŒãªãŠã™ãŒã€ _*/
+				/*_ ãƒ¦ãƒ¼ã‚¶ã‚¢ãƒ—ãƒªã¨å¯¾è©±ã—ãªãŒã‚‰å¾©å¸°ã—ãŸã„ã®ã§ã€è‡ªå‹•å¾©å¸°ã¯è¡Œã‚ãªã„ã‚ˆã†ã«ã™ã‚‹ã€‚ _*/
+				if( !hdev->parent ){
+					/*_ ãƒ«ãƒ¼ãƒˆHUBãªã‚‰å…¨ãƒãƒ¼ãƒˆ VbusOFF _*/
+					/*_ printk( "%s:%d: hub_power_off\n", __FUNCTION__, __LINE__ ); _*/
+					hub_power_off( hub );
+				}else{
+					/*_ HUBãªã‚‰ã€è©²å½“ãƒãƒ¼ãƒˆã®VbusOFF _*/
+					/*_ printk( "%s:%d: clear_power_feature(%d)\n", __FUNCTION__, __LINE__, i ); _*/
+					usb_clear_port_feature( hdev, i, USB_PORT_FEAT_POWER );
+				}
+				usb_notify_oc( hdev, i, (u32)portstatus | ((u32)portchange << 16) );
+#ifdef CONFIG_USB_PANASONIC_HOST
+				usb_error_uevent_notifier(hdev, i, USB_OVERCURRENT_ERROR);
+#endif
+				/*_ æŽ¥ç¶š/åˆ‡æ–­ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚»ãƒƒãƒˆ _*/
+				connect_change = 1;
+#else
 				hub_power_on(hub, true);
 				hub_port_status(hub, i, &status, &unused);
 				if (status & USB_PORT_STAT_OVERCURRENT)
 					dev_err(hub_dev, "over-current "
 						"condition on port %d\n", i);
+#endif
 			}
 
 			if (portchange & USB_PORT_STAT_C_RESET) {
@@ -5035,6 +5346,15 @@
 
 int usb_hub_init(void)
 {
+/*_ GerdaC 2015/1/5 _*/
+/*_ @LINUXHOST:V0210tx[12/02/29] HIDãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­æ™‚ã«ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ä¸å…·åˆå¯¾å¿œ _*/
+/*_                             (dnote LinuxHost(2.6.32) bug No.19)            _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+	hub_tt_wp = create_workqueue("usbhub_tt");
+	if(!hub_tt_wp)
+		return -1;
+#endif
+
 	if (usb_register(&hub_driver) < 0) {
 		printk(KERN_ERR "%s: can't register hub driver\n",
 			usbcore_name);
@@ -5064,6 +5384,12 @@
 	 * individual hub resources. -greg
 	 */
 	usb_deregister(&hub_driver);
+/*_ GerdaC 2015/1/5 _*/
+/*_ @LINUXHOST:V0210tx[12/02/29] HIDãƒ‡ãƒã‚¤ã‚¹åˆ‡æ–­æ™‚ã«ãƒ‡ãƒƒãƒ‰ãƒ­ãƒƒã‚¯ã™ã‚‹ä¸å…·åˆå¯¾å¿œ _*/
+/*_                             (dnote LinuxHost(2.6.32) bug No.19)            _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+	destroy_workqueue(hub_tt_wp);
+#endif
 } /* usb_hub_cleanup() */
 
 static int descriptors_changed(struct usb_device *udev,
diff -uNr linux-3.14.19/drivers/usb/core/sysfs.c linux-gerda/drivers/usb/core/sysfs.c
--- linux-3.14.19/drivers/usb/core/sysfs.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/sysfs.c	2017-06-22 09:52:55.035039184 +0900
@@ -4,6 +4,7 @@
  * (C) Copyright 2002 David Brownell
  * (C) Copyright 2002,2004 Greg Kroah-Hartman
  * (C) Copyright 2002,2004 IBM Corp.
+ * (C) Copyright 2015 Panasonic Corporation
  *
  * All of the sysfs file attributes for usb devices and interfaces.
  *
@@ -754,6 +755,12 @@
 const struct attribute_group *usb_device_groups[] = {
 	&dev_attr_grp,
 	&dev_string_attr_grp,
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/5 _*/
+	&dev_oc_ind_attr_grp,			/*_ oc_indã‚’ç™»éŒ² _*/
+#endif
+#if defined(CONFIG_USB_PANASONIC_PORT_CONTROL) /*_ GerdaC 2015/1/5 _*/
+	&dev_port_attr_grp,				/*_ port_ctrl,port_statusã‚’ç™»éŒ² _*/
+#endif
 	NULL
 };
 
diff -uNr linux-3.14.19/drivers/usb/core/sysfs_oc_ind.c linux-gerda/drivers/usb/core/sysfs_oc_ind.c
--- linux-3.14.19/drivers/usb/core/sysfs_oc_ind.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/core/sysfs_oc_ind.c	2017-06-22 09:52:55.039039184 +0900
@@ -0,0 +1,146 @@
+/*
+ * Copyright (C) 2010, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/usb.h>
+#include <linux/usb/quirks.h>
+#include "usb.h"
+
+#define assert(s) do{if (!(s)) panic(#s);} while(0);
+
+/*_ ãƒ‡ãƒã‚¤ã‚¹ã®ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã«é–¢ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’åˆæœŸåŒ–ã™ã‚‹ _*/
+void usb_initialize_oc( struct usb_device *udev )
+{
+	spin_lock_init( &udev->oc_ind_lock );
+}
+
+/*_ ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã«é–¢ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’é–‹æ”¾ã™ã‚‹ _*/
+void usb_finish_oc( struct usb_device *udev )
+{
+	struct st_oc_ind	*oc_ind, *next;
+	unsigned long		flags;
+	
+	spin_lock_irqsave( &udev->oc_ind_lock, flags );
+	{
+		for( oc_ind = udev->oc_ind ; oc_ind ; oc_ind = next ){
+			next = oc_ind->next;
+			kfree( oc_ind );
+		}
+		udev->oc_ind = NULL;
+	}
+	spin_unlock_irqrestore( &udev->oc_ind_lock, flags );
+}
+
+/*_ æ–°ã—ã„oc_indã‚’ä½œæˆã™ã‚‹ã€‚æ—¢ã«ãƒªã‚¹ãƒˆã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€NULLã‚’è¿”ã™ _*/
+static struct st_oc_ind* create_new_oc_ind( struct usb_device* udev, int port, const char* msg )
+{
+	struct st_oc_ind	*oc_ind;
+	
+	oc_ind = udev->oc_ind;
+	
+	/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ¡ãƒ¢ãƒªç¢ºä¿ç”¨ãƒ•ãƒ©ã‚°å¤‰æ›´ _*/
+	/*_  sleepç¦æ­¢ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‹ã‚‰å‘¼ã³å‡ºã•ã‚Œã‚‹ãŸã‚ _*/
+
+	if( oc_ind == NULL )
+		return udev->oc_ind = kzalloc( sizeof(struct st_oc_ind), GFP_ATOMIC );	/*_ ãƒªã‚¹ãƒˆã¯ç©ºã€‚å…ˆé ­ã«oc_indã‚’ä½œã‚‹ _*/
+	
+	/*_ ãƒªã‚¹ãƒˆã‚’è¾¿ã‚Šæœ€å¾Œã®ãƒŽãƒ¼ãƒ‰ã‚’æŽ¢ã™ã€‚ç™»éŒ²æ¸ˆã¿ã§ã‚ã‚‹äº‹ãŒåˆ¤æ˜Žã™ã‚Œã°å‡¦ç†ã‚’æ­¢ã‚ã‚‹ _*/
+	for( ; ; oc_ind = oc_ind->next ){
+		if( oc_ind->port == port && strcmp(oc_ind->msg,msg) == 0 )	/*_ statusã‚‚ãƒã‚§ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã®ã‹è¦æ¤œè¨Ž _*/
+			return NULL;					/*_ æ—¢ã«ç™»éŒ²æ¸ˆã¿ _*/
+		if( oc_ind->next == NULL ) break;	/*_ ä»Šå›žã®oc_indãŒæœ€å¾Œå°¾ _*/
+	}
+	
+	return oc_ind->next = kzalloc( sizeof(struct st_oc_ind), GFP_ATOMIC );	/*_ ãƒªã‚¹ãƒˆã®æœ€å¾Œå°¾ã«oc_indã‚’ä½œã‚‹ _*/
+}
+
+/*_ ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã®ç™ºç”Ÿã‚’é€šçŸ¥ã™ã‚‹ _*/
+void usb_notify_oc( struct usb_device *udev, int port, u32 status )
+{
+	struct st_oc_ind	*oc_ind;
+	unsigned long		flags;
+	const char			*msg;
+	
+	if( !udev ) return;
+	
+	msg = udev->dev.kobj.name;
+	assert( msg != NULL );
+	while( udev->parent != NULL ) udev = udev->parent;	/*_ ãƒ«ãƒ¼ãƒˆãƒãƒ–ã®udevã‚’æŽ¢ã™ _*/
+	
+/*_ 	printk( "notify_oc %s : %d\n", msg, port ); _*/
+	
+	spin_lock_irqsave( &udev->oc_ind_lock, flags );
+	{
+		oc_ind = create_new_oc_ind( udev, port, msg );
+		if( oc_ind ){
+			oc_ind->port = port;
+			oc_ind->status = status;
+			assert( strlen(msg) < sizeof(oc_ind->msg) );
+			sprintf( oc_ind->msg, "%s", msg );
+		}
+	}
+	spin_unlock_irqrestore( &udev->oc_ind_lock, flags );
+}
+
+/*_ sysfsã®oc_indã‚’èª­ã¿è¾¼ã‚“ã éš›ã«æ–‡å­—åˆ—ã‚’çµ„ã¿ç«‹ã¦ã‚‹é–¢æ•°ã€‚ _*/
+/*_ ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã®ç™ºç”Ÿã‚’ãƒ¦ãƒ¼ã‚¶ã«é€šçŸ¥ã™ã‚‹ã€‚èª­ã‚€ã¨ã€èª­ã‚“ã ãƒ‡ãƒ¼ã‚¿ã¯ãƒªã‚¹ãƒˆã‹ã‚‰æ¶ˆãˆã‚‹ã®ã§æ³¨æ„ã€‚ _*/
+static ssize_t show_oc_ind(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device	*udev;
+	struct st_oc_ind	*oc_ind;
+	unsigned long		flags;
+	ssize_t				sz;
+	
+	udev = to_usb_device(dev);
+	
+	if( likely(!udev->oc_ind) ) return 0;	/*_ æŽ’ä»–åˆ¶å¾¡ã‚’ã™ã‚‹å‰ã«äº‹å‰ãƒã‚§ãƒƒã‚¯ã€‚ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã¯ç™ºç”Ÿã—ã¦ã„ãªã„äº‹ã®æ–¹ãŒå¤šã„ã€‚ _*/
+	
+	spin_lock_irqsave( &udev->oc_ind_lock, flags );
+	{
+		oc_ind = udev->oc_ind;				/*_ å…ˆé ­ã®oc_indã‚’æŠœãå–ã‚‹ _*/
+		if( likely(oc_ind) )
+			udev->oc_ind = oc_ind->next;	/*_ ï¼’ç•ªç›®ã®oc_indã‚’å…ˆé ­ã«æŒã£ã¦ãã‚‹ _*/
+	}
+	spin_unlock_irqrestore( &udev->oc_ind_lock, flags );
+	
+	if( unlikely(!oc_ind) ) return 0;
+	
+	sz = sprintf( buf, "%s %d %08x\n", oc_ind->msg, oc_ind->port, oc_ind->status );
+	kfree( oc_ind );
+	
+	return sz;
+}
+static DEVICE_ATTR(oc_ind, S_IRUGO, show_oc_ind, NULL);
+
+static struct attribute *dev_oc_ind_attrs[] = {
+	&dev_attr_oc_ind.attr,
+	NULL
+};
+
+/*_ é …ç›®ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹ _*/
+static mode_t dev_oc_ind_attrs_are_visible(struct kobject *kobj, struct attribute *a, int n)
+{
+	struct device *dev = container_of(kobj, struct device, kobj);
+	struct usb_device *udev = to_usb_device(dev);
+	
+	if( a == &dev_attr_oc_ind.attr ){
+		if( udev->parent != NULL )
+			return 0;		/*_ è¦ªãŒå±…ã‚‹ == ãƒ«ãƒ¼ãƒˆãƒãƒ–ä»¥å¤–ã®ãƒ‡ãƒã‚¤ã‚¹ãªã‚‰ã€é …ç›®ã‚’è¡¨ç¤ºã—ãªã„ã€‚ _*/
+	}
+	return a->mode;
+}
+
+/*_ sysfsã«oc_indã‚’ç™»éŒ²ã™ã‚‹ç‚ºã®ã‚¨ãƒ³ãƒˆãƒª _*/
+const struct attribute_group dev_oc_ind_attr_grp = {
+	.attrs =		dev_oc_ind_attrs,
+	.is_visible =	dev_oc_ind_attrs_are_visible,
+};
+
+#endif
diff -uNr linux-3.14.19/drivers/usb/core/sysfs_port.c linux-gerda/drivers/usb/core/sysfs_port.c
--- linux-3.14.19/drivers/usb/core/sysfs_port.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/core/sysfs_port.c	2017-06-22 09:52:55.039039184 +0900
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2010, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+#if defined(CONFIG_USB_PANASONIC_PORT_CONTROL)
+
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/usb.h>
+#include <linux/usb/quirks.h>
+#include "usb.h"
+
+/*_
+  sysfsã®port_statusã‚’èª­ã¿è¾¼ã‚“ã éš›ã«æ–‡å­—åˆ—ã‚’çµ„ã¿ç«‹ã¦ã‚‹é–¢æ•°ã€‚
+  å…ˆé ­ã«ãƒãƒ–æƒ…å ±ã‚’1è¡Œã€ç¶šã„ã¦ãƒãƒ¼ãƒˆæƒ…å ±ã‚’ãƒãƒ¼ãƒˆã®æ•°ã ã‘æ ¼ç´ã™ã‚‹ã€‚
+  suspendä¸­ã ã¨ã€æƒ…å ±ã®å–å¾—ã«å¤±æ•—ã™ã‚‹ã€‚ã‚µã‚¹ãƒšãƒ³ãƒ‰ä¸­å¯¾å¿œã¯å¿…è¦ï¼Ÿ
+_*/
+static ssize_t show_port_status(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct usb_device	*udev;
+	ssize_t				sz;
+	int					i, ret, portNum;
+	u32					status;
+	
+	sz = 0;
+	udev = to_usb_device(dev);
+	
+	/*_ ãƒãƒ–ã®æƒ…å ±å–å¾— _*/
+	ret = usb_get_hub_status( udev, &status );
+/*_ 	printk( "%s:%d ret=%d\n", __FUNCTION__, __LINE__, ret ); _*/
+	if( ret < 0 )
+		return -EINVAL;
+	ret = sprintf( &buf[sz], "%u %08X\n", 0, status );
+	if( ret < 0 )
+		return -EINVAL;
+	sz += ret;
+	
+	/*_ ãƒãƒ¼ãƒˆã®æƒ…å ±å–å¾— _*/
+	portNum = udev->maxchild;
+	for( i=1 ; i <= portNum ; i++ ){
+		if( usb_get_port_status( udev, i, &status ) < 0 )
+			return -EINVAL;
+		
+		ret = sprintf( &buf[sz], "%u %08X\n", i, status );
+		if( ret < 0 )
+			return -EINVAL;
+		sz += ret;
+	}
+	
+	return sz;
+}
+static DEVICE_ATTR(port_status, S_IRUGO, show_port_status, NULL);
+
+/*_ ãƒãƒ–ã®port_statusã‚’å¤‰æ›´ã™ã‚‹ã€‚ _*/
+static ssize_t set_port_ctrl(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct usb_device* udev;
+	u32 flag, status, port;
+	int ret;
+	
+	udev = to_usb_device(dev);
+	
+	ret = sscanf( buf, "%x %x %x \n", &flag, &status, &port );
+	if( (ret != 3) || (port == 0) )
+		return -EINVAL;
+	
+	if( flag ){
+		ret = usb_set_port_status( udev, port, status );
+	}else{
+		ret = usb_clr_port_status( udev, port, status );
+	}
+	if( ret < 0 )
+		return -EINVAL;
+	
+	return count;	/*_ returnã®æ„å‘³ã¯ï¼Ÿè¦èª¿æŸ»ã€‚ _*/
+}
+static DEVICE_ATTR(port_ctrl, S_IWUSR, NULL, set_port_ctrl);
+
+/* USB-PHY Reset */
+static ssize_t set_port_reset( struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	u32 flag;
+	struct usb_device* udev;
+	int ret;
+	
+	ret = sscanf( buf, "%x\n", &flag );
+	if( (ret != 1) || (flag != 1) )
+		return -EINVAL;
+
+	udev = to_usb_device(dev);
+	ret = usb_set_port_reset(udev);
+	if( ret < 0 )
+		return -EINVAL;
+	
+	return count;
+}
+static DEVICE_ATTR(port_reset, S_IWUSR, NULL, set_port_reset);
+
+
+static struct attribute *dev_port_attrs[] = {
+	&dev_attr_port_status.attr,
+	&dev_attr_port_ctrl.attr,
+	&dev_attr_port_reset.attr,
+	NULL
+};
+
+/*_ é …ç›®ã‚’è¡¨ç¤ºã™ã‚‹ã‹ã©ã†ã‹ _*/
+static mode_t dev_port_attrs_are_visible(struct kobject *kobj, struct attribute *a, int n)
+{
+/*_ 	struct device *dev = container_of(kobj, struct device, kobj); _*/
+/*_ 	struct usb_device *udev = to_usb_device(dev); _*/
+	
+	if( a == &dev_attr_port_status.attr || a == &dev_attr_port_ctrl.attr ){
+		/*_ return 0;	ãƒãƒ–ä»¥å¤–ã®å ´åˆã¯è¡¨ç¤ºã—ãªã„ _*/
+	}
+	return a->mode;
+}
+
+/*_ sysfsã«port_ctrl,port_statusã‚’ç™»éŒ²ã™ã‚‹ç‚ºã®ã‚¨ãƒ³ãƒˆãƒª _*/
+const struct attribute_group dev_port_attr_grp = {
+	.attrs =		dev_port_attrs,
+	.is_visible =	dev_port_attrs_are_visible,
+};
+
+#endif
diff -uNr linux-3.14.19/drivers/usb/core/usb-panasonic.c linux-gerda/drivers/usb/core/usb-panasonic.c
--- linux-3.14.19/drivers/usb/core/usb-panasonic.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/core/usb-panasonic.c	2017-06-22 09:52:55.035039184 +0900
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2011, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+
+#include "usb-panasonic.h"
+
+/*_ ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹è¨­å®šãƒ•ãƒ©ã‚° _*/
+static uint usb_ehci_host_ebable=0x0;
+static uint usb_xhci_host_ebable=0x0;
+module_param(usb_ehci_host_ebable, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(usb_ehci_host_ebable, "echi enable info");
+module_param(usb_xhci_host_ebable, uint, S_IRUGO | S_IWUSR);
+MODULE_PARM_DESC(usb_xhci_host_ebable, "xchi enable info");
+
+/*_ ãƒ‰ãƒ©ã‚¤ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³ _*/
+static uint usb_hostdd_version=USBH_DDVERSION;
+module_param(usb_hostdd_version, uint, S_IRUGO);
+MODULE_PARM_DESC(usb_hostdd_version, "usb host driver version");
+
+
+/*_ @ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹ã®å‹•çš„åˆ‡æ›¿ æƒ…å ±å–å¾— _*/
+uint usbh_get_host_enableinfo(int controller_type)
+{
+
+	uint ret_val = 0x0;
+
+	switch(controller_type){
+		
+		case USBH_ENABLEINFO_EHCI:	/*_ echi _*/
+			ret_val = usb_ehci_host_ebable;
+			break;
+
+		case USBH_ENABLEINFO_XHCI:	/*_ xchi _*/
+			ret_val = usb_xhci_host_ebable;
+			break;
+			
+		default:
+			ret_val = 0x0;
+			break;
+	}
+
+	return ret_val;
+}
+
+EXPORT_SYMBOL_GPL(usbh_get_host_enableinfo);
+
diff -uNr linux-3.14.19/drivers/usb/core/usb-panasonic.h linux-gerda/drivers/usb/core/usb-panasonic.h
--- linux-3.14.19/drivers/usb/core/usb-panasonic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/core/usb-panasonic.h	2017-06-22 09:52:55.035039184 +0900
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) 2012, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+
+#ifndef __LINUX_USB_PANASONIC_H
+#define __LINUX_USB_PANASONIC_H
+
+/*_ USBãƒ›ã‚¹ãƒˆ ãƒ‰ãƒ©ã‚¤ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³ _*/
+#define USBH_DDVERSION	0x0333
+
+/*_ ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹è¨­å®šç”¨(æœªå®Ÿè£…) _*/
+#define USBH_ENABLEINFO_EHCI	0x01
+#define USBH_ENABLEINFO_XHCI	0x02
+extern uint usbh_get_host_enableinfo(int controller_type);
+
+#endif /* __LINUX_USB_PANASONIC_H */
+
+
diff -uNr linux-3.14.19/drivers/usb/core/usb.c linux-gerda/drivers/usb/core/usb.c
--- linux-3.14.19/drivers/usb/core/usb.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/usb.c	2017-06-22 09:52:55.043039184 +0900
@@ -11,6 +11,7 @@
  * (C) Copyright Yggdrasil Computing, Inc. 2000
  *     (usb_device_id matching changes by Adam J. Richter)
  * (C) Copyright Greg Kroah-Hartman 2002-2003
+ * (C) Copyright Panasonic Corporation 2015
  *
  * NOTE! This is not actually a driver at all, rather this is
  * just a collection of helper routines that implement the
@@ -271,6 +272,9 @@
 	kfree(udev->product);
 	kfree(udev->manufacturer);
 	kfree(udev->serial);
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)		/*_ GerdaC 2015/1/5 _*/
+	usb_finish_oc(udev);
+#endif
 	kfree(udev);
 }
 
@@ -413,6 +417,10 @@
 	if (!dev)
 		return NULL;
 
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/5 _*/
+	usb_initialize_oc( dev );
+#endif
+
 	if (!usb_get_hcd(usb_hcd)) {
 		kfree(dev);
 		return NULL;
diff -uNr linux-3.14.19/drivers/usb/core/usb.h linux-gerda/drivers/usb/core/usb.h
--- linux-3.14.19/drivers/usb/core/usb.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/core/usb.h	2017-06-22 09:52:55.035039184 +0900
@@ -195,3 +195,83 @@
 static inline int usb_acpi_register(void) { return 0; };
 static inline void usb_acpi_unregister(void) { };
 #endif
+
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)		/*_ GerdaC 2015/1/5 _*/
+void usb_initialize_oc( struct usb_device *udev );						/*_ ãƒ‡ãƒã‚¤ã‚¹ã®ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã«é–¢ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’åˆæœŸåŒ–ã™ã‚‹ _*/
+void usb_finish_oc( struct usb_device *udev );							/*_ ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã«é–¢ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã‚’é–‹æ”¾ã™ã‚‹ _*/
+void usb_notify_oc( struct usb_device *udev, int port, u32 status );	/*_ ã‚ªãƒ¼ãƒãƒ¼ã‚«ãƒ¬ãƒ³ãƒˆã®ç™ºç”Ÿã‚’é€šçŸ¥ã™ã‚‹ _*/
+extern const struct attribute_group dev_oc_ind_attr_grp;				/*_ sysfsã«oc_indã‚’ç™»éŒ²ã™ã‚‹ç‚ºã®ã‚¨ãƒ³ãƒˆãƒª _*/
+#endif
+
+#if defined(CONFIG_USB_PANASONIC_PORT_CONTROL)	/*_ GerdaC 2015/1/5 _*/
+int usb_get_hub_status(struct usb_device* udev_ptr, u32 *data);
+int usb_get_port_status(struct usb_device* udev_ptr, u32 index, u32* status_ptr);
+int usb_set_port_status(struct usb_device* udev_ptr, u32 index, u32 status);
+int usb_clr_port_status(struct usb_device* udev_ptr, u32 index, u32 status);
+int usb_set_port_reset(struct usb_device* udev_ptr);
+extern const struct attribute_group dev_port_attr_grp;					/*_ sysfsã«port_ctrl,port_statusã‚’ç™»éŒ²ã™ã‚‹ç‚ºã®ã‚¨ãƒ³ãƒˆãƒª _*/
+#endif
+
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+#include <linux/dmapool.h>
+#include <linux/dma-mapping.h>
+
+/* Absolute address to Relative address */
+#define USB_DDR_BASE_ADDR (0xA0000000)
+static inline void *usb_dma_pool_alloc(struct dma_pool *pool, gfp_t mem_flags,dma_addr_t *handle)
+{
+	void *retval;
+	retval = dma_pool_alloc(pool, mem_flags, handle);
+	*handle -= USB_DDR_BASE_ADDR;
+
+	return retval;
+}
+
+static inline void usb_dma_pool_free(struct dma_pool *pool, void *vaddr, dma_addr_t addr)
+{
+	dma_pool_free(pool, vaddr, addr + USB_DDR_BASE_ADDR);
+}
+
+static inline dma_addr_t usb_dma_map_single(struct device *dev, void *ptr, size_t size, enum dma_data_direction direction)
+{
+	return ( dma_map_single(dev, ptr, size, direction) - USB_DDR_BASE_ADDR );
+}
+
+static inline void usb_dma_unmap_single(struct device *dev, dma_addr_t dma_addr, size_t size, enum dma_data_direction direction)
+{
+	dma_unmap_single(dev, dma_addr + USB_DDR_BASE_ADDR, size, direction);
+}
+
+
+static void * usb_dma_alloc_coherent(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
+{
+	void *retval;
+	retval = dma_alloc_coherent(dev, size, dma_handle, flag);
+	*dma_handle -= USB_DDR_BASE_ADDR;
+
+	return retval;
+
+}
+
+static inline void usb_dma_free_coherent(struct device *dev, size_t size, void *kvaddr,dma_addr_t dma_handle)
+{
+	dma_free_coherent(dev, size, kvaddr, dma_handle + USB_DDR_BASE_ADDR);
+}
+
+static inline dma_addr_t usb_dma_map_page(struct device *dev, struct page *page, size_t offset, size_t size, enum dma_data_direction dir)
+{
+	return ( dma_map_page(dev, page, offset, size, dir) - USB_DDR_BASE_ADDR );
+}
+
+static inline void usb_dma_unmap_page(struct device *dev, dma_addr_t addr, size_t size, enum dma_data_direction dir)
+{
+	dma_unmap_page(dev, addr + USB_DDR_BASE_ADDR, size, dir);
+}
+
+
+
+
+
+
+
+#endif
diff -uNr linux-3.14.19/drivers/usb/gadget/Kconfig linux-gerda/drivers/usb/gadget/Kconfig
--- linux-3.14.19/drivers/usb/gadget/Kconfig	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/Kconfig	2017-06-22 09:52:55.351039175 +0900
@@ -347,6 +347,19 @@
 	  MARVELL PXA2128 Processor series include a super speed USB3.0 device
 	  controller, which support super speed USB peripheral.
 
+config USB_PANASONIC
+	tristate "PANASONIC USB2.0 Device controller"
+	help
+	  This driver provides USB Device Controller driver for PANASONIC
+
+config USB_PANASONIC_ENABLE_DMA
+	boolean "Enable DMA mode"
+	depends on USB_PANASONIC
+	default y
+	help
+	  Say "y" to enable DMA mode.
+	  If unsure, say "N" here.  The driver works fine in PIO mode.
+
 #
 # Controllers available in both integrated and discrete versions
 #
@@ -549,6 +562,9 @@
 config USB_F_FS
 	tristate
 
+config USB_F_IAP2
+	tristate
+	
 choice
 	tristate "USB Gadget Drivers"
 	default USB_ETH
@@ -721,6 +737,25 @@
 	  implemented in kernel space (for instance Ethernet, serial or
 	  mass storage) and other are implemented in user space.
 
+config USB_CARPLAY
+	tristate "Gadget CarPlay"
+	depends on NET
+	select USB_LIBCOMPOSITE
+	select USB_F_IAP2
+	select USB_U_ETHER
+	select USB_F_NCM
+	help
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "g_carplay".
+	  
+config USB_IAP2
+	tristate "Gadget iAP2"
+	select USB_LIBCOMPOSITE
+	select USB_F_IAP2
+	help
+	  Say "y" to link the driver statically, or "m" to build a
+	  dynamically linked module called "g_iap2".
+	  
 config USB_ZERO
 	tristate "Gadget Zero (DEVELOPMENT)"
 	select USB_LIBCOMPOSITE
diff -uNr linux-3.14.19/drivers/usb/gadget/Makefile linux-gerda/drivers/usb/gadget/Makefile
--- linux-3.14.19/drivers/usb/gadget/Makefile	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/Makefile	2017-06-22 09:52:55.363039174 +0900
@@ -9,6 +9,8 @@
 libcomposite-y			:= usbstring.o config.o epautoconf.o
 libcomposite-y			+= composite.o functions.o configfs.o u_f.o
 obj-$(CONFIG_USB_DUMMY_HCD)	+= dummy_hcd.o
+obj-$(CONFIG_USB_PANASONIC)	+= panasonic_udc.o
+panasonic_udc-y			:= panasonic_udc_main.o panasonic_udc_ep0.o
 obj-$(CONFIG_USB_NET2272)	+= net2272.o
 obj-$(CONFIG_USB_NET2280)	+= net2280.o
 obj-$(CONFIG_USB_AMD5536UDC)	+= amd5536udc.o
@@ -64,6 +66,8 @@
 obj-$(CONFIG_USB_F_MASS_STORAGE)+= usb_f_mass_storage.o
 usb_f_fs-y			:= f_fs.o
 obj-$(CONFIG_USB_F_FS)		+= usb_f_fs.o
+usb_f_iap2-y			:= f_iap2.o
+obj-$(CONFIG_USB_F_IAP2)	+= usb_f_iap2.o
 
 #
 # USB gadget drivers
@@ -85,6 +89,8 @@
 g_ncm-y				:= ncm.o
 g_acm_ms-y			:= acm_ms.o
 g_tcm_usb_gadget-y		:= tcm_usb_gadget.o
+g_carplay-y			:= carplay.o
+g_iap2-y			:= iap2.o
 
 obj-$(CONFIG_USB_ZERO)		+= g_zero.o
 obj-$(CONFIG_USB_AUDIO)		+= g_audio.o
@@ -104,3 +110,5 @@
 obj-$(CONFIG_USB_G_NCM)		+= g_ncm.o
 obj-$(CONFIG_USB_G_ACM_MS)	+= g_acm_ms.o
 obj-$(CONFIG_USB_GADGET_TARGET)	+= tcm_usb_gadget.o
+obj-$(CONFIG_USB_CARPLAY)	+= g_carplay.o
+obj-$(CONFIG_USB_IAP2)		+= g_iap2.o
diff -uNr linux-3.14.19/drivers/usb/gadget/carplay.c linux-gerda/drivers/usb/gadget/carplay.c
--- linux-3.14.19/drivers/usb/gadget/carplay.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/carplay.c	2017-06-22 09:52:55.351039175 +0900
@@ -0,0 +1,234 @@
+/*
+ * carplay.c -- CARPLAY gadget driver
+ *
+ * Copyright (C) 2015 Panasonic
+ *
+ *  Vendor + NCM
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/usb/composite.h>
+
+#include "u_ether.h"
+#include "u_ncm.h"
+
+#define DRIVER_DESC		"CarPlay Gadget"/*TODO:ç¢ºè¡¦*/
+
+/*-------------------------------------------------------------------------*/
+
+#define DRIVER_VENDOR_NUM		0x0525	/*  *//*TODO:ç¢ºè¡¦*/
+#define DRIVER_PRODUCT_NUM		0xa4a1	/*  *//*TODO:ç¢ºè¡¦*/
+
+/*-------------------------------------------------------------------------*/
+USB_GADGET_COMPOSITE_OPTIONS();
+
+USB_ETHERNET_MODULE_PARAMETERS();
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		sizeof device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		cpu_to_le16 (0x0200),
+
+	.bDeviceClass =		0,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id defaults change according to what configs
+	 * we support.  (As does bNumConfigurations.)  These values can
+	 * also be overridden by module parameters.
+	 */
+	.idVendor =		cpu_to_le16 (DRIVER_VENDOR_NUM),
+	.idProduct =		cpu_to_le16 (DRIVER_PRODUCT_NUM),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+/* string IDs are assigned dynamically */
+static struct usb_string strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "Panasonic Corporation",/*TODO:ç¢ºè¡¦*/
+	[USB_GADGET_PRODUCT_IDX].s = "DVD Reciever",/*TODO:ç¢ºè¡¦*/
+	[USB_GADGET_SERIAL_IDX].s = "10",/*TODO:ç¢ºè¡¦*/
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_function_instance *f_ncm_inst;
+static struct usb_function *f_ncm;
+static struct usb_function_instance *f_iap2_inst;
+static struct usb_function *f_iap2;
+
+/*-------------------------------------------------------------------------*/
+
+static int __init carplay_do_config(struct usb_configuration *c)
+{
+	int status;
+
+	/* FIXME alloc iConfiguration string, set it in c->strings */
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	f_iap2 = usb_get_function(f_iap2_inst);
+	if (IS_ERR(f_iap2)) {
+		status = PTR_ERR(f_iap2);
+		return status;
+	}
+
+	status = usb_add_function(c, f_iap2);
+	if (status < 0)
+		goto err_func_iap2;
+
+	f_ncm = usb_get_function(f_ncm_inst);
+	if (IS_ERR(f_ncm)) {
+		status = PTR_ERR(f_ncm);
+		return status;
+	}
+
+	status = usb_add_function(c, f_ncm);
+	if (status < 0)
+		goto err_func_ncm;
+
+	return 0;
+err_func_ncm:
+	usb_put_function(f_ncm);
+err_func_iap2:
+	usb_put_function(f_iap2);
+	return status;
+}
+
+static struct usb_configuration carplay_config_driver = {
+	/* .label = f(hardware) */
+	.label			= "iAP2",/*TODO:ç¢ºè¡¦*/
+	.bConfigurationValue	= 1,
+	/* .iConfiguration = DYNAMIC */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init carplay_bind(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget	*gadget = cdev->gadget;
+	struct f_ncm_opts	*ncm_opts;
+	int			status;
+
+	f_iap2_inst = usb_get_function_instance("iap2");
+	if (IS_ERR(f_iap2_inst))
+		return PTR_ERR(f_iap2_inst);
+	
+	f_ncm_inst = usb_get_function_instance("ncm");
+	if (IS_ERR(f_ncm_inst)){
+		status = PTR_ERR(f_ncm_inst);
+		goto fail;
+	}
+	
+	ncm_opts = container_of(f_ncm_inst, struct f_ncm_opts, func_inst);
+
+	gether_set_qmult(ncm_opts->net, qmult);
+	if (!gether_set_host_addr(ncm_opts->net, host_addr))
+		pr_info("using host ethernet address: %s", host_addr);
+	if (!gether_set_dev_addr(ncm_opts->net, dev_addr))
+		pr_info("using self ethernet address: %s", dev_addr);
+
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+
+	status = usb_string_ids_tab(cdev, strings_dev);
+	if (status < 0)
+		goto fail0;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+	device_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;
+	
+	status = usb_add_config(cdev, &carplay_config_driver,
+				carplay_do_config);
+	if (status < 0)
+		goto fail0;
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	dev_info(&gadget->dev, "%s\n", DRIVER_DESC);
+
+	return 0;
+
+fail0:
+	usb_put_function_instance(f_ncm_inst);
+fail:
+	usb_put_function_instance(f_iap2_inst);
+	return status;
+}
+
+static int __exit carplay_unbind(struct usb_composite_dev *cdev)
+{
+	if (!IS_ERR_OR_NULL(f_iap2))
+		usb_put_function(f_iap2);
+	if (!IS_ERR_OR_NULL(f_iap2_inst))
+		usb_put_function_instance(f_iap2_inst);
+	
+	if (!IS_ERR_OR_NULL(f_ncm))
+		usb_put_function(f_ncm);
+	if (!IS_ERR_OR_NULL(f_ncm_inst))
+		usb_put_function_instance(f_ncm_inst);
+	
+	return 0;
+}
+
+static __refdata struct usb_composite_driver carplay_driver = {
+	.name		= "g_carplay",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.max_speed	= USB_SPEED_HIGH,
+	.bind		= carplay_bind,
+	.unbind		= __exit_p(carplay_unbind),
+};
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Panasonic.");/*TODO:ç¢ºè¡¦*/
+MODULE_LICENSE("GPL");
+
+static int __init init(void)
+{
+	return usb_composite_probe(&carplay_driver);
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&carplay_driver);
+}
+module_exit(cleanup);
diff -uNr linux-3.14.19/drivers/usb/gadget/composite.c linux-gerda/drivers/usb/gadget/composite.c
--- linux-3.14.19/drivers/usb/gadget/composite.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/composite.c	2017-06-22 09:52:55.347039175 +0900
@@ -634,6 +634,7 @@
 	if (!c)
 		goto done;
 
+	usb_gadget_set_state(gadget, USB_STATE_CONFIGURED);
 	cdev->config = c;
 
 	/* Initialize all interfaces by setting them to altsetting zero. */
diff -uNr linux-3.14.19/drivers/usb/gadget/f_iap2.c linux-gerda/drivers/usb/gadget/f_iap2.c
--- linux-3.14.19/drivers/usb/gadget/f_iap2.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/f_iap2.c	2017-06-22 09:52:55.363039174 +0900
@@ -0,0 +1,634 @@
+/*
+ * f_iap2.c -- USB iAP2 function driver
+ *
+ * Copyright (C) 2015 Panasonic
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/poll.h>
+#include <linux/cdev.h>
+
+#include <linux/uaccess.h>
+
+#include "u_iap2.h"
+
+#define IAP2_MAX_REQUEST_SIZE	512
+
+struct f_iap2_req_list {
+	struct usb_request		*req;
+	unsigned int			 pos;
+	struct list_head		list;
+};
+
+struct f_iap2 {
+	struct usb_ep			*in_ep;
+	struct usb_ep			*out_ep;
+	struct usb_request		*iap2_inreq;
+	struct usb_request		*iap2_outreq;
+
+	wait_queue_head_t		read_queue;
+	wait_queue_head_t		write_queue;
+	bool				completed_in_req;
+	struct list_head		completed_out_req;
+	
+	u8						iap2_id;
+
+	spinlock_t				spinlock;
+	
+	struct mutex			lock;
+	
+	struct usb_function		func;
+	struct cdev				cdev;
+	
+	u8						cdev_open;
+};
+
+static inline struct f_iap2 *func_to_iap2(struct usb_function *f)
+{
+	return container_of(f, struct f_iap2, func);
+}
+
+static dev_t 		g_iap2_devno;
+
+static struct usb_interface_assoc_descriptor iap2_iad_desc = {
+	.bLength =		sizeof iap2_iad_desc,
+	.bDescriptorType =	USB_DT_INTERFACE_ASSOCIATION,
+
+	/* .bFirstInterface =	DYNAMIC, */
+	.bInterfaceCount =	1,
+	.bFunctionClass =	0xFF,/*TODO*/
+	.bFunctionSubClass =	0xF0,/*TODO*/
+	.bFunctionProtocol =	0x00,
+	.iFunction =	0x00,
+};
+
+/* interface descriptor: */
+static struct usb_interface_descriptor iap2_intf = {
+	.bLength =		sizeof iap2_intf,
+	.bDescriptorType =	USB_DT_INTERFACE,
+
+	/* .bInterfaceNumber = DYNAMIC */
+	.bAlternateSetting = 0x00,
+	.bNumEndpoints =	2,
+	.bInterfaceClass =	0xFF,
+	.bInterfaceSubClass =	0xF0,
+	.bInterfaceProtocol =	0x00,
+	/* .iInterface = DYNAMIC */
+};
+
+static struct usb_endpoint_descriptor fs_iap2_ep_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_endpoint_descriptor fs_iap2_ep_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+	.bEndpointAddress =	USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+};
+
+static struct usb_descriptor_header *iap2_fs_function[] = {
+	(struct usb_descriptor_header *) &iap2_iad_desc,
+	/* iAP2 descriptors */
+	(struct usb_descriptor_header *) &iap2_intf,
+	(struct usb_descriptor_header *) &fs_iap2_ep_in_desc,
+	(struct usb_descriptor_header *) &fs_iap2_ep_out_desc,
+	NULL,
+};
+
+/* high speed support: */
+static struct usb_endpoint_descriptor hs_iap2_ep_in_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_IN,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(512),
+};
+
+static struct usb_endpoint_descriptor hs_iap2_ep_out_desc = {
+	.bLength =		USB_DT_ENDPOINT_SIZE,
+	.bDescriptorType =	USB_DT_ENDPOINT,
+
+	.bEndpointAddress =	USB_DIR_OUT,
+	.bmAttributes =		USB_ENDPOINT_XFER_BULK,
+	.wMaxPacketSize =	cpu_to_le16(512),
+};
+
+static struct usb_descriptor_header *iap2_hs_function[] = {
+	(struct usb_descriptor_header *) &iap2_iad_desc,
+	/* iAP2 descriptors */
+	(struct usb_descriptor_header *) &iap2_intf,
+	(struct usb_descriptor_header *) &hs_iap2_ep_in_desc,
+	(struct usb_descriptor_header *) &hs_iap2_ep_out_desc,
+	NULL,
+};
+
+/* string descriptors: */
+#define STRING_IAP2_IDX	0
+
+static struct usb_string iap2_string_defs[] = {
+	[STRING_IAP2_IDX].s = "iAP Interface",/*TODO*/
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings iap2_string_table = {
+	.language =		0x0409,	/* en-us */
+	.strings =		iap2_string_defs,
+};
+
+static struct usb_gadget_strings *iap2_strings[] = {
+	&iap2_string_table,
+	NULL,
+};
+
+/*-------------------------------------------------------------------------*/
+/*                              Char Device                                */
+static int
+iap2_open(struct inode *inode, struct file *fd)
+{
+	struct f_iap2		*dev;
+	unsigned long		flags;
+	int					ret = -EBUSY;
+	
+	dev = container_of(inode->i_cdev, struct f_iap2, cdev);
+
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	if (!dev->cdev_open) {
+		dev->cdev_open = 1;
+		fd->private_data = dev;
+		ret = 0;
+	}
+	
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+	
+	return ret;
+}
+
+static int
+iap2_release(struct inode *inode, struct file *fd)
+{
+	struct f_iap2		*dev = fd->private_data;
+	unsigned long		flags;
+	
+	spin_lock_irqsave(&dev->spinlock, flags);
+	dev->cdev_open = 0;
+	fd->private_data = NULL;
+	
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+	
+	return 0;
+}
+
+static void iap2_out_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_iap2 *dev = (struct f_iap2 *) ep->driver_data;
+	struct f_iap2_req_list *req_list;
+	unsigned long flags;
+
+	req_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);
+		if (!req_list)
+			return;
+	
+	req_list->req = req;
+	
+	spin_lock_irqsave(&dev->spinlock, flags);
+	list_add_tail(&req_list->list, &dev->completed_out_req);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+
+	wake_up_interruptible(&dev->read_queue);
+}
+
+static void iap2_in_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	struct f_iap2 *dev = (struct f_iap2 *) ep->driver_data;
+	
+	dev->completed_in_req = 1;
+	wake_up_interruptible(&dev->write_queue);
+}
+
+static ssize_t
+iap2_read(struct file *fd, char __user *buf, size_t len, loff_t *ptr)
+{
+	struct f_iap2		*dev = fd->private_data;
+	struct f_iap2_req_list *list;
+	struct usb_request	*req;
+	unsigned long		flags;
+	
+	mutex_lock(&dev->lock);
+	spin_lock_irqsave(&dev->spinlock, flags);
+
+	while(list_empty(&dev->completed_out_req)) {
+		spin_unlock_irqrestore(&dev->spinlock, flags);
+		mutex_unlock(&dev->lock);
+		if (fd->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+
+		if (wait_event_interruptible(dev->read_queue, !list_empty(&dev->completed_out_req)))
+			return -ERESTARTSYS;
+
+		mutex_lock(&dev->lock);
+		spin_lock_irqsave(&dev->spinlock, flags);
+	}
+		
+	/* pick the first one */
+	list = list_first_entry(&dev->completed_out_req,
+                                struct f_iap2_req_list, list);
+	req = list->req;
+	len = min_t(unsigned int, len, req->actual);
+		
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+		
+	copy_to_user(buf, req->buf, len);
+		
+	spin_lock_irqsave(&dev->spinlock, flags);
+	list_del(&list->list);
+	kfree(list);
+	spin_unlock_irqrestore(&dev->spinlock, flags);
+		
+	/* Next */
+	req->length = IAP2_MAX_REQUEST_SIZE;
+	req->complete = iap2_out_complete;
+	req->context  = dev;	
+
+	if (usb_ep_queue(dev->out_ep, req, GFP_KERNEL)){
+		mutex_unlock(&dev->lock);
+		return -EIO;
+	}
+	
+	mutex_unlock(&dev->lock);
+	
+	return len;
+}
+
+static ssize_t
+iap2_write(struct file *fd, const char __user *buf, size_t len, loff_t *ptr)
+{
+	struct f_iap2		*dev = fd->private_data;
+	struct usb_request	*req = dev->iap2_inreq;
+	
+	mutex_lock(&dev->lock);
+	
+	while (!dev->completed_in_req) {
+			mutex_unlock(&dev->lock);
+			if (fd->f_flags & O_NONBLOCK)
+				return -EAGAIN;
+
+			if (wait_event_interruptible(dev->write_queue, dev->completed_in_req))
+				return -ERESTARTSYS;
+		
+			mutex_lock(&dev->lock);
+	}
+	
+	len = min_t(unsigned int, len, IAP2_MAX_REQUEST_SIZE);
+	copy_from_user(req->buf, buf, len);
+	req->length   = len;
+	req->complete = iap2_in_complete;
+	req->context  = dev;
+
+	dev->completed_in_req = 0;
+	
+	if (usb_ep_queue(dev->in_ep, req, GFP_KERNEL)){
+		dev->completed_in_req = 1;
+		mutex_unlock(&dev->lock);
+		return -EIO;
+	}
+	
+	mutex_unlock(&dev->lock);
+	
+	return len;
+}
+
+static unsigned int
+iap2_poll(struct file *fd, poll_table *wait)
+{
+	struct f_iap2      *dev = fd->private_data;
+	unsigned int    ret = 0;
+
+	poll_wait(fd, &dev->read_queue, wait);
+	poll_wait(fd, &dev->write_queue, wait);
+
+	if(!list_empty(&dev->completed_out_req))
+		ret |= POLLOUT | POLLWRNORM;
+
+	if (dev->completed_in_req)
+		ret |= POLLIN | POLLRDNORM;
+
+	return ret;
+}
+
+static const struct file_operations iap2_io_operations = {
+		.owner =		THIS_MODULE,
+		.open =			iap2_open,
+		.read =			iap2_read,
+		.write =		iap2_write,
+/*		.fsync =		iap2_fsync,*/
+		.poll =			iap2_poll,
+/*		.unlocked_ioctl =		iap2_ioctl,*/
+		.release =		iap2_release,
+/*		.llseek =		iap2_llseek,*/
+};
+
+/*-------------------------------------------------------------------------*/
+/*                                usb_function                             */
+
+static int iap2_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
+{
+	struct f_iap2		*iap2 = func_to_iap2(f);
+	struct usb_composite_dev *cdev = f->config->cdev;
+
+	/* Control interface has only altsetting 0 */
+	if (intf == iap2->iap2_id) {
+		if (alt != 0)
+			goto fail;
+
+		if (iap2->in_ep->driver_data) 
+			usb_ep_disable(iap2->in_ep);
+
+		if (!(iap2->in_ep->desc)) {
+			if (config_ep_by_speed(cdev->gadget, f, iap2->in_ep))
+				goto fail;
+		}
+		usb_ep_enable(iap2->in_ep);
+		iap2->in_ep->driver_data = iap2;
+		
+		if (iap2->out_ep->driver_data) 
+			usb_ep_disable(iap2->out_ep);
+
+		if (!(iap2->out_ep->desc)) {
+			if (config_ep_by_speed(cdev->gadget, f, iap2->out_ep))
+				goto fail;
+		}
+		usb_ep_enable(iap2->out_ep);
+		iap2->out_ep->driver_data = iap2;
+		
+		iap2->completed_in_req = 1;
+		if (iap2->iap2_outreq) {
+			iap2->iap2_outreq->length = IAP2_MAX_REQUEST_SIZE;
+			iap2->iap2_outreq->complete = iap2_out_complete;
+			iap2->iap2_outreq->context  = iap2;
+			usb_ep_queue(iap2->out_ep, iap2->iap2_outreq, GFP_KERNEL);
+		}
+		
+	} else
+		goto fail;
+
+	return 0;
+fail:
+	return -EINVAL;
+}
+
+static void iap2_disable(struct usb_function *f)
+{
+	struct f_iap2		*iap2 = func_to_iap2(f);
+	struct f_iap2_req_list *list, *next;
+	
+	if (iap2->in_ep->driver_data) {
+		usb_ep_disable(iap2->in_ep);
+		iap2->in_ep->driver_data = NULL;
+		iap2->in_ep->desc = NULL;
+	}
+	iap2->completed_in_req = 0;
+	
+	if (iap2->out_ep->driver_data) {
+		usb_ep_disable(iap2->out_ep);
+		iap2->out_ep->driver_data = NULL;
+		iap2->out_ep->desc = NULL;
+	}
+
+	list_for_each_entry_safe(list, next, &iap2->completed_out_req, list) {
+		list_del(&list->list);
+		kfree(list);
+	}
+
+}
+/*-------------------------------------------------------------------------*/
+
+/*-------------------------------------------------------------------------*/
+
+/* function driver setup/binding */
+static int iap2_bind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct usb_composite_dev *cdev = c->cdev;
+	struct f_iap2		*iap2 = func_to_iap2(f);
+	struct usb_string       *us;
+	int			status;
+	struct usb_ep		*ep;
+
+	us = usb_gstrings_attach(cdev, iap2_strings,
+				ARRAY_SIZE(iap2_string_defs));
+	if (IS_ERR(us))
+		return PTR_ERR(us);
+	iap2_intf.iInterface = us[STRING_IAP2_IDX].id;
+
+	/* allocate instance-specific interface IDs */
+	status = usb_interface_id(c, f);
+	if (status < 0)
+		goto fail;
+	iap2->iap2_id = status;
+	iap2_iad_desc.bFirstInterface = status;
+	iap2_intf.bInterfaceNumber = status;
+
+	/* allocate instance-specific endpoints */
+	status = -ENODEV;
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_iap2_ep_in_desc);
+	if (!ep)
+		goto fail;
+	iap2->in_ep = ep;
+	ep->driver_data = cdev;	/* claim */
+
+	ep = usb_ep_autoconfig(cdev->gadget, &fs_iap2_ep_out_desc);
+	if (!ep)
+		goto fail;
+	iap2->out_ep = ep;
+	ep->driver_data = cdev;	/* claim */
+
+	/* allocate notification request and buffer */
+	iap2->iap2_inreq = usb_ep_alloc_request(iap2->in_ep, GFP_KERNEL);
+	if (!iap2->iap2_inreq)
+		goto fail;
+	iap2->iap2_inreq->buf = kmalloc(IAP2_MAX_REQUEST_SIZE, GFP_KERNEL);
+	if (!iap2->iap2_inreq->buf)
+		goto fail;
+	
+	iap2->iap2_outreq = usb_ep_alloc_request(iap2->out_ep, GFP_KERNEL);
+	if (!iap2->iap2_outreq)
+		goto fail;
+	iap2->iap2_outreq->buf = kmalloc(IAP2_MAX_REQUEST_SIZE, GFP_KERNEL);
+	if (!iap2->iap2_outreq->buf)
+		goto fail;
+
+	
+	hs_iap2_ep_in_desc.bEndpointAddress = fs_iap2_ep_in_desc.bEndpointAddress;
+	hs_iap2_ep_out_desc.bEndpointAddress = fs_iap2_ep_out_desc.bEndpointAddress;
+
+	status = usb_assign_descriptors(f, iap2_fs_function, iap2_hs_function,
+			NULL);
+	if (status)
+		goto fail;
+
+	mutex_init(&iap2->lock);
+	spin_lock_init(&iap2->spinlock);
+    init_waitqueue_head(&iap2->write_queue);
+    init_waitqueue_head(&iap2->read_queue);
+	INIT_LIST_HEAD(&iap2->completed_out_req);
+	iap2->completed_in_req = 0;
+	
+	/*
+	 * Register a character device as an interface to a user mode
+	 * program that handles the printer specific functionality.
+	 */
+	status = alloc_chrdev_region(&g_iap2_devno, 0, 1, "USB iap2 gadget");
+	if(status)
+		goto fail;
+	
+	cdev_init(&iap2->cdev, &iap2_io_operations);
+	status = cdev_add(&iap2->cdev, g_iap2_devno, 1);
+	if(status)
+		goto fail;
+	
+	iap2->cdev_open = 0;
+	
+	return 0;
+
+fail:
+	usb_free_all_descriptors(f);
+	
+	if (iap2->iap2_inreq != NULL) {
+		kfree(iap2->iap2_inreq->buf);
+		usb_ep_free_request(iap2->in_ep, iap2->iap2_inreq);
+	}
+	
+	if (iap2->iap2_outreq != NULL) {
+		kfree(iap2->iap2_outreq->buf);
+		usb_ep_free_request(iap2->out_ep, iap2->iap2_outreq);
+	}
+
+	/* we might as well release our claims on endpoints */
+	if (iap2->in_ep)
+		iap2->in_ep->driver_data = NULL;
+	if (iap2->out_ep)
+		iap2->out_ep->driver_data = NULL;
+
+	ERROR(cdev, "%s: can't bind, err %d\n", f->name, status);
+
+	return status;
+}
+
+
+CONFIGFS_ATTR_STRUCT(f_iap2_opts);
+
+static inline struct f_iap2_opts *to_f_iap2_opts(struct config_item *item)
+{
+	return container_of(to_config_group(item), struct f_iap2_opts,
+			    func_inst.group);
+}
+
+static void iap2_attr_release(struct config_item *item)
+{
+	struct f_iap2_opts *opts = to_f_iap2_opts(item);
+
+	usb_put_function_instance(&opts->func_inst);
+}
+
+static struct configfs_item_operations iap2_item_ops = {
+	.release	= iap2_attr_release,
+};
+
+static struct configfs_attribute *iap2_attrs[] = {
+	NULL,
+};
+
+static struct config_item_type iap2_func_type = {
+	.ct_item_ops	= &iap2_item_ops,
+	.ct_attrs	= iap2_attrs,
+	.ct_owner	= THIS_MODULE,
+};
+
+
+static void iap2_free_inst(struct usb_function_instance *f)
+{
+	struct f_iap2_opts *opts;
+
+	opts = container_of(f, struct f_iap2_opts, func_inst);
+
+	kfree(opts);
+}
+
+static struct usb_function_instance *iap2_alloc_inst(void)
+{
+	struct f_iap2_opts *opts;
+
+	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
+	if (!opts)
+		return ERR_PTR(-ENOMEM);
+
+	opts->func_inst.free_func_inst = iap2_free_inst;
+	
+	config_group_init_type_name(&opts->func_inst.group, "", &iap2_func_type);
+
+	return &opts->func_inst;
+}
+
+static void iap2_free(struct usb_function *f)
+{
+	struct f_iap2 *iap2;
+
+	iap2 = func_to_iap2(f);
+	kfree(iap2);
+}
+
+static void iap2_unbind(struct usb_configuration *c, struct usb_function *f)
+{
+	struct f_iap2 *iap2 = func_to_iap2(f);
+
+	DBG(c->cdev, "iap2 unbind\n");
+
+	usb_free_all_descriptors(f);
+
+	/* disable/free request and end point */
+	usb_ep_disable(iap2->in_ep);
+	usb_ep_dequeue(iap2->in_ep, iap2->iap2_inreq);
+	kfree(iap2->iap2_inreq->buf);
+	usb_ep_free_request(iap2->in_ep, iap2->iap2_inreq);
+	
+	usb_ep_disable(iap2->out_ep);
+	usb_ep_dequeue(iap2->out_ep, iap2->iap2_outreq);
+	kfree(iap2->iap2_outreq->buf);
+	usb_ep_free_request(iap2->out_ep, iap2->iap2_outreq);
+	
+	cdev_del( &iap2->cdev );
+	unregister_chrdev_region( g_iap2_devno, 1 );
+}
+
+static struct usb_function *iap2_alloc(struct usb_function_instance *fi)
+{
+	struct f_iap2		*iap2;
+
+	/* allocate and initialize one new instance */
+	iap2 = kzalloc(sizeof(*iap2), GFP_KERNEL);
+	if (!iap2)
+		return ERR_PTR(-ENOMEM);
+
+	
+	iap2->func.name = "iap2";
+	iap2->func.strings = iap2_strings;
+	iap2->func.bind = iap2_bind;
+	iap2->func.unbind = iap2_unbind;
+	iap2->func.set_alt = iap2_set_alt;
+	iap2->func.disable = iap2_disable;
+	iap2->func.free_func = iap2_free;
+
+	return &iap2->func;
+}
+
+DECLARE_USB_FUNCTION_INIT(iap2, iap2_alloc_inst, iap2_alloc);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Panasonic.");/*TODO*/
diff -uNr linux-3.14.19/drivers/usb/gadget/f_ncm.c linux-gerda/drivers/usb/gadget/f_ncm.c
--- linux-3.14.19/drivers/usb/gadget/f_ncm.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/f_ncm.c	2017-06-22 09:52:55.359039175 +0900
@@ -93,7 +93,7 @@
  * because it's used by default by the current linux host driver
  */
 #define NTB_DEFAULT_IN_SIZE	USB_CDC_NCM_NTB_MIN_IN_SIZE
-#define NTB_OUT_SIZE		16384
+#define NTB_OUT_SIZE		4096
 
 /*
  * skbs of size less than that will not be aligned
diff -uNr linux-3.14.19/drivers/usb/gadget/f_uac2.c linux-gerda/drivers/usb/gadget/f_uac2.c
--- linux-3.14.19/drivers/usb/gadget/f_uac2.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/f_uac2.c	2017-06-22 09:52:55.355039175 +0900
@@ -20,13 +20,27 @@
 #include <sound/pcm.h>
 #include <sound/pcm_params.h>
 
+#define PANASONIC_UAC2
+
+#ifdef PANASONIC_UAC2
+#include <linux/etherdevice.h>
+#endif
+
+/* USB ISO IN AUDIO NON or EXIST */
+#define USB_ISO_IN_NON_EXIST
+
 /* Playback(USB-IN) Default Stereo - Fl/Fr */
 static int p_chmask = 0x3;
 module_param(p_chmask, uint, S_IRUGO);
 MODULE_PARM_DESC(p_chmask, "Playback Channel Mask");
 
+#ifdef PANASONIC_UAC2
+/* Playback Default 44.1 KHz */
+static int p_srate = 44100;
+#else
 /* Playback Default 48 KHz */
 static int p_srate = 48000;
+#endif
 module_param(p_srate, uint, S_IRUGO);
 MODULE_PARM_DESC(p_srate, "Playback Sampling Rate");
 
@@ -40,8 +54,13 @@
 module_param(c_chmask, uint, S_IRUGO);
 MODULE_PARM_DESC(c_chmask, "Capture Channel Mask");
 
+#ifdef PANASONIC_UAC2
+/* Capture Default 44.1 KHz */
+static int c_srate = 44100;
+#else
 /* Capture Default 64 KHz */
 static int c_srate = 64000;
+#endif
 module_param(c_srate, uint, S_IRUGO);
 MODULE_PARM_DESC(c_srate, "Capture Sampling Rate");
 
@@ -187,6 +206,7 @@
 {
 	unsigned pending;
 	unsigned long flags;
+	unsigned int hw_ptr;
 	bool update_alsa = false;
 	unsigned char *src, *dst;
 	int status = req->status;
@@ -196,7 +216,7 @@
 	struct snd_uac2_chip *uac2 = prm->uac2;
 
 	/* i/f shutting down */
-	if (!prm->ep_enabled)
+	if (!prm->ep_enabled || req->status == -ESHUTDOWN)
 		return;
 
 	/*
@@ -220,8 +240,8 @@
 		req->actual = req->length;
 		dst = req->buf;
 	} else {
-		dst = prm->dma_area + prm->hw_ptr;
-		src = req->buf;
+		src = NULL;
+		dst = NULL;
 	}
 
 	pending = prm->hw_ptr % prm->period_size;
@@ -229,12 +249,28 @@
 	if (pending >= prm->period_size)
 		update_alsa = true;
 
+	hw_ptr = prm->hw_ptr;
 	prm->hw_ptr = (prm->hw_ptr + req->actual) % prm->dma_bytes;
 
 	spin_unlock_irqrestore(&prm->lock, flags);
 
 	/* Pack USB load in ALSA ring buffer */
-	memcpy(dst, src, req->actual);
+	pending = prm->dma_bytes - hw_ptr;
+
+	/*iso out modify:from Linux kernel 3.18 2015/06/26*/
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		/*iso in not modify 2015/06/26*/
+		memcpy(dst, src, req->actual);
+	} else {
+		if (unlikely(pending < req->actual)) {
+			memcpy(prm->dma_area + hw_ptr, req->buf, pending);
+			memcpy(prm->dma_area, req->buf + pending,
+			       req->actual - pending);
+		} else {
+			memcpy(prm->dma_area + hw_ptr, req->buf, req->actual);
+		}
+	}
+
 exit:
 	if (usb_ep_queue(ep, req, GFP_ATOMIC))
 		dev_err(&uac2->pdev.dev, "%d Error!\n", __LINE__);
@@ -451,6 +487,11 @@
 	return 0;
 }
 
+static void snd_uac2_release(struct device *dev)
+{
+        dev_dbg(dev, "releasing '%s'\n", dev_name(dev));
+}
+
 static int alsa_uac2_init(struct audio_dev *agdev)
 {
 	struct snd_uac2_chip *uac2 = &agdev->uac2;
@@ -462,7 +503,8 @@
 
 	uac2->pdev.id = 0;
 	uac2->pdev.name = uac2_name;
-
+	uac2->pdev.dev.release = snd_uac2_release;
+	
 	/* Register snd_uac2 driver */
 	err = platform_driver_register(&uac2->pdrv);
 	if (err)
@@ -547,8 +589,12 @@
 	.bLength = sizeof iad_desc,
 	.bDescriptorType = USB_DT_INTERFACE_ASSOCIATION,
 
-	.bFirstInterface = 0,
+	/*.bFirstInterface = 0,*/
+#ifndef USB_ISO_IN_NON_EXIST
+	.bInterfaceCount = 2,
+#else
 	.bInterfaceCount = 3,
+#endif /*  USB_ISO_IN_NON_EXIST*/
 	.bFunctionClass = USB_CLASS_AUDIO,
 	.bFunctionSubClass = UAC2_FUNCTION_SUBCLASS_UNDEFINED,
 	.bFunctionProtocol = UAC_VERSION_2,
@@ -574,7 +620,11 @@
 	.bDescriptorSubtype = UAC2_CLOCK_SOURCE,
 	.bClockID = USB_IN_CLK_ID,
 	.bmAttributes = UAC_CLOCK_SOURCE_TYPE_INT_FIXED,
+#ifdef PANASONIC_UAC2
+	.bmControls = ((CONTROL_RDWR << CLK_FREQ_CTRL) | (CONTROL_RDONLY << CLK_VLD_CTRL)),
+#else
 	.bmControls = (CONTROL_RDONLY << CLK_FREQ_CTRL),
+#endif
 	.bAssocTerminal = 0,
 };
 
@@ -586,7 +636,11 @@
 	.bDescriptorSubtype = UAC2_CLOCK_SOURCE,
 	.bClockID = USB_OUT_CLK_ID,
 	.bmAttributes = UAC_CLOCK_SOURCE_TYPE_INT_FIXED,
+#ifdef PANASONIC_UAC2
+	.bmControls = ((CONTROL_RDWR << CLK_FREQ_CTRL) | (CONTROL_RDONLY << CLK_VLD_CTRL)),
+#else
 	.bmControls = (CONTROL_RDONLY << CLK_FREQ_CTRL),
+#endif
 	.bAssocTerminal = 0,
 };
 
@@ -710,7 +764,12 @@
 	.bDescriptorType = USB_DT_ENDPOINT,
 
 	.bEndpointAddress = USB_DIR_OUT,
+#ifdef PANASONIC_UAC2
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE,
+#else
 	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,
+#endif
+	.wMaxPacketSize = cpu_to_le16(192),
 	.bInterval = 1,
 };
 
@@ -718,7 +777,12 @@
 	.bLength = USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType = USB_DT_ENDPOINT,
 
+#ifdef PANASONIC_UAC2
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE,
+#else
 	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,
+#endif
+	.wMaxPacketSize = cpu_to_le16(192),
 	.bInterval = 4,
 };
 
@@ -785,7 +849,12 @@
 	.bDescriptorType = USB_DT_ENDPOINT,
 
 	.bEndpointAddress = USB_DIR_IN,
+#ifdef PANASONIC_UAC2
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE,
+#else
 	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,
+#endif
+	.wMaxPacketSize = cpu_to_le16(192),
 	.bInterval = 1,
 };
 
@@ -793,7 +862,12 @@
 	.bLength = USB_DT_ENDPOINT_SIZE,
 	.bDescriptorType = USB_DT_ENDPOINT,
 
+#ifdef PANASONIC_UAC2
+	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ADAPTIVE,
+#else
 	.bmAttributes = USB_ENDPOINT_XFER_ISOC | USB_ENDPOINT_SYNC_ASYNC,
+#endif
+	.wMaxPacketSize = cpu_to_le16(192),
 	.bInterval = 4,
 };
 
@@ -829,6 +903,7 @@
 	(struct usb_descriptor_header *)&fs_epout_desc,
 	(struct usb_descriptor_header *)&as_iso_out_desc,
 
+#ifndef USB_ISO_IN_NON_EXIST
 	(struct usb_descriptor_header *)&std_as_in_if0_desc,
 	(struct usb_descriptor_header *)&std_as_in_if1_desc,
 
@@ -836,6 +911,7 @@
 	(struct usb_descriptor_header *)&as_in_fmt1_desc,
 	(struct usb_descriptor_header *)&fs_epin_desc,
 	(struct usb_descriptor_header *)&as_iso_in_desc,
+#endif	/* USB_ISO_IN_NON_EXIST */
 	NULL,
 };
 
@@ -859,6 +935,7 @@
 	(struct usb_descriptor_header *)&hs_epout_desc,
 	(struct usb_descriptor_header *)&as_iso_out_desc,
 
+#ifndef USB_ISO_IN_NON_EXIST
 	(struct usb_descriptor_header *)&std_as_in_if0_desc,
 	(struct usb_descriptor_header *)&std_as_in_if1_desc,
 
@@ -866,6 +943,7 @@
 	(struct usb_descriptor_header *)&as_in_fmt1_desc,
 	(struct usb_descriptor_header *)&hs_epin_desc,
 	(struct usb_descriptor_header *)&as_iso_in_desc,
+#endif	/* USB_ISO_IN_NON_EXIST */
 	NULL,
 };
 
@@ -873,12 +951,41 @@
 	__u32	dCUR;
 };
 
+#ifdef PANASONIC_UAC2
+struct cntrl_range_lay3 {
+	__u16	wNumSubRanges;
+	__u32	dMIN1;
+	__u32	dMAX1;
+	__u32	dRES1;
+	__u32	dMIN2;
+	__u32	dMAX2;
+	__u32	dRES2;
+} __packed;
+
+struct cntrl_range_lay3 p_srange = {
+	.wNumSubRanges = 0x0001,
+	.dMIN1 = 44100, 
+	.dMAX1 = 44100, 
+	.dRES1 = 0, 
+};
+
+struct cntrl_range_lay3 c_srange = {
+	.wNumSubRanges = 0x0002, 
+	.dMIN1 = 44100, 
+	.dMAX1 = 44100, 
+	.dRES1 = 0, 
+	.dMIN2 = 48000, 
+	.dMAX2 = 48000, 
+	.dRES2 = 0,
+};
+#else
 struct cntrl_range_lay3 {
 	__u16	wNumSubRanges;
 	__u32	dMIN;
 	__u32	dMAX;
 	__u32	dRES;
 } __packed;
+#endif
 
 static inline void
 free_ep(struct uac2_rtd_params *prm, struct usb_ep *ep)
@@ -886,6 +993,9 @@
 	struct snd_uac2_chip *uac2 = prm->uac2;
 	int i;
 
+	if (!prm->ep_enabled)
+		return;
+
 	prm->ep_enabled = false;
 
 	for (i = 0; i < USB_XFERS; i++) {
@@ -917,6 +1027,7 @@
 			"%s:%d Error!\n", __func__, __LINE__);
 		return ret;
 	}
+	iad_desc.bFirstInterface = ret;
 	std_ac_if_desc.bInterfaceNumber = ret;
 	agdev->ac_intf = ret;
 	agdev->ac_alt = 0;
@@ -1190,10 +1301,25 @@
 	u16 w_value = le16_to_cpu(cr->wValue);
 	u8 entity_id = (w_index >> 8) & 0xff;
 	u8 control_selector = w_value >> 8;
+#ifdef PANASONIC_UAC2
+	struct cntrl_range_lay3 *r;
+#else
 	struct cntrl_range_lay3 r;
+#endif
 	int value = -EOPNOTSUPP;
 
 	if (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {
+#ifdef PANASONIC_UAC2
+		if (entity_id == USB_IN_CLK_ID)
+			r = &p_srange;
+		else if (entity_id == USB_OUT_CLK_ID)
+			r = &c_srange;
+		else
+			return -EOPNOTSUPP;
+
+		value = min_t(unsigned, w_length, sizeof (struct cntrl_range_lay3));
+		memcpy(req->buf, r, value);
+#else
 		if (entity_id == USB_IN_CLK_ID)
 			r.dMIN = p_srate;
 		else if (entity_id == USB_OUT_CLK_ID)
@@ -1207,6 +1333,7 @@
 
 		value = min_t(unsigned, w_length, sizeof r);
 		memcpy(req->buf, &r, value);
+#endif
 	} else {
 		dev_err(&uac2->pdev.dev,
 			"%s:%d control_selector=%d TODO!\n",
@@ -1227,15 +1354,70 @@
 		return -EOPNOTSUPP;
 }
 
+#ifdef PANASONIC_UAC2
+static void audio_ep0_complete(struct usb_ep *ep, struct usb_request *req)
+{
+	unsigned size;
+	int i;
+	unsigned int num;
+	unsigned char *p;
+	int status = req->status;
+
+	if(!status){
+		size = get_unaligned_le32(req->buf);
+		num = c_srange.wNumSubRanges;
+		p = (unsigned char *)&c_srange;
+
+		for(i = 0; i < num; i++){
+			__u32 *pdMIN;
+			__u32 *pdMAX;
+			__u32 *pdRES;
+
+			pdMIN = (__u32*)(p+(12*i)+2);
+			pdMAX = (__u32*)(p+(12*i)+6);
+			pdRES = (__u32*)(p+(12*i)+10);
+
+			if(size < *pdMIN)
+				break;					/* out of range */
+
+			if(*pdRES == 0 || size == 0){
+				/* if dRES == 0 -> dMIN = dMAX */
+				if(*pdMIN == size){
+					c_srate = size;		/* range match */
+					break;
+				}
+			}else{
+				if(size > *pdMAX)
+					continue;			/* serch next SubRanges */
+
+				if((size - *pdMIN) % *pdRES == 0){
+					c_srate = size;		/* range match */
+					break;
+				}
+			}
+		}
+	}
+}
+#endif
+
 static int
 out_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)
 {
 	u16 w_length = le16_to_cpu(cr->wLength);
 	u16 w_value = le16_to_cpu(cr->wValue);
 	u8 control_selector = w_value >> 8;
+#ifdef PANASONIC_UAC2
+	struct usb_request *req = fn->config->cdev->req;
+
+	if (control_selector == UAC2_CS_CONTROL_SAM_FREQ){
+		req->complete = audio_ep0_complete;
+		return w_length;
+	}
+#else
 
 	if (control_selector == UAC2_CS_CONTROL_SAM_FREQ)
 		return w_length;
+#endif
 
 	return -EOPNOTSUPP;
 }
diff -uNr linux-3.14.19/drivers/usb/gadget/iap2.c linux-gerda/drivers/usb/gadget/iap2.c
--- linux-3.14.19/drivers/usb/gadget/iap2.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/iap2.c	2017-06-22 09:52:55.355039175 +0900
@@ -0,0 +1,200 @@
+/*
+ * carplay.c -- IAP2 gadget driver
+ *
+ * Copyright (C) 2016 Panasonic
+ *
+ *  Vendor + AUDIO 2.0
+ *
+ */
+
+/* #define DEBUG */
+/* #define VERBOSE_DEBUG */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/usb/composite.h>
+
+#include "f_uac2.c"
+
+#define DRIVER_DESC		"iAP2 Gadget"/*TODO:ç¢ºè¡¦*/
+
+/*-------------------------------------------------------------------------*/
+
+#define DRIVER_VENDOR_NUM		0x0525	/*  *//*TODO:ç¢ºè¡¦*/
+#define DRIVER_PRODUCT_NUM		0xa4a1	/*  *//*TODO:ç¢ºè¡¦*/
+
+/*-------------------------------------------------------------------------*/
+USB_GADGET_COMPOSITE_OPTIONS();
+
+static struct usb_device_descriptor device_desc = {
+	.bLength =		sizeof device_desc,
+	.bDescriptorType =	USB_DT_DEVICE,
+
+	.bcdUSB =		cpu_to_le16 (0x0200),
+
+	.bDeviceClass =		0,
+	.bDeviceSubClass =	0,
+	.bDeviceProtocol =	0,
+	/* .bMaxPacketSize0 = f(hardware) */
+
+	/* Vendor and product id defaults change according to what configs
+	 * we support.  (As does bNumConfigurations.)  These values can
+	 * also be overridden by module parameters.
+	 */
+	.idVendor =		cpu_to_le16 (DRIVER_VENDOR_NUM),
+	.idProduct =		cpu_to_le16 (DRIVER_PRODUCT_NUM),
+	/* .bcdDevice = f(hardware) */
+	/* .iManufacturer = DYNAMIC */
+	/* .iProduct = DYNAMIC */
+	/* NO SERIAL NUMBER */
+	.bNumConfigurations =	1,
+};
+
+static struct usb_otg_descriptor otg_descriptor = {
+	.bLength =		sizeof otg_descriptor,
+	.bDescriptorType =	USB_DT_OTG,
+
+	/* REVISIT SRP-only hardware is possible, although
+	 * it would not be called "OTG" ...
+	 */
+	.bmAttributes =		USB_OTG_SRP | USB_OTG_HNP,
+};
+
+static const struct usb_descriptor_header *otg_desc[] = {
+	(struct usb_descriptor_header *) &otg_descriptor,
+	NULL,
+};
+
+/* string IDs are assigned dynamically */
+static struct usb_string strings_dev[] = {
+	[USB_GADGET_MANUFACTURER_IDX].s = "Panasonic Corporation",/*TODO:ç¢ºè¡¦*/
+	[USB_GADGET_PRODUCT_IDX].s = "DVD Reciever",/*TODO:ç¢ºè¡¦*/
+	[USB_GADGET_SERIAL_IDX].s = "10",/*TODO:ç¢ºè¡¦*/
+	{  } /* end of list */
+};
+
+static struct usb_gadget_strings stringtab_dev = {
+	.language	= 0x0409,	/* en-us */
+	.strings	= strings_dev,
+};
+
+static struct usb_gadget_strings *dev_strings[] = {
+	&stringtab_dev,
+	NULL,
+};
+
+static struct usb_function_instance *f_iap2_inst;
+static struct usb_function *f_iap2;
+
+/*-------------------------------------------------------------------------*/
+
+static int __init iap2_do_config(struct usb_configuration *c)
+{
+	int status;
+
+	/* FIXME alloc iConfiguration string, set it in c->strings */
+
+	if (gadget_is_otg(c->cdev->gadget)) {
+		c->descriptors = otg_desc;
+		c->bmAttributes |= USB_CONFIG_ATT_WAKEUP;
+	}
+
+	f_iap2 = usb_get_function(f_iap2_inst);
+	if (IS_ERR(f_iap2)) {
+		status = PTR_ERR(f_iap2);
+		return status;
+	}
+
+	status = usb_add_function(c, f_iap2);
+	if (status < 0)
+		goto err_func_iap2;
+
+	audio_bind_config(c);
+
+	return 0;
+
+err_func_iap2:
+	usb_put_function(f_iap2);
+	return status;
+}
+
+static struct usb_configuration iap2_config_driver = {
+	/* .label = f(hardware) */
+	.label			= "iAP2",/*TODO:ç¢ºè¡¦*/
+	.bConfigurationValue	= 1,
+	/* .iConfiguration = DYNAMIC */
+	.bmAttributes		= USB_CONFIG_ATT_SELFPOWER,
+	.unbind			= uac2_unbind_config,
+};
+
+/*-------------------------------------------------------------------------*/
+
+static int __init iap2_bind(struct usb_composite_dev *cdev)
+{
+	struct usb_gadget	*gadget = cdev->gadget;
+	int			status;
+
+	f_iap2_inst = usb_get_function_instance("iap2");
+	if (IS_ERR(f_iap2_inst))
+		return PTR_ERR(f_iap2_inst);
+	
+	/* Allocate string descriptor numbers ... note that string
+	 * contents can be overridden by the composite_dev glue.
+	 */
+
+	status = usb_string_ids_tab(cdev, strings_dev);
+	if (status < 0)
+		goto fail0;
+	device_desc.iManufacturer = strings_dev[USB_GADGET_MANUFACTURER_IDX].id;
+	device_desc.iProduct = strings_dev[USB_GADGET_PRODUCT_IDX].id;
+	device_desc.iSerialNumber = strings_dev[USB_GADGET_SERIAL_IDX].id;
+	
+	status = usb_add_config(cdev, &iap2_config_driver,
+				iap2_do_config);
+	if (status < 0)
+		goto fail0;
+
+	usb_composite_overwrite_options(cdev, &coverwrite);
+	dev_info(&gadget->dev, "%s\n", DRIVER_DESC);
+
+	return 0;
+
+fail0:
+	usb_put_function_instance(f_iap2_inst);
+	return status;
+}
+
+static int __exit iap2_unbind(struct usb_composite_dev *cdev)
+{
+	if (!IS_ERR_OR_NULL(f_iap2))
+		usb_put_function(f_iap2);
+	if (!IS_ERR_OR_NULL(f_iap2_inst))
+		usb_put_function_instance(f_iap2_inst);
+
+	return 0;
+}
+
+static __refdata struct usb_composite_driver iap2_driver = {
+	.name		= "g_iap2",
+	.dev		= &device_desc,
+	.strings	= dev_strings,
+	.max_speed	= USB_SPEED_HIGH,
+	.bind		= iap2_bind,
+	.unbind		= __exit_p(iap2_unbind),
+};
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Panasonic.");/*TODO:ç¢ºè¡¦*/
+MODULE_LICENSE("GPL");
+
+static int __init init(void)
+{
+	return usb_composite_probe(&iap2_driver);
+}
+module_init(init);
+
+static void __exit cleanup(void)
+{
+	usb_composite_unregister(&iap2_driver);
+}
+module_exit(cleanup);
diff -uNr linux-3.14.19/drivers/usb/gadget/panasonic_udc.h linux-gerda/drivers/usb/gadget/panasonic_udc.h
--- linux-3.14.19/drivers/usb/gadget/panasonic_udc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/panasonic_udc.h	2017-06-22 09:52:55.359039175 +0900
@@ -0,0 +1,818 @@
+/*
+ * linux/drivers/usb/gadget/panasonic_udc.h
+ * PANASONIC on-chip high/full speed USB device controllers
+ *
+ * Copyright (C) 2014 Panasonic
+ *
+ */
+
+#ifndef __PANASONIC_UDC_H__
+#define __PANASONIC_UDC_H__
+
+/****************************************************************************/
+/* config																	*/
+/****************************************************************************/
+
+#define ERROR_PRINT			printk
+//#define REG_WRITE_PRINT	printk		/*_ ¥ì¥¸¥¹¥¿¤Ø¤Î½ñ¤­¹þ¤ß¤ò¥×¥ê¥ó¥È¥¢¥¦¥È¤¹¤ë¡£¤¿¤À¤·FIFO¤Ï½ü¤¯¡£ _*/
+//#define FIFO_PRINT		printk		/*_ FIFO¤Ø¤ÎÆÉ¤ß½ñ¤­¤ò¥×¥ê¥ó¥È¥¢¥¦¥È¤¹¤ë¡£ _*/
+//#define DMA_PRINT 		printk		/*_ 2014/11/21 debug _*/
+//#define QUEUE_LOG			printk
+
+//#define IN_DATA_PRINT		printk
+//#define OUT_DATA_PRINT	printk
+
+//#define DEBUG_PRINT		printk
+//#define DEBUG_EP0			printk
+//#define DEBUG_SETUP		printk
+
+/*_ Á´¾Ã¤· _*/
+//#define printk(args...)
+
+/****************************************************************************/
+#ifndef ERROR_PRINT
+# define ERROR_PRINT(...)			do{}while(0)
+#endif
+
+#ifndef REG_WRITE_PRINT
+# define REG_WRITE_PRINT(fmt,args...)	do{}while(0)
+#endif
+#ifndef FIFO_PRINT
+# define FIFO_PRINT(fmt,args...)	do{}while(0)
+#endif
+#ifndef DMA_PRINT
+# define DMA_PRINT(fmt,args...)		do{}while(0)
+#endif
+
+#ifndef QUEUE_LOG
+# define QUEUE_LOG(fmt,args...)		do{}while(0)
+#endif
+
+#ifndef IN_DATA_PRINT
+# define IN_DATA_PRINT(...)			do{}while(0)
+#endif
+
+#ifndef OUT_DATA_PRINT
+# define OUT_DATA_PRINT(...)		do{}while(0)
+#endif
+
+#ifndef DEBUG_EP0
+# define DEBUG_EP0(fmt,args...)		do{}while(0)
+#endif
+#ifndef DEBUG_SETUP
+# define DEBUG_SETUP(fmt,args...)	do{}while(0)
+#endif
+#ifndef DEBUG_PRINT
+# define NO_STATES
+# define DEBUG_PRINT(fmt,args...)			do{}while(0)
+#endif
+
+/****************************************************************************/
+/* register and IRQ															*/
+/****************************************************************************/
+#define IRQ_USBINTR_0			160		/*_ USB0IP¤Î³ä¹þ¤ßÈÖ¹æ _*/
+#define IRQ_SDMAC_RXINTR_0		175		/*_ SDMAC¤ÎCh6¡Ê¼õ¿®¡Ë¤Î³ä¤ê¹þ¤ßÈÖ¹æ _*/
+#define IRQ_SDMAC_TXINTR_0		176		/*_ SDMAC¤ÎCh7¡ÊÁ÷¿®¡Ë¤Î³ä¤ê¹þ¤ßÈÖ¹æ _*/
+#define IRQ_USBINTR_1			165		/*_ USB1IP¤Î³ä¹þ¤ßÈÖ¹æ _*/
+#define IRQ_SDMAC_RXINTR_1		177		/*_ SDMAC¤ÎCh8¡Ê¼õ¿®¡Ë¤Î³ä¤ê¹þ¤ßÈÖ¹æ _*/
+#define IRQ_SDMAC_TXINTR_1		178		/*_ SDMAC¤ÎCh9¡ÊÁ÷¿®¡Ë¤Î³ä¤ê¹þ¤ßÈÖ¹æ _*/
+
+#define BIT0	(1<<0)
+#define BIT1	(1<<1)
+#define BIT2	(1<<2)
+#define BIT3	(1<<3)
+#define BIT4	(1<<4)
+#define BIT5	(1<<5)
+#define BIT6	(1<<6)
+#define BIT7	(1<<7)
+#define BIT8	(1<<8)
+#define BIT9	(1<<9)
+#define BIT10	(1<<10)
+#define BIT11	(1<<11)
+#define BIT12	(1<<12)
+#define BIT13	(1<<13)
+#define BIT14	(1<<14)
+#define BIT15	(1<<15)
+
+//USBTOP register
+#define USB_TOP_BASE_0			0x9C008000
+#define USB_TOP_BASE_1			0x9C038000
+#define USB_TOP_BASE_SIZE		0x30
+
+#define USB_SEL					(0x00)
+#define USBSEL					BIT0
+#define DNPULLDOWN				BIT1
+#define DPPULLDOWN				BIT2
+
+
+//USBIP register
+#define USB_DEV_BASE_0			0x9C009000
+#define USB_DEV_BASE_1			0x9C039000
+#define USB_DEV_BASE_SIZE		0x100
+
+#define USB_CSR					(0x00)
+#define IRQ_REG					(0x04)
+#define IRQ_ENA_REG				(0x08)
+
+#define USB_ADDR_REG			(0x10)
+#define SOF_CNT_REG				(0x14)
+#define EP0_CSR_REG				(0x18)
+#define INDEX_REG				(0x1C)
+
+#define EP_CONFIG_REG			(0x40)
+#define EP_CONFIG2_REG			(0x44)
+#define IN_CSR_REG				(0x48)
+#define OUT_CSR_REG				(0x4C)
+#define OUT_WRT_CNT_REG			(0x50)
+#define DMA_COUNT_L				(0x54)
+#define DMA_COUNT_H				(0x58)
+#define FIFO_SIZE				(0x60)
+#define FIFO_START				(0x64)
+
+#define DMA_FIFO0_CNT			(0x80)
+#define DMA_FIFO0_STATUS		(0x88)
+#define DMA_FIFO0_READ			(0x8C)
+
+#define DMA_FIFO1_CNT			(0x90)
+#define DMA_FIFO1_STATUS		(0x98)
+#define DMA_FIFO1_READ			(0x9C)
+
+#define DMA_IF_CTR				(0xB8)
+
+#define EP0_FIFO_REG			(0xC0)
+#define EP1_FIFO_REG			(0xC4)
+#define EP2_FIFO_REG			(0xC8)
+#define EP3_FIFO_REG			(0xCC)
+#define EP4_FIFO_REG			(0xD0)
+#define EP5_FIFO_REG			(0xD4)
+#define EP6_FIFO_REG			(0xD8)
+#define EP7_FIFO_REG			(0xDC)
+#define EP8_FIFO_REG			(0xE0)
+
+//USB_CSR
+#define USB_CSR_ENABLE_SUSPEND		BIT0
+#define USB_CSR_SPEED			BIT5
+#define USB_FORCE_FS			BIT7
+#define FUNCTION_ENABLE			BIT8
+#define USB_CSR_VBUS			BIT9
+#define TEST_SE0_NAK_BIT		BIT12
+#define TEST_J_BIT				BIT13
+#define TEST_K_BIT				BIT14
+#define TEST_PACKET_BIT			BIT15
+
+//EP0_CSR_REG
+#define EP0_OUT_PKT_RDY			BIT0
+#define EP0_CLEAR_OPR			BIT1
+#define EP0_IN_PKT_RDY			BIT2
+#define EP0_ODD_IN_PKT			BIT3
+#define EP0_IPR_CLEAR			BIT4
+#define EP0_SEND_STALL			BIT5
+#define EP0_SENT_STALL			BIT6
+#define EP0_DATA_END			BIT7
+#define EP0_DATA_END_CLR		BIT8
+#define EP0_SETUP_END			BIT9
+#define EP0_CLR_SETUP_END		BIT10
+#define EP0_SETUP_TOKEN			BIT11
+
+//IRQ_REG and IRQ_ENA_REG
+#define EP0_INTERRUPT			BIT0
+#define EP1_INTERRUPT			BIT1
+#define EP2_INTERRUPT			BIT2
+#define EP3_INTERRUPT			BIT3
+#define EP4_INTERRUPT			BIT4
+#define EP5_INTERRUPT			BIT5
+#define EP6_INTERRUPT			BIT6
+#define EP7_INTERRUPT			BIT7
+#define EP8_INTERRUPT			BIT8
+#define VBUS_INTERRUPT			BIT12
+#define SUSPEND_INTERRUPT		BIT13
+#define RESUME_INTERRUPT		BIT14
+#define RESET_INTERRUPT			BIT15
+
+//EP_CONFIG_REG
+#define EP_DIRECTION			BIT0
+//#define EP_MAXP				BIT4-BIT11
+#define EP_SINGLE				BIT15
+
+//IN_CSR_REG
+#define MCU_IN_PKT_RDY			BIT0	/*_ FIFO¤Ë¶õ¤­¤¬Ìµ¤¤ _*/
+#define USB_IN_PKT_RDY			BIT1	/*_ °ì¥Ð¥¤¥È¤Ç¤âÆþ¤Ã¤Æ¤¤¤ë¤« _*/
+#define ODD_IN_PKT				BIT2
+#define IPR_CLEAR				BIT3	/*_¥Ñ¥±¥Ã¥È¤¬Á÷¿®¤µ¤ì¤¿¤« _*/
+#define IN_SEND_STALL			BIT4
+#define IN_SENT_STALL			BIT5
+#define IN_RST_DATA_PID			BIT6
+#define IN_FIFO_FLUSH			BIT11
+
+//OUT_CSR_REG
+#define MCU_OUT_PKT_RDY			BIT0	/*_ FIFO¤Ë1¥Ñ¥±¥Ã¥È°Ê¾å¤Î¥Ç¡¼¥¿¤¬¤¢¤ë  _*/
+#define USB_OUT_PKT_RDY			BIT1	/*_ FIFO¤Ë¶õ¤­¤¬¤Ê¤¤ _*/
+#define SHORT_PACKET			BIT2
+#define FORCE_NAK				BIT3
+#define OUT_SEND_STALL			BIT4
+#define OUT_SENT_STALL			BIT5
+#define OUT_RST_DATA_PID		BIT6
+#define OUT_FIFO_FLUSH			BIT11
+
+//DMA_IF_CTR
+#define DMA_BURST_MODE			BIT1
+
+//Stream Direct Memory Access (DMA) Controller register
+#define USB_SDMAC_BASE		0x9c005000
+#define USB_SDMAC_BASE_SIZE	0x300
+
+#define USB_SDMAC_STRT				(0x000)					/*_ DMAµ¯Æ°¡¦Ãæ»ßÍ×µá¥ì¥¸¥¹¥¿	                _*/
+#define USB_SDMAC_PERFCNFG			(0x008)					/*_ À­Ç½ÀßÄê¥ì¥¸¥¹¥¿                            _*/
+#define	USB_SDMAC_CAUSE				(0x010)					/*_ ¥½¥Õ¥ÈÍ×°ø¥ì¥¸¥¹¥¿                          _*/
+#define	USB_SDMAC_STAT0				(0x020)					/*_ Ê£¿ô¥Á¥ã¥Í¥ë¾õÂÖ¥ì¥¸¥¹¥¿                    _*/
+#define	USB_SDMAC_RBFLUSH0			(0x040)					/*_ ¥ê¥ó¥°¥Ð¥Ã¥Õ¥¡¥Õ¥é¥Ã¥·¥å¥ì¥¸¥¹¥¿            _*/
+#define	USB_SDMAC_PARTRESET0		(0x050)					/*_ ¥Ñ¡¼¥·¥ã¥ë¥ê¥»¥Ã¥È¥ì¥¸¥¹¥¿                  _*/
+#define	USB_SDMAC_MONNUM			(0x058)					/*_ ¥Ï¡¼¥É¥¦¥§¥¢¾ðÊóÈÖ¹æÀßÄê¥ì¥¸¥¹¥¿            _*/
+#define	USB_SDMAC_MONDAT			(0x05C)					/*_ ¥Ï¡¼¥É¥¦¥§¥¢¾ðÊó¥Ç¡¼¥¿¥ì¥¸¥¹¥¿              _*/
+#define	USB_SDMAC_TEST				(0x0A0)					/*_ ¥Ç¥Ð¥Ã¥°¥ì¥¸¥¹¥¿                            _*/
+
+#define	USB_SDMAC_CHnCTRL1(n)		(0x100+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÀ©¸æ¥ì¥¸¥¹¥¿1                      _*/
+#define	USB_SDMAC_CHnCTRL2(n)		(0x104+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÀ©¸æ¥ì¥¸¥¹¥¿2                      _*/
+#define	USB_SDMAC_CHnSTAT(n)		(0x110+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ën¥¹¥Æ¡¼¥¿¥¹¥ì¥¸¥¹¥¿                 _*/
+#define	USB_SDMAC_CHnIR(n)			(0x114+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ën³ä¹þ¤ßÍ×µá¥ì¥¸¥¹¥¿                 _*/
+#define	USB_SDMAC_CHnIE(n)			(0x118+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ën³ä¹þ¤ß¥¤¥Í¡¼¥Ö¥ë¥ì¥¸¥¹¥¿           _*/
+#define	USB_SDMAC_CHnID(n)			(0x11C+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ën³ä¹þ¤ß¸¡½Ð¥ì¥¸¥¹¥¿                 _*/
+#define	USB_SDMAC_CHnSRCAMODE(n)	(0x120+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÅ¾Á÷¸µ¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É¥ì¥¸¥¹¥¿ _*/
+#define	USB_SDMAC_CHnDSTAMODE(n)	(0x124+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÅ¾Á÷Àè¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É¥ì¥¸¥¹¥¿ _*/
+#define	USB_SDMAC_CHnSRCSTRTADRS(n)	(0x128+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÅ¾Á÷¸µ³«»Ï¥¢¥É¥ì¥¹¥ì¥¸¥¹¥¿         _*/
+#define	USB_SDMAC_CHnDSTSTRTADRS(n)	(0x12C+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÅ¾Á÷Àè³«»Ï¥¢¥É¥ì¥¹¥ì¥¸¥¹¥¿         _*/
+#define	USB_SDMAC_CHnSIZE(n)		(0x130+0x40*(n))		/* n=0-12 *//*_ ¥Á¥ã¥Í¥ënÅ¾Á÷¥µ¥¤¥º¥ì¥¸¥¹¥¿                 _*/
+
+
+//Max packet size
+#define EP0_PACKETSIZE			64
+
+#define UDC_MAX_ENDPOINTS       9	/* EP0-EP8 */
+
+//EP0 State
+#define WAIT_FOR_SETUP          0
+#define DATA_STATE_XMIT         1
+#define DATA_STATE_NEED_ZLP     2
+#define WAIT_FOR_OUT_STATUS     3
+#define DATA_STATE_RECV         4
+#define STATE_NAMES(X)	(((X)==0)?"WAIT_FOR_SETUP":((X)==1)?"DATA_STATE_XMIT":((X)==2)?"DATA_STATE_NEED_ZLP":((X)==3)?"WAIT_FOR_OUT_STATUS":"DATA_STATE_RECV")
+
+//DMA Stete
+#define UDC_DMA_STATE_IDLE		0x00	/*_ DMAÅ¾Á÷¤ò¹Ô¤Ã¤Æ¤¤¤Ê¤¤       _*/
+#define UDC_DMA_STATE_IP_SDMA	0x10	/*_ USBIP¤ÈSDMAC¤ÎÎ¾Êý¤¬DMA¾õÂÖ _*/
+#define UDC_DMA_STATE_IP_ONLY	0x20	/*_ USBIP¤Î¤ßDMA¾õÂÖ(OUT ONLY)  _*/
+#define UDC_DMA_EP_MASK			0x0f	/*_ dma_state¤«¤é¤Î¥¨¥ó¥É¥Ý¥¤¥ó¥ÈÈÖ¹æ¼è¤ê½Ð¤·ÍÑ _*/
+
+//SDMA
+#define USB_SDMAC_CH6_RCV	6		/* ch6:USB0 Device ->RAM */
+#define USB_SDMAC_CH7_SND	7		/* ch7:RAM->USB0 Device */
+#define USB_SDMAC_CH8_RCV	8		/* ch8:USB1 Device ->RAM */
+#define USB_SDMAC_CH9_SND	9		/* ch9:RAM->USB1 Device */
+
+//src/dest Target ID
+#define USB_SDMAC_ADR_USBDEVICE		0x10000000		/* USB_DEVICE */
+
+typedef enum{							/* chanel priority _*/
+	USB_SDMAC_PRI_LV4	 	 = 0x00000004,	/* 4(high) > 6(low) */
+	USB_SDMAC_PRI_LV5	 	 = 0x00000005,
+	USB_SDMAC_PRI_LV6	 	 = 0x00000006
+}eSDMAC_PRILV;
+
+typedef enum{							/* src endian */
+	USB_SDMAC_ED_LITTLE		 = 0x00000000,	/* little endian */
+	USB_SDMAC_ED_32BIG		 = 0x00010000,	/* 32bit-big endian */
+	USB_SDMAC_ED_32HALF		 = 0x00020000,	/* 32bit-half big endian */
+	USB_SDMAC_ED_16BIG		 = 0x00030000	/* 16bit-big endian */
+}eSDMAC_ENDIAN;
+
+typedef enum{							/* address update method selection */
+	USB_SDMAC_ADR_INC		 = 0x00000000,	/* increment */
+	USB_SDMAC_ADR_FIX		 = 0x00000020	/* fix */
+}eSDMAC_ADDRESSING;
+
+typedef enum{							/* IRQ factor */
+	USB_SDMAC_IRQ_ALLOFF	 = 0x00000000,	/* All Disable */
+	USB_SDMAC_IRQ_TRSIZE0	 = 0x00020000,	/* Error Interrupt(transfer size0) */
+	USB_SDMAC_IRQ_WRITEDONE	 = 0x00000002,	/* Write Done Interrupt */
+	USB_SDMAC_IRQ_TRSTART	 = 0x00000010,	/* Transfer Start Interrupt */
+	USB_SDMAC_IRQ_TRSTOP	 = 0x00002000,	/* Transfer Cancel Interrupt */
+	USB_SDMAC_IRQ_ALLON		 = 0x00022012	/* All Enable */
+}eSDMAC_IRQTYPE;							/*_ ¸ÄÊÌ¤Ëµö²Ä¤¹¤ë¤â¤Î¤Ï¡¢OR"|"¤ÇÊÂ¤Ù¤ë _*/
+
+typedef enum{
+	USB_SDMAC_TRTYPE_NORMAL	 = 0x00000000,	/* normal memory */
+}eSDMAC_TRANS;
+
+/*---------------------------------------------------------------------------*/
+
+/****************************************************************************/
+/* DRIVER DATA STRUCTURES and UTILITIES										*/
+/****************************************************************************/
+struct panasonic_ep {
+	struct usb_ep ep;
+	struct panasonic_udc *dev;
+	unsigned long irqs;
+
+	/* analogous to a host-side qh */
+	struct list_head queue;
+	const struct usb_endpoint_descriptor *desc;
+	u32 csr;
+	u32 fifo;
+	unsigned num:8,
+	         fifo_size:12,
+	         stopped:1,
+	         wedged:1,
+	         is_in:1,
+	         is_iso:1,
+	         dma:1,
+	         not_empty:1;
+};
+
+struct panasonic_udc {
+	/* each device provides one gadget, several endpoints */
+	struct usb_gadget gadget;
+	struct device *dev;
+	unsigned short dev_id;
+
+	spinlock_t lock;
+	int ep0state;
+	struct panasonic_ep ep[UDC_MAX_ENDPOINTS];
+	struct usb_gadget_driver *driver;
+	unsigned char usb_address;
+	unsigned protocol_stall:1,
+	         softconnect:1,
+	         is_selfpowered:1,
+	         wakeup:1;
+
+	unsigned int usb_irq;
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	unsigned int dma_out_ch;
+	unsigned int dma_out_irq;
+	unsigned int dma_in_ch;
+	unsigned int dma_in_irq;
+#endif
+
+	unsigned int base_shift;
+	void __iomem *base_addr;
+	void __iomem *usbtop_base_addr;
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	u8 dma_out_state;
+	u8 dma_in_state;
+	void __iomem *sdmac_base_addr;
+#endif
+};
+
+struct panasonic_request {
+	struct usb_request req;
+	struct list_head queue;
+};
+
+struct sdma_setup{
+	int					sdmaid;					/* SDMA ch */
+	eSDMAC_PRILV		ePriLv;					/* chanel priority(Lv4¡Á6) */
+	u32					pulSrc;					/* src(Transfer source) address */
+	eSDMAC_ADDRESSING	eSrc_amode;				/* src(Transfer source) addressing mode  */
+	eSDMAC_TRANS		eSrc_trtype;			/* src(Transfer source) type */
+	u32					pulDis;					/* dest(Transfer destination) address */
+	eSDMAC_ADDRESSING	eDis_amode;				/* dest(Transfer destination) addressing mode */
+	eSDMAC_TRANS		eDis_trtype;			/* dest(Transfer destination) type */
+	u32					ulSize;					/* Transfer size(0¡Á0x001FFFFF) */
+};
+
+
+/****************************************************************************/
+/* Register access functions												*/
+/*_ ¥¨¥ó¥Ç¥£¥¢¥óÃí°Õ CPU¤ÈDeviceLinkIP¤Î¥¨¥ó¥Ç¥£¥¢¥ó¤¬°Û¤Ê¤ë¾ì¹ç½¤Àµ¤¬É¬Í×	_*/
+/****************************************************************************/
+#define USB_IP_REG(dev, port) (void __iomem *)((u32)(dev->base_addr)+(port))
+
+
+/*_ ¥ì¥¸¥¹¥¿¤Ë»ØÄê¥Ó¥Ã¥È¤ò¥»¥Ã¥È¤¹¤ë _*/
+static __inline__ void usb_ioset32(u32 val, void __iomem *add)
+{
+	u32 tmp;
+	tmp = ioread32(add);
+	iowrite32(tmp | val, add);
+	REG_WRITE_PRINT( "0x%08x(0x%08x) |= 0x%08x\n", (u32)add, tmp, val );
+}
+
+/*_ ¥ì¥¸¥¹¥¿¤Î»ØÄê¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+static __inline__ void usb_ioclear32(u32 val, void __iomem *add)
+{
+	u32 tmp;
+	tmp = ioread32(add);
+	iowrite32(tmp & ~val, add);
+	REG_WRITE_PRINT( "0x%08x(0x%08x) &= ~0x%08x\n", (u32)add, tmp, val );
+}
+
+
+/*_ USBIP¥ì¥¸¥¹¥¿¤òÆÉ¤ß¹þ¤à _*/
+static __inline__ u32 usb_read( struct panasonic_udc *dev, u32 port )
+{
+	return ioread32(USB_IP_REG(dev, port));
+}
+
+/*_ USBIP¥ì¥¸¥¹¥¿¤Ë¥Ç¡¼¥¿¤ò½ñ¤­¹þ¤à _*/
+static __inline__ void usb_write( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	iowrite32(val, USB_IP_REG(dev, port));
+	REG_WRITE_PRINT( "0x%08x < 0x%08x\n", (u32)USB_IP_REG(dev, port), val );
+}
+
+/*_ USBIP¥ì¥¸¥¹¥¿¤Ë»ØÄê¥Ó¥Ã¥È¤ò¥»¥Ã¥È¤¹¤ë _*/
+static __inline__ void usb_set( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioset32(val, USB_IP_REG(dev, port));
+}
+
+/*_ USBIP¥ì¥¸¥¹¥¿¤Î»ØÄê¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+static __inline__ void usb_clear( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioclear32(val, USB_IP_REG(dev, port));
+}
+
+
+#define USB_TOP_REG(dev, port) (void __iomem *)((u32)(dev->usbtop_base_addr)+(port))
+
+/*_ USBTOP¥ì¥¸¥¹¥¿¤òÆÉ¤ß¹þ¤à _*/
+static __inline__ u32 usbtop_read( struct panasonic_udc *dev, u32 port )
+{
+	return ioread32(USB_TOP_REG(dev, port));
+}
+
+/*_ USBTOP¥ì¥¸¥¹¥¿¤Ë¥Ç¡¼¥¿¤ò½ñ¤­¹þ¤à _*/
+static __inline__ void usbtop_write( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	iowrite32(val, USB_TOP_REG(dev, port));
+	REG_WRITE_PRINT( "0x%08x < 0x%08x\n", (u32)USB_TOP_REG(dev, port), val );
+}
+
+/*_ USBTOP¥ì¥¸¥¹¥¿¤Ë»ØÄê¥Ó¥Ã¥È¤ò¥»¥Ã¥È¤¹¤ë _*/
+static __inline__ void usbtop_set( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioset32(val, USB_TOP_REG(dev, port));
+}
+
+/*_ USBTOP¥ì¥¸¥¹¥¿¤Î»ØÄê¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+static __inline__ void usbtop_clear( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioclear32(val, USB_TOP_REG(dev, port));
+}
+
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+
+#define USB_SDMAC_REG(dev, port) (void __iomem *)((u32)(dev->sdmac_base_addr)+(port))
+
+/*_ SDMAC¥ì¥¸¥¹¥¿¤òÆÉ¤ß¹þ¤à _*/
+static __inline__ u32 sdmac_read( struct panasonic_udc *dev, u32 port )
+{
+	return ioread32(USB_SDMAC_REG(dev, port));
+}
+
+/*_ SDMAC¥ì¥¸¥¹¥¿¤Ë¥Ç¡¼¥¿¤ò½ñ¤­¹þ¤à _*/
+static __inline__ void sdmac_write( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	iowrite32(val, USB_SDMAC_REG(dev, port));
+	REG_WRITE_PRINT( "0x%08x < 0x%08x\n", (u32)USB_SDMAC_REG(dev, port), val );
+}
+
+/*_ SDMAC¥ì¥¸¥¹¥¿¤Ë»ØÄê¥Ó¥Ã¥È¤ò¥»¥Ã¥È¤¹¤ë _*/
+static __inline__ void sdmac_set( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioset32(val, USB_SDMAC_REG(dev, port));
+}
+
+/*_ SDMAC¥ì¥¸¥¹¥¿¤Î»ØÄê¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+static __inline__ void sdmac_clear( struct panasonic_udc *dev, u32 val, u32 port )
+{
+	usb_ioclear32(val, USB_SDMAC_REG(dev, port));
+}
+
+
+#endif
+
+/****************************************************************************/
+/* Common inline function													*/
+/****************************************************************************/
+/*_ ÁàºîÂÐ¾Ý¤ÎEP¤òÀÚ¤êÂØ¤¨¤ë _*/
+static __inline__ void usb_set_index( struct panasonic_udc *dev, u32 ep )
+{
+	usb_write( dev, ep, INDEX_REG );
+	DEBUG_PRINT( "usb_set_index(%d)\n", ep );
+}
+
+/*_ DMA FIFO0¤ÎÆâÍÆ¤òµÛ¤¤½Ð¤¹¡£ÄÌ¾ï¤³¤Î´Ø¿ô¤Ï¸Æ¤Ð¤ì¤Ê¤¤¡£DMA¤Î°Û¾ï½ªÎ»Åù¤ÇFIFO¤Ë¥Ç¡¼¥¿¤¬»Ä¤Ã¤Æ¤¤¤ë¾ì¹ç¤Ë¸Æ¤Ð¤ì¤ë _*/
+static inline void flushOutDMAFIFO0( struct panasonic_udc *dev )
+{
+	int cnt;
+	int i;
+	cnt = usb_read(dev, DMA_FIFO0_STATUS) >> 8;
+	cnt = (cnt+1)/2;
+
+	for(i=0; i<cnt;i++){
+		u16 t;
+		t = usb_read( dev, DMA_FIFO0_READ );
+		ERROR_PRINT("DMA_FIFO0_READ=0x%04x\n", t );
+	}
+}
+
+/*_ DMA FIFO1¤ÎÆâÍÆ¤òµÛ¤¤½Ð¤¹¡£ÄÌ¾ï¤³¤Î´Ø¿ô¤Ï¸Æ¤Ð¤ì¤Ê¤¤¡£DMA¤Î°Û¾ï½ªÎ»Åù¤ÇFIFO¤Ë¥Ç¡¼¥¿¤¬»Ä¤Ã¤Æ¤¤¤ë¾ì¹ç¤Ë¸Æ¤Ð¤ì¤ë _*/
+static inline void flushOutDMAFIFO1( struct panasonic_udc *dev )
+{
+	int cnt;
+	int i;
+	cnt = usb_read(dev, DMA_FIFO1_STATUS) >> 8;
+	cnt = (cnt+1)/2;
+
+	for(i=0; i<cnt;i++){
+		u16 t;
+		t = usb_read( dev, DMA_FIFO1_READ );
+		ERROR_PRINT("DMA_FIFO1_READ=0x%04x\n", t );
+	}
+}
+
+/*_ Enable EP interrupt _*/
+static inline void pio_irq_enable( struct panasonic_udc *dev, int ep )
+{
+	DEBUG_PRINT( "%s: %d\n", __FUNCTION__, ep );
+	
+	switch( ep ){
+		case 1:
+			usb_set( dev, EP1_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 2:
+			usb_set( dev, EP2_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 3:
+			usb_set( dev, EP3_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 4:
+			usb_set( dev, EP4_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 5:
+			usb_set( dev, EP5_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 6:
+			usb_set( dev, EP6_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 7:
+			usb_set( dev, EP7_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 8:
+			usb_set( dev, EP8_INTERRUPT, IRQ_ENA_REG );
+			break;
+		default:
+			DEBUG_PRINT( "Unknown endpoint: %d\n", ep );
+			break;
+	}
+}
+
+/*_ Disable EP interrupt _*/
+static inline void pio_irq_disable( struct panasonic_udc *dev, int ep )
+{
+	DEBUG_PRINT( "%s: %d\n", __FUNCTION__, ep );
+	
+	switch( ep ){
+		case 1:
+			usb_clear( dev, EP1_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 2:
+			usb_clear( dev, EP2_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 3:
+			usb_clear( dev, EP3_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 4:
+			usb_clear( dev, EP4_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 5:
+			usb_clear( dev, EP5_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 6:
+			usb_clear( dev, EP6_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 7:
+			usb_clear( dev, EP7_INTERRUPT, IRQ_ENA_REG );
+			break;
+		case 8:
+			usb_clear( dev, EP8_INTERRUPT, IRQ_ENA_REG );
+			break;
+		default:
+			ERROR_PRINT( "Unknown endpoint: %d\n", ep );
+			break;
+	}
+}
+
+/*_ Clear EP interrupt _*/
+static inline void pio_irq_clear( struct panasonic_udc *dev, int ep )
+{
+	DEBUG_PRINT( "%s: %d\n", __FUNCTION__, ep );
+	
+	switch( ep ){
+		case 1:
+			usb_write( dev, EP1_INTERRUPT, IRQ_REG );
+			break;
+		case 2:
+			usb_write( dev, EP2_INTERRUPT, IRQ_REG );
+			break;
+		case 3:
+			usb_write( dev, EP3_INTERRUPT, IRQ_REG );
+			break;
+		case 4:
+			usb_write( dev, EP4_INTERRUPT, IRQ_REG );
+			break;
+		case 5:
+			usb_write( dev, EP5_INTERRUPT, IRQ_REG );
+			break;
+		case 6:
+			usb_write( dev, EP6_INTERRUPT, IRQ_REG );
+			break;
+		case 7:
+			usb_write( dev, EP7_INTERRUPT, IRQ_REG );
+			break;
+		case 8:
+			usb_write( dev, EP8_INTERRUPT, IRQ_REG );
+			break;
+		default:
+			ERROR_PRINT( "Unknown endpoint: %d\n", ep );
+			break;
+	}
+}
+
+/*_ PIO¤Ë¤è¤ëINÅ¾Á÷¤Î¼Â½èÍý¡£DeviceLinkIP¤ÎFIFO¥ì¥¸¥¹¥¿¤ËCPU¤«¤éÅ¾Á÷¤¹¤ë¥Ç¡¼¥¿¤ò½ñ¤­¹þ¤à _*/
+static __inline__ int panasonic_write_packet( struct panasonic_ep *ep, struct panasonic_request *req, int max )
+{
+	u8 *buf;
+	int length, count;
+	u32 fifo = ep->fifo;
+	
+	buf = req->req.buf + req->req.actual;
+	prefetch( buf );
+	
+	length = req->req.length - req->req.actual;
+	length = min(length, max);
+	req->req.actual += length;
+	
+	DEBUG_PRINT( "Write %d (max %d), fifo %p\n", length, max, USB_IP_REG(ep->dev, fifo) );
+	
+	count = length;
+	{
+		u32 tmp;
+		int isOdd;
+		isOdd = count%2;
+		for( count/=2 ; 0<count ; count-- ){
+			tmp = *buf;
+			buf++;
+			tmp |= *buf<<8;
+			buf++;
+			usb_write(ep->dev, tmp, fifo);
+			FIFO_PRINT("fifo<%04x\n",tmp);
+		}
+		if( isOdd ){
+			usb_write(ep->dev, *buf, fifo);
+			FIFO_PRINT("fifo<%04x\n",*buf);
+		}
+	}
+	return length;
+}
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+/*_ »ØÄêEP¤ÎDMAÅ¾Á÷¾õÂÖ¤òÊÖ¤¹ _*/
+static __inline__ int get_dma_state_ep(struct panasonic_ep *ep)
+{
+	int ret;
+	u8 dma_state;
+
+	if(ep->is_in){
+		dma_state = ep->dev->dma_in_state;
+	}else{
+		dma_state = ep->dev->dma_out_state;
+	}
+
+	if((dma_state & UDC_DMA_EP_MASK) != ep->num) {
+		ret=UDC_DMA_STATE_IDLE;				/*_ Â¾EP¤¬DMA»ÈÍÑÃæ or DMA IDLE _*/
+	}else if((dma_state & UDC_DMA_STATE_IP_SDMA) == UDC_DMA_STATE_IP_SDMA) {
+		ret=UDC_DMA_STATE_IP_SDMA;
+	}else{
+		ret=UDC_DMA_STATE_IP_ONLY;
+	}
+
+	DEBUG_PRINT( "%s:EP%d state=%d\n", __FUNCTION__, ep->num , ret);
+	return ret;
+}
+
+/*_ »ØÄêsdmaid¤Î³ä¤ê¹þ¤ßÍ×°ø¤¬Å¾Á÷Ãæ»ß¤«¤òÊÖ¤¹ _*/
+static __inline int is_sdma_cancel(struct panasonic_udc *dev, int sdmaid)
+{
+	u32 tmp;
+
+	tmp = sdmac_read(dev, USB_SDMAC_CHnID(sdmaid));
+	if((tmp & USB_SDMAC_IRQ_TRSTOP) == USB_SDMAC_IRQ_TRSTOP){
+		return 1;
+	}else{
+		return 0;
+	}
+}
+#endif
+/****************************************************************************/
+/* USB Device Resource													    */
+/****************************************************************************/
+/* register resource number */
+#define USB_RES_IP_MEM			0
+#define USB_RES_USBTOP_MEM		1
+#define USB_RES_SDMAC_MEM		2
+
+/* IRQ resource number */
+#define USB_RES_DEVICE_IRQ		0
+#define USB_RES_SDMAC_IRQ_RX	1
+#define USB_RES_SDMAC_IRQ_TX	2
+
+/*_ USB Device ¥ê¥½¡¼¥¹¹½Â¤ÂÎ _*/
+static const struct resource device_res[][6]= {
+	{ /* Device #0 */
+		/* USB_RES_IP_MEM */
+		[0] = {
+			.start	= USB_DEV_BASE_0,
+			.end	= USB_DEV_BASE_0 + USB_DEV_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		/* USB_RES_USBTOP_MEM */
+		[1] = {
+			.start	= USB_TOP_BASE_0,
+			.end	= USB_TOP_BASE_0 + USB_TOP_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		}, 
+		/* USB_RES_SDMAC_MEM */
+		[2] = {
+			.start	= USB_SDMAC_BASE,
+			.end	= USB_SDMAC_BASE + USB_SDMAC_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		}, 
+		/* USB_RES_DEVICE_IRQ */
+		[3] = {
+			.start	= IRQ_USBINTR_0,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+		/* USB_RES_SDMAC_IRQ_RX */
+		[4] = {
+			.start	= IRQ_SDMAC_RXINTR_0,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+		/* USB_RES_SDMAC_IRQ_TX */
+		[5] = {
+			.start	= IRQ_SDMAC_TXINTR_0,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+	},
+	{ /* Device #1 */
+		/* USB_RES_IP_MEM */
+		[0] = {
+			.start	= USB_DEV_BASE_1,
+			.end	= USB_DEV_BASE_1 + USB_DEV_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		},
+		/* USB_RES_USBTOP_MEM */
+		[1] = {
+			.start	= USB_TOP_BASE_1,
+			.end	= USB_TOP_BASE_1 + USB_TOP_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		}, 
+		/* USB_RES_SDMAC_MEM */
+		[2] = {
+			.start	= USB_SDMAC_BASE,
+			.end	= USB_SDMAC_BASE + USB_SDMAC_BASE_SIZE - 1,
+			.flags	= IORESOURCE_MEM,
+		}, 
+		/* USB_RES_DEVICE_IRQ */
+		[3] = {
+			.start	= IRQ_USBINTR_1,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+		/* USB_RES_SDMAC_IRQ_RX */
+		[4] = {
+			.start	= IRQ_SDMAC_RXINTR_1,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+		/* USB_RES_SDMAC_IRQ_TX */
+		[5] = {
+			.start	= IRQ_SDMAC_TXINTR_1,
+			.flags	= IORESOURCE_IRQ | IORESOURCE_IRQ_HIGHLEVEL,
+		},
+	},
+};
+
+/****************************************************************************/
+/* Global Variable/function												    */
+/****************************************************************************/
+//panasonic_udc_main.c
+extern const char ep0name[];		//EP0 name
+
+void panasonic_done(struct panasonic_ep *ep, struct panasonic_request *req, int status);	/*_ Å¾Á÷´°Î»¥³¡¼¥ë¥Ð¥Ã¥¯¤Î¸Æ¤Ó½Ð¤· _*/
+int panasonic_set_halt(struct usb_ep *_ep, int value);
+
+//panasonic_udc_ep0.c
+void panasonic_udc_ep0_kick( struct panasonic_udc *dev, struct panasonic_ep *ep );
+void panasonic_udc_handle_ep0(struct panasonic_udc *dev, u32 intr);
+
+#endif
diff -uNr linux-3.14.19/drivers/usb/gadget/panasonic_udc_ep0.c linux-gerda/drivers/usb/gadget/panasonic_udc_ep0.c
--- linux-3.14.19/drivers/usb/gadget/panasonic_udc_ep0.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/panasonic_udc_ep0.c	2017-06-22 09:52:55.355039175 +0900
@@ -0,0 +1,718 @@
+/*
+ * linux/drivers/usb/gadget/panasonic_udc_ep0.c
+ * PANASONIC on-chip high/full speed USB device controllers
+ *
+ * Copyright (C) 2014 Panasonic
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/prefetch.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+
+#include "panasonic_udc.h"
+
+#define TEST_J_PATTERN			(0x01)
+#define TEST_K_PATTERN			(0x02)
+#define TEST_SE0_NAK_PATTERN	(0x03)
+#define TEST_PACKET_PATTERN		(0x04)
+
+/****************************************************************/
+/* End Point 0 related functions                                */
+/****************************************************************/
+static struct panasonic_ep *
+panasonic_get_ep_by_addr(struct panasonic_udc *dev, u16 wIndex)
+{
+	struct panasonic_ep *ep;
+
+	DEBUG_EP0( "%s: %p\n", __FUNCTION__, dev );
+
+	if ((wIndex & USB_ENDPOINT_NUMBER_MASK) == 0)
+		return &dev->ep[0];
+
+	list_for_each_entry(ep, &dev->gadget.ep_list, ep.ep_list) {
+		u8 bEndpointAddress;
+
+		if (!ep->desc)
+			continue;
+		bEndpointAddress = ep->desc->bEndpointAddress;
+		if ((wIndex ^ bEndpointAddress) & USB_DIR_IN)
+			continue;
+		if ((wIndex & 0x0f) == (bEndpointAddress & 0x0f))
+			return ep;
+	}
+	return NULL;
+}
+
+//dequeue EP0 ALL requests
+void panasonic_udc_nuke( struct panasonic_ep *ep, int status )
+{
+	struct panasonic_request *req;
+	
+	DEBUG_EP0( "%s, %p\n", __FUNCTION__, ep );
+	
+	while( !list_empty(&ep->queue) ){
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+		panasonic_done( ep, req, status );
+	}
+}
+
+/*_ EP0¤ÇINÅ¾Á÷¤ò¹Ô¤¦ _*/
+static int write_fifo_ep0( struct panasonic_ep *ep, struct panasonic_request *req, int* isOdd )
+{
+	u32 max;
+	unsigned count;
+	int is_last;
+	
+	max = ep->ep.maxpacket;	//2^n
+	
+	DEBUG_EP0("%s\n", __FUNCTION__);
+	
+	count = panasonic_write_packet( ep, req, max );
+	*isOdd = (count%2);
+	
+	/* last packet is usually short (or a zlp) */
+	if( unlikely(count != max) )
+		is_last = 1;
+	else{
+		if ( likely(req->req.length != req->req.actual) || req->req.zero )
+			is_last = 0;
+		else
+			is_last = 1;
+	}
+	
+	DEBUG_EP0( "%s: wrote %s %d bytes%s %d left %p\n", __FUNCTION__,
+		ep->ep.name, count, is_last ? "/L" : "", req->req.length - req->req.actual, req );
+	
+	/* requests complete when all IN data is in the FIFO */
+	if( is_last ){
+		panasonic_done( ep, req, 0 );	/*_ ´°Î»¥³¡¼¥ë¥Ð¥Ã¥¯¸Æ¤Ó½Ð¤· _*/
+		return 1;
+	}
+	
+	return 0;
+}
+
+/*_ ¥»¥Ã¥È¥¢¥Ã¥×¥³¥Þ¥ó¥É¼õ¿®ÀìÍÑ _*/
+static __inline__ int panasonic_fifo_read( struct panasonic_ep *ep, unsigned char *cp, int max )
+{
+	int i;
+	u32 tmp;
+	int count;
+	u32 fifo = ep->fifo;
+	
+	count = usb_read(ep->dev, OUT_WRT_CNT_REG);
+	if( count != 8 || max != 8 ){
+		DEBUG_EP0( "%s, count=%d, max=%d\n", __FUNCTION__, count, max );
+		return -1;
+	}
+	
+	for( i=0 ; i<8 ; i+=2 ){
+		tmp = usb_read(ep->dev, fifo);
+		FIFO_PRINT( "fifo>0x%04x\n", fifo );
+		cp[i]   = tmp     &0xff;
+		cp[i+1] = (tmp>>8)&0xff;
+	}
+	
+	return 8;
+}
+
+/*_ EP0¤ÇOUTÅ¾Á÷¤ò¼õ¿®¤¹¤ë _*/
+static int read_fifo_ep0( struct panasonic_ep *ep, struct panasonic_request *req )
+{
+	u32 csr;
+	u8 *buf;
+	unsigned bufferspace, count, is_short;
+	u32 fifo = ep->fifo;
+	int i;
+	
+	DEBUG_EP0("%s\n", __FUNCTION__);
+	
+	csr = usb_read(ep->dev, EP0_CSR_REG);
+//	if( !(csr & EP0_OUT_PKT_RDY) ) return 0;
+	if( !(csr & EP0_OUT_PKT_RDY) ) return -1;
+	
+	buf = req->req.buf + req->req.actual;
+	prefetchw(buf);
+	bufferspace = req->req.length - req->req.actual;
+	
+	/* read all bytes from this packet */
+	if( likely(csr & EP0_OUT_PKT_RDY) ){
+		count = usb_read(ep->dev, OUT_WRT_CNT_REG);
+		req->req.actual += min(count, bufferspace);
+	}else			/* zlp */
+		count = 0;
+	
+	is_short = (count < ep->ep.maxpacket);
+	DEBUG_EP0("read %s %02x, %d bytes%s req %p %d/%d\n",
+		  ep->ep.name, csr, count,
+		  is_short ? "/S" : "", req, req->req.actual, req->req.length);
+	
+#define SETBUF_1BYTE( x )																						\
+	if( unlikely(bufferspace == 0) ){																			\
+		if (req->req.status != -EOVERFLOW) DEBUG_EP0("%s overflow i=%d count=%d\n", ep->ep.name, i, count );	\
+		req->req.status = -EOVERFLOW;																			\
+	} else {																									\
+		*buf++ = (x);																							\
+		bufferspace--;																							\
+	}
+	
+	for( i=0 ; i < count ; i+=2 ){
+		u32 tmp = usb_read(ep->dev, fifo);			/*_ ÆÉ¤á¤ë¤Î¤Ï2¥Ð¥¤¥ÈÃ±°Ì _*/
+		FIFO_PRINT( "fifo>0x%04x\n", fifo );
+		SETBUF_1BYTE( tmp & 0xff );
+		if( i + 1  == count ) break;		/*_ ºÇ¸å¤Î°ì¥Ð¥¤¥È¤ò¥Ð¥Ã¥Õ¥¡¤Ë½ñ¤­½ª¤¨¤¿¤Î¤Ç½ªÎ»¤¹¤ë _*/
+		SETBUF_1BYTE( (tmp>>8) & 0xff );
+	}
+	
+	if( is_short || req->req.actual == req->req.length ){
+		panasonic_done( ep, req, 0 );	/*_ ´°Î»¥³¡¼¥ë¥Ð¥Ã¥¯¸Æ¤Ó½Ð¤· _*/
+		return 1;
+	}
+	
+	/* finished that packet.  the next one may be waiting... */
+	return 0;
+}
+
+//Called from control endpoint function after it decodes a set address setup packet.
+static void udc_set_address( struct panasonic_udc *dev, unsigned char address )
+{
+	DEBUG_EP0( "%s: %d\n", __FUNCTION__, address );
+	dev->usb_address = address;
+	usb_set( dev, BIT7|address, USB_ADDR_REG );
+}
+
+//DATA_STATE_RECV (OUT_PKT_RDY)
+static void panasonic_ep0_out(struct panasonic_udc *dev, u32 csr)
+{
+	struct panasonic_request *req;
+	struct panasonic_ep *ep = &dev->ep[0];
+	int ret;
+	
+	DEBUG_EP0( "%s: %x\n", __FUNCTION__, csr );
+	
+	if( list_empty(&ep->queue) )
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+	
+	if( !req ){
+		DEBUG_EP0("NO REQ??!\n");
+		return;
+	}
+	if( req->req.length == 0 ){
+		DEBUG_EP0("ZERO LENGTH OUT!\n");
+		usb_set(dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG);
+		dev->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+	
+	ret = read_fifo_ep0(ep, req);	/*_ FIFO¤«¤é¥Ç¡¼¥¿¤òÆÉ¤ß¹þ¤à(OUTÅ¾Á÷) ´°Î»¥³¡¼¥ë¥Ð¥Ã¥¯¤â¤³¤ÎÃæ¤Ç¸Æ¤Ð¤ì¤ë _*/
+#if 1
+	if( ret == 1 ){
+		/* Done! */
+		DEBUG_EP0( "%s: finished, waiting for status\n", __FUNCTION__ );
+		
+		usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+		dev->ep0state = WAIT_FOR_SETUP;
+	} else if( ret == -1 ){
+		/* Not yet received.. */
+		DEBUG_EP0("%s: not received\n", __FUNCTION__);
+	} else {
+		/* Not done yet.. */
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+		usb_set( dev, EP0_CLEAR_OPR, EP0_CSR_REG );
+	}
+#else
+	if( ret ){
+		/* Done! */
+		DEBUG_EP0( "%s: finished, waiting for status\n", __FUNCTION__ );
+		
+		usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+		dev->ep0state = WAIT_FOR_SETUP;
+	} else {
+		/* Not done yet.. */
+		DEBUG_EP0("%s: not finished\n", __FUNCTION__);
+		usb_set( dev, EP0_CLEAR_OPR, EP0_CSR_REG );
+	}
+#endif
+}
+
+//DATA_STATE_XMIT
+static int panasonic_ep0_in( struct panasonic_udc *dev, u32 csr )
+{
+	struct panasonic_request *req;
+	struct panasonic_ep *ep = &dev->ep[0];
+	int ret, need_zlp = 0;
+	int isOdd;
+	
+	DEBUG_EP0( "%s: %x\n", __FUNCTION__, csr );
+	
+	if( list_empty(&ep->queue) )
+		req = 0;
+	else
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+	
+	if( !req ){
+		DEBUG_EP0( "%s: NULL REQ\n", __FUNCTION__ );
+		return 0;
+	}
+	
+	if( req->req.length == 0 ){
+		usb_set( dev, (EP0_IN_PKT_RDY | EP0_DATA_END), EP0_CSR_REG );
+		dev->ep0state = WAIT_FOR_SETUP;
+		return 1;
+	}
+	
+	if( req->req.length - req->req.actual == EP0_PACKETSIZE ){
+		/* Next write will end with the packet size, */
+		/* so we need Zero-length-packet */
+		need_zlp = 1;
+	}
+	
+	ret = write_fifo_ep0( ep, req, &isOdd );	/*_ FIFO¤Ë¥Ç¡¼¥¿¤ò½ñ¤­¹þ¤à(INÅ¾Á÷) ´°Î»¥³¡¼¥ë¥Ð¥Ã¥¯¤â¤³¤ÎÃæ¤Ç¸Æ¤Ð¤ì¤ë _*/
+	
+	if( ret == 1 && !need_zlp ){
+		/* Last packet */
+		DEBUG_EP0( "%s: finished, waiting for status\n", __FUNCTION__ );
+		
+		usb_set( dev, (EP0_IN_PKT_RDY | EP0_DATA_END | ((isOdd)?EP0_ODD_IN_PKT:0) ), EP0_CSR_REG );
+		dev->ep0state = WAIT_FOR_SETUP;
+	}else{
+		DEBUG_EP0( "%s: not finished\n", __FUNCTION__ );
+		usb_set( dev, EP0_IN_PKT_RDY | ((isOdd)?EP0_ODD_IN_PKT:0), EP0_CSR_REG );
+	}
+	
+	if( need_zlp ){
+		DEBUG_EP0( "%s: Need ZLP!\n", __FUNCTION__ );
+		usb_set( dev, EP0_IN_PKT_RDY | ((isOdd)?EP0_ODD_IN_PKT:0), EP0_CSR_REG );
+		dev->ep0state = DATA_STATE_NEED_ZLP;
+	}
+	
+	return 1;
+}
+
+//get_status
+static int panasonic_handle_get_status( struct panasonic_udc *dev, struct usb_ctrlrequest *ctrl )
+{
+	struct panasonic_ep *ep0 = &dev->ep[0];
+	struct panasonic_ep *qep;
+	int reqtype = (ctrl->bRequestType & USB_RECIP_MASK);
+	u16 val = 0;
+	
+	if( reqtype == USB_RECIP_INTERFACE ){
+		/* This is not supported.
+		 * And according to the USB spec, this one does nothing..
+		 * Just return 0
+		 */
+		DEBUG_SETUP( "GET_STATUS: USB_RECIP_INTERFACE\n" );
+	}else if( reqtype == USB_RECIP_DEVICE ){
+		DEBUG_SETUP( "GET_STATUS: USB_RECIP_DEVICE\n" );
+		val |= (dev->is_selfpowered << 0);	/* Self power field  */
+		val |= (dev->wakeup << 1); 			/* Remote wakeup field */
+	}else if( reqtype == USB_RECIP_ENDPOINT ){
+		DEBUG_SETUP( "GET_STATUS: USB_RECIP_ENDPOINT (0x%x), ctrl->wLength = %d\n", ctrl->wIndex , ctrl->wLength );
+
+		qep = panasonic_get_ep_by_addr(dev, ctrl->wIndex);
+		if( !qep || ctrl->wLength > 2 || qep->num >= UDC_MAX_ENDPOINTS )
+			return -EOPNOTSUPP;
+		
+		if( qep->is_in != ((ctrl->wIndex & USB_DIR_IN) ? 1 : 0) && qep->num != 0 ){
+			return -EOPNOTSUPP;
+		}
+		
+		/* Return status on next IN token */
+		if(qep->num == 0){
+			val = (usb_read(dev, qep->csr) & EP0_SEND_STALL) == EP0_SEND_STALL;
+		}else {
+			usb_set_index( dev, qep->num );
+			if(qep->is_in){
+				val = (usb_read(dev, qep->csr) & IN_SEND_STALL) == IN_SEND_STALL;
+			}else{
+				val = (usb_read(dev, qep->csr) & OUT_SEND_STALL) == OUT_SEND_STALL;
+			}
+			usb_set_index(dev, 0 );					/* Back to EP0 index */
+		}
+		
+		DEBUG_SETUP( "GET_STATUS, ep: %d (%x), val = %d\n", qep->num, ctrl->wIndex, val );
+	} else {
+		DEBUG_SETUP( "Unknown REQ TYPE: %d\n", reqtype );
+		return -EOPNOTSUPP;
+	}
+	
+	usb_set( dev, EP0_CLEAR_OPR, EP0_CSR_REG );						//Clear "out packet ready"
+	usb_write( dev, val, ep0->fifo );								//Put status to FIFO
+	usb_set( dev, (EP0_IN_PKT_RDY | EP0_DATA_END), EP0_CSR_REG );	//Issue "In packet ready"
+	
+	return 0;
+}
+
+static void write_testpacket_ep0(struct panasonic_udc *dev)
+{
+	u32				save_index;
+	volatile u32	*fifo;
+	
+	save_index	= usb_read( dev, INDEX_REG );
+	usb_set_index( dev, 0 );
+	
+	{
+		u8		cnt;
+		
+		for (cnt=0; cnt<4; cnt++) {		// 8byte
+			usb_set(dev, 0x0000, EP0_FIFO_REG);
+		}
+		usb_set(dev, 0xAA00, EP0_FIFO_REG);
+		for (cnt=0; cnt<3; cnt++) {		// 16byte
+			usb_set(dev, 0xAAAA, EP0_FIFO_REG);
+		}
+		usb_set(dev, 0xEEAA, EP0_FIFO_REG);
+		for (cnt=0; cnt<3; cnt++) {		// 24byte
+			usb_set(dev, 0xEEEE, EP0_FIFO_REG);
+		}
+		usb_set(dev, 0xFEEE, EP0_FIFO_REG);
+		for (cnt=0; cnt<5; cnt++) {		// 36byte
+			usb_set(dev, 0xFFFF, EP0_FIFO_REG);
+		}
+		usb_set(dev, 0x7FFF, EP0_FIFO_REG);
+		usb_set(dev, 0xDFBF, EP0_FIFO_REG);
+		usb_set(dev, 0xF7EF, EP0_FIFO_REG);
+		usb_set(dev, 0xFDFB, EP0_FIFO_REG);
+		usb_set(dev, 0x7EFC, EP0_FIFO_REG);
+		usb_set(dev, 0xDFBF, EP0_FIFO_REG);
+		usb_set(dev, 0xF7EF, EP0_FIFO_REG);
+		usb_set(dev, 0xFDFB, EP0_FIFO_REG);
+		usb_set(dev, 0x00E7, EP0_FIFO_REG); // 53byte
+	}
+	
+	usb_set_index( dev, save_index );
+}
+
+/*
+ * WAIT_FOR_SETUP (OUT_PKT_RDY)
+ *      - read data packet from EP0 FIFO
+ *      - decode command
+ *      - if error
+ *              set EP0_CLEAR_OPR | EP0_DATA_END | EP0_SEND_STALL bits
+ *      - else
+ *              set EP0_CLEAR_OPR | EP0_DATA_END bits
+ */
+static void panasonic_ep0_setup( struct panasonic_udc *dev, u32 csr )
+{
+	struct panasonic_ep *ep = &dev->ep[0];
+	struct usb_ctrlrequest ctrl;
+	int i, bytes;
+	
+	DEBUG_SETUP( "%s: csr=%x\n", __FUNCTION__, csr );
+	
+
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN) {
+		if ((usb_read(dev, USB_CSR) & USB_CSR_SPEED) == USB_CSR_SPEED)
+			dev->gadget.speed = USB_SPEED_HIGH;
+		else
+			dev->gadget.speed = USB_SPEED_FULL;
+		dev_dbg(dev->dev, "%s\n",
+			usb_speed_string(dev->gadget.speed));
+	}
+
+	/* Nuke all previous transfers */
+	panasonic_udc_nuke( ep, -EPROTO );
+	
+	/* read control req from fifo (8 bytes) */
+	bytes = panasonic_fifo_read( ep, (unsigned char *)&ctrl, 8 );
+	/*_ 8°Ê³°¤Ê¤éStall¤Ë¤¹¤Ù¤­¤«¡© _*/
+	if( bytes != 8 ) return;
+	
+	DEBUG_SETUP("Read CTRL REQ %d bytes\n", bytes);
+	DEBUG_SETUP("CTRL.bRequestType = %d (is_in %d)\n", ctrl.bRequestType, ctrl.bRequestType == USB_DIR_IN );
+	DEBUG_SETUP("CTRL.bRequest = %d\n", ctrl.bRequest);
+	DEBUG_SETUP("CTRL.wLength = %d\n", ctrl.wLength);
+	DEBUG_SETUP("CTRL.wValue = %d (%d)\n", ctrl.wValue, ctrl.wValue >> 8);
+	DEBUG_SETUP("CTRL.wIndex = %d\n", ctrl.wIndex);
+	
+	/* Set direction of EP0 */
+	if( likely(ctrl.bRequestType & USB_DIR_IN) ){
+		ep->is_in = 1;
+	} else {
+		ep->is_in = 0;
+	}
+
+	/* Handle some SETUP packets ourselves */
+	switch( ctrl.bRequest ){
+		case USB_REQ_SET_ADDRESS:
+			if( ctrl.bRequestType != (USB_TYPE_STANDARD | USB_RECIP_DEVICE) )
+				break;
+			
+			DEBUG_SETUP( "USB_REQ_SET_ADDRESS (%d)\n", ctrl.wValue );
+			udc_set_address( dev, ctrl.wValue );
+			usb_set(dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+			return;
+		
+		case USB_REQ_GET_STATUS:
+			if( panasonic_handle_get_status(dev, &ctrl) == 0 )
+				return;
+		
+		case USB_REQ_CLEAR_FEATURE:
+		case USB_REQ_SET_FEATURE:
+			if( ctrl.bRequestType == USB_RECIP_ENDPOINT ){
+				struct panasonic_ep *qep;
+				
+				qep = panasonic_get_ep_by_addr(dev, ctrl.wIndex);
+
+				/* Support only HALT feature */
+				if( ctrl.wValue != 0 || ctrl.wLength != 0 || qep->num >= UDC_MAX_ENDPOINTS || qep->num < 1 )
+					break;
+				
+				spin_unlock( &dev->lock );
+				if( ctrl.bRequest == USB_REQ_SET_FEATURE ){
+					DEBUG_SETUP( "SET_FEATURE (%d)\n", qep->num );
+					panasonic_set_halt( &qep->ep, 1 );
+				} else {
+					if(qep->wedged == 1){
+						DEBUG_SETUP( "CLR_FEATURE (%d) wedged, halt not cleared\n", qep->num );
+					}else{
+						DEBUG_SETUP( "CLR_FEATURE (%d) halt clear\n", qep->num );
+						panasonic_set_halt( &qep->ep, 0 );
+					}
+				}
+				spin_lock( &dev->lock );
+				usb_set_index( dev, 0 );
+				
+				/* Reply with a ZLP on next IN token */
+				usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+				return;
+			}
+			
+			if( ctrl.bRequestType == USB_RECIP_DEVICE ){
+				unsigned char wIndex_lbyte	= (ctrl.wIndex & 0x00FF);
+				unsigned char wIndex_hbyte	= ((ctrl.wIndex & 0xFF00) >> 8);
+				
+				/* Support Test Mode */
+				if( ctrl.wValue != 2 || ctrl.wLength != 0 || wIndex_lbyte != 0 ) {
+					break;
+				}
+				
+				switch( wIndex_hbyte ) {
+					case TEST_J_PATTERN:
+						printk("[USBG] TEST MODE - TEST_J\n");
+						usb_set( dev, TEST_J_BIT, USB_CSR );
+						usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+						return;
+						
+					case TEST_K_PATTERN:
+						printk("[USBG] TEST MODE - TEST_K\n");
+						usb_set( dev, TEST_K_BIT, USB_CSR );
+						usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+						return;
+						
+					case TEST_SE0_NAK_PATTERN:
+						printk("[USBG] TEST MODE - TEST_SE0_NAK\n");
+						usb_set( dev, TEST_SE0_NAK_BIT, USB_CSR );
+						usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END), EP0_CSR_REG );
+						return;
+						
+					case TEST_PACKET_PATTERN:
+						printk("[USBG] TEST MODE - TEST_PACKET\n");
+						usb_set( dev, TEST_PACKET_BIT, USB_CSR );
+						write_testpacket_ep0(dev);
+						usb_set( dev, (EP0_CLEAR_OPR | EP0_DATA_END | EP0_IN_PKT_RDY | EP0_ODD_IN_PKT), EP0_CSR_REG );
+						return;
+						
+					default:
+						break;
+				}
+			}
+			
+			break;
+		
+		default:
+			break;
+	}
+	
+	if( likely(dev->driver) ){
+		/* device-2-host (IN) or no data setup command, process immediately */
+		spin_unlock( &dev->lock );
+		i = dev->driver->setup( &dev->gadget, &ctrl );
+		spin_lock( &dev->lock );
+		if( i < 0 ){
+			/* setup processing failed, force stall */
+			ERROR_PRINT( "  --> ERROR: gadget setup FAILED (stalling), setup returned %d\n", i );
+			usb_set_index(dev, 0);
+			usb_set( dev, (EP0_CLEAR_OPR|EP0_DATA_END|EP0_SEND_STALL), EP0_CSR_REG );	/*_ setup¤Ç¼ºÇÔ¤·¤¿¾ì¹çStall¤Ë¤¹¤ë _*/
+			
+			dev->ep0state = WAIT_FOR_SETUP;
+		}
+	}
+}
+
+
+//DATA_STATE_NEED_ZLP
+static void panasonic_ep0_in_zlp(struct panasonic_udc *dev, u32 csr)
+{
+	DEBUG_EP0( "%s: %x\n", __FUNCTION__, csr );
+	
+	/* c.f. Table 15-14 */
+	usb_set( dev, (EP0_IN_PKT_RDY | EP0_DATA_END), EP0_CSR_REG );
+	dev->ep0state = WAIT_FOR_SETUP;
+}
+
+
+//handle ep0 interrupt
+void panasonic_udc_handle_ep0( struct panasonic_udc *dev, u32 intr )
+{
+	struct panasonic_ep *ep = &dev->ep[0];
+	u32 csr;
+	
+	usb_set_index( dev, 0 );
+	csr = usb_read( dev, EP0_CSR_REG );
+	
+	DEBUG_EP0( "%s: csr = %x\n", __FUNCTION__, csr );
+	
+	if( csr & EP0_DATA_END_CLR ){	/*_ DATA_END_CLR¤ò¾Ã¤¹ _*/
+		DEBUG_PRINT( "Clear DATA_END_CLR\n" );
+		usb_clear( dev, EP0_DATA_END_CLR, EP0_CSR_REG );
+	}
+	
+	if( csr & EP0_IPR_CLEAR ){	/*_ EP0_IPR_CLEAR¤ò¾Ã¤¹ _*/
+		DEBUG_PRINT( "Clear EP0_IPR_CLEAR\n" );
+		usb_clear( dev, EP0_IPR_CLEAR, EP0_CSR_REG );
+	}
+	
+	/*
+	 * For overview of what we should be doing see c.f. Chapter 18.1.2.4
+	 * We will follow that outline here modified by our own global state
+	 * indication which provides hints as to what we think should be
+	 * happening..
+	 */
+	
+	/*
+	 * if SENT_STALL is set
+	 *      - clear the SENT_STALL bit
+	 */
+	if( csr & EP0_SENT_STALL ){
+		DEBUG_EP0( "%s: EP0_SENT_STALL is set: %x\n", __FUNCTION__, csr );
+		usb_clear( dev, (EP0_SENT_STALL|EP0_SEND_STALL), EP0_CSR_REG );
+		panasonic_udc_nuke( ep, -ECONNABORTED );
+		dev->ep0state = WAIT_FOR_SETUP;
+		return;
+	}
+	
+	/*
+	 * if a transfer is in progress && IN_PKT_RDY and OUT_PKT_RDY are clear
+	 *      - fill EP0 FIFO
+	 *      - if last packet
+	 *      -       set IN_PKT_RDY | DATA_END
+	 *      - else
+	 *              set IN_PKT_RDY
+	 */
+	if( !(csr & (EP0_IN_PKT_RDY | EP0_OUT_PKT_RDY)) ){
+		DEBUG_EP0( "%s: IN_PKT_RDY and OUT_PKT_RDY are clear\n", __FUNCTION__ );
+		
+		switch( dev->ep0state ){
+			case DATA_STATE_XMIT:
+				DEBUG_EP0( "continue with DATA_STATE_XMIT\n" );
+				panasonic_ep0_in( dev, csr );
+				return;
+			case DATA_STATE_NEED_ZLP:
+				DEBUG_EP0( "continue with DATA_STATE_NEED_ZLP\n" );
+				panasonic_ep0_in_zlp( dev, csr );
+				return;
+			default:
+				if(csr & ~(EP0_DATA_END_CLR | EP0_IPR_CLEAR)) {
+					/* Stall? */
+					DEBUG_EP0( "Odd state!! state = %s\n", STATE_NAMES(dev->ep0state) );
+					dev->ep0state = WAIT_FOR_SETUP;
+					/* panasonic_udc_nuke(ep, 0); */
+				}
+				break;
+		}
+	}
+	
+	/*
+	 * if SETUP_END is set
+	 *      - abort the last transfer
+	 *      - set SERVICED_SETUP_END_BIT
+	 */
+	if( csr & EP0_SETUP_END ){
+		DEBUG_EP0( "%s: EP0_SETUP_END is set: %x\n", __FUNCTION__, csr );
+		usb_set( dev, EP0_CLR_SETUP_END, EP0_CSR_REG );
+		
+		panasonic_udc_nuke( ep, 0 );
+		dev->ep0state = WAIT_FOR_SETUP;
+	}
+	
+	/*
+	 * if EP0_OUT_PKT_RDY is set
+	 *      - read data packet from EP0 FIFO
+	 *      - decode command
+	 *      - if error
+	 *              set SERVICED_OUT_PKT_RDY | DATA_END bits | SEND_STALL
+	 *      - else
+	 *              set SERVICED_OUT_PKT_RDY | DATA_END bits
+	 */
+	if( csr & EP0_OUT_PKT_RDY ){
+		DEBUG_EP0( "%s: EP0_OUT_PKT_RDY is set: %x\n", __FUNCTION__, csr );
+		if( csr & ( EP0_SETUP_TOKEN | EP0_SEND_STALL ) ){
+			DEBUG_PRINT( "ep0_csr=0x%x. delete EP0_SEND_STALL\n", csr );	/*_ ¼¡¤Î¥»¥Ã¥È¥¢¥Ã¥×¥È¡¼¥¯¥ó¤¬»Ï¤Þ¤Ã¤¿¤Î¤Ç¡¢STALL¤ò½ª¤ï¤ë  _*/
+			usb_clear( dev, EP0_SEND_STALL, EP0_CSR_REG );
+		}
+		
+		switch( dev->ep0state ){
+			case WAIT_FOR_SETUP:
+				DEBUG_EP0( "WAIT_FOR_SETUP\n" );
+				panasonic_ep0_setup( dev, csr );
+				break;
+			
+			case DATA_STATE_RECV:
+				DEBUG_EP0( "DATA_STATE_RECV\n" );
+				panasonic_ep0_out( dev, csr );
+				break;
+			
+			default:
+				/* send stall? */
+				DEBUG_EP0( "strange state!! 2. send stall? state = %d\n", dev->ep0state );
+				break;
+		}
+	}
+}
+
+void panasonic_udc_ep0_kick( struct panasonic_udc *dev, struct panasonic_ep *ep )
+{
+	u32 csr;
+	
+	usb_set_index( dev, 0 );
+	csr = usb_read( dev, EP0_CSR_REG );
+	
+	DEBUG_EP0( "%s: %x\n", __FUNCTION__, csr );
+	
+	/* Clear "out packet ready" */
+	usb_set( dev, EP0_CLEAR_OPR, EP0_CSR_REG );
+	
+	if( ep->is_in ){
+		dev->ep0state = DATA_STATE_XMIT;
+		panasonic_ep0_in( dev, csr );
+	} else {
+		dev->ep0state = DATA_STATE_RECV;
+		panasonic_ep0_out( dev, csr );
+	}
+}
+
diff -uNr linux-3.14.19/drivers/usb/gadget/panasonic_udc_main.c linux-gerda/drivers/usb/gadget/panasonic_udc_main.c
--- linux-3.14.19/drivers/usb/gadget/panasonic_udc_main.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/panasonic_udc_main.c	2017-06-22 09:52:55.363039174 +0900
@@ -0,0 +1,2707 @@
+/*
+ * linux/drivers/usb/gadget/panasonic_udc_main.c
+ * PANASONIC on-chip high/full speed USB device controllers
+ *
+ * Copyright (C) 2014 Panasonic
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/device.h>
+#include <linux/errno.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/ioport.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/prefetch.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/timer.h>
+#include <linux/usb.h>
+#include <linux/usb/ch9.h>
+#include <linux/usb/gadget.h>
+
+#include <asm/byteorder.h>
+#include <asm/unaligned.h>
+
+#include "panasonic_udc.h"
+
+//conversion from ch-number to the IRQ-number
+#define SDMAC_CHTOIRQ(dev, ch)		((ch) == SDMAC_DIR(ch) ? dev->dma_out_irq : dev->dma_in_irq)
+#define SDMAC_DIR(ch)	((((ch) == USB_SDMAC_CH6_RCV) ||((ch) == USB_SDMAC_CH8_RCV) ) ? 1 : 0)
+#define SDMAC_RX_CH(id)	(((id) == 0 ) ? USB_SDMAC_CH6_RCV : USB_SDMAC_CH8_RCV)
+#define SDMAC_TX_CH(id)	(((id) == 0 ) ? USB_SDMAC_CH7_SND : USB_SDMAC_CH9_SND)
+
+#define DRIVER_DESC "Panasonic USB Peripheral Controller"
+
+static const char driver_name[] = "panasonic_udc";
+static const char driver_vers[] = "2014 October";
+static const char driver_desc[] = DRIVER_DESC;
+
+static const char dummy_name[] = "zero";
+
+const char ep0name[] = "ep0";
+static const char * const ep_name[] = {
+	ep0name,
+	"ep1", "ep2", "ep3", "ep4", "ep5", "ep6", "ep7", "ep8"
+};
+
+static const u32 ep_fifo[] = {
+	EP0_FIFO_REG,
+	EP1_FIFO_REG, EP2_FIFO_REG, EP3_FIFO_REG, EP4_FIFO_REG,
+	EP5_FIFO_REG, EP6_FIFO_REG, EP7_FIFO_REG, EP8_FIFO_REG
+};
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+/*
+ * use_dma: the Panasonic can use an  SDMA controller.
+ * Note that since there is no generic DMA api, some functions,
+ * notably request_dma, start_dma, and cancel_dma will need to be
+ * modified for your platform's particular dma controller.
+ *
+ * If use_dma is disabled, pio will be used instead.
+ */
+static bool use_dma = 1;
+module_param(use_dma, bool, 0644);
+
+/*
+ * dma_ep: selects the endpoint for use with dma
+ * The Panasonic can only use dma for one endpoints at a time.
+ * 0x02 = ep1
+ * 0x04 = ep2
+ * 0x08 = ep3
+ * 0x10 = ep4
+ * cf) ep1 and ep4 -> dma_ep = 0x12
+ *
+ */
+static ushort dma_ep = 0x10;
+module_param(dma_ep, ushort, 0644);
+
+#else
+#define use_dma 0
+#define dma_ep 1
+#endif
+
+/*
+ * fifo_mode: panasonic buffer configuration:
+ *      mode 0 == ep-{a,b,c,d} 1024(512*2)byte each
+ */
+static ushort fifo_mode = 0;
+module_param(fifo_mode, ushort, 0644);
+
+#define MAX_FIFO_MODE 0
+
+/*
+ * enable_suspend: When enabled, the driver will respond to
+ * USB suspend requests by powering down the Panasonic.  Otherwise,
+ * USB suspend requests will be ignored.  This is acceptible for
+ * self-powered devices.  For bus powered devices set this to 1.
+ */
+static ushort enable_suspend = 0;
+module_param(enable_suspend, ushort, 0644);
+
+#define PIPEDIR(bAddress) (usb_pipein(bAddress) ? "in" : "out")
+
+#define IS_SDMAC_STARTSTATE(dev, sdmaid) ((sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)) & BIT4 ) == BIT4 )
+
+static char *type_string(u8 bmAttributes)
+{
+	switch ((bmAttributes) & USB_ENDPOINT_XFERTYPE_MASK) {
+	case USB_ENDPOINT_XFER_BULK: return "bulk";
+	case USB_ENDPOINT_XFER_ISOC: return "iso";
+	case USB_ENDPOINT_XFER_INT:  return "intr";
+	default:                     return "control";
+	}
+}
+
+#if 0	/*_  2014/10/16 T.B.D registers_showÍÑ¡£°ìÃ¶ºï½ü _*/
+static char *buf_state_string(unsigned state)
+{
+	DEBUG_PRINT( "%s \n", __FUNCTION__ );
+
+	switch (state) {
+	case BUFF_FREE:  return "free";
+	case BUFF_VALID: return "valid";
+	case BUFF_LCL:   return "local";
+	case BUFF_USB:   return "usb";
+	default:         return "unknown";
+	}
+}
+#endif
+
+static void panasonic_dequeue_all(struct panasonic_ep *);
+static int panasonic_kick_dma(struct panasonic_ep *, struct panasonic_request *);
+static int panasonic_fifo_status(struct usb_ep *);
+static struct usb_ep_ops panasonic_ep_ops;
+
+
+/*---------------------------------------------------------------------------*/
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+static int
+panasonic_sdmac_init(struct panasonic_udc *dev, int sdmaid, u8 pri, eSDMAC_IRQTYPE fact)
+{
+	u8			ret = 0;
+	u32			tmp = 0;
+
+	DEBUG_PRINT( "%s: panasonic_udc = %p sdmaid = %d\n", __FUNCTION__, dev ,sdmaid);
+
+	/*_ ½é´ü²½Ãæ¤Ï³ä¹þ¤ß¶Ø»ß _*/
+	disable_irq(SDMAC_CHTOIRQ(dev, sdmaid));
+	
+	if(IS_SDMAC_STARTSTATE(dev, sdmaid) == 0){	/*_ Å¾Á÷Ää»ß¤Ê¤é¤Ð½èÍý¤¹¤ë _*/
+		/*_ ¥ì¡¼¥ÈÀ©¸æ _*/
+		sdmac_write(dev, 0, USB_SDMAC_PERFCNFG);				/*_ ¥ì¡¼¥ÈÀ©¸æ¥Ç¥£¥¹¥¤¥Í¡¼¥Ö¥ë _*/
+
+		/*_ ¥Á¥ã¥Í¥ëÀ©¸æ¥ì¥¸¥¹¥¿1 _*/
+		tmp = sdmac_read(dev, USB_SDMAC_CHnCTRL1(sdmaid));
+		tmp &= 0xFFFFFC7F;									/*_ º£¤«¤é½ñ¹þ¤à¥Ó¥Ã¥È¤À¤±0¥¯¥ê¥¢ _*/
+		tmp |= 0x00000080;									/*_ [9-7]:001 ¥é¥¤¥ÈDONE¤òÉ½¼¨ _*/
+		sdmac_write(dev, tmp, USB_SDMAC_CHnCTRL1(sdmaid));	/*_ ¥ì¥¸¥¹¥¿¤ËÈ¿±Ç _*/
+
+		/*_ ¥Á¥ã¥Í¥ëÀ©¸æ¥ì¥¸¥¹¥¿2 _*/
+		tmp = sdmac_read(dev, USB_SDMAC_CHnCTRL2(sdmaid));	/*_ ¸½ºßÃÍ¤òÆÉ½Ð¤· _*/
+		tmp &= 0x000F0000;									/*_ º£¤«¤é½ñ¹þ¤à¥Ó¥Ã¥È¤À¤±0¥¯¥ê¥¢ _*/
+		tmp |= ((pri & 0x07) | USB_SDMAC_PRI_LV4);			/*_ ¥Á¥ã¥Í¥ëÍ¥ÀèÅÙ _*/
+		sdmac_write(dev, tmp, USB_SDMAC_CHnCTRL2(sdmaid));	/*_ ¥ì¥¸¥¹¥¿¤ËÈ¿±Ç _*/
+		
+		/*_ ¥Á¥ã¥Í¥ë³ä¹þ¤ßÍ×µá¥ì¥¸¥¹¥¿ _*/
+		sdmac_write(dev, 0xFFFFFFFF, USB_SDMAC_CHnIR(sdmaid));	/*_ ³ä¹þ¤ß¥¯¥ê¥¢ _*/
+		
+		/*_ ¥Á¥ã¥Í¥ë³ä¹þ¤ß¥¤¥Í¡¼¥Ö¥ë¥ì¥¸¥¹¥¿ _*/
+		sdmac_write(dev, fact & USB_SDMAC_IRQ_ALLON, USB_SDMAC_CHnIE(sdmaid));	/*_ ³ä¹þ¤ßµö²Ä¤¹¤ëÍ×°ø¤ò¥»¥Ã¥È _*/
+	}
+	else{													/*_ Å¾Á÷Ää»ß¾õÂÖ°Ê³° _*/
+		ERROR_PRINT( "\nSDMAC could not be initialized. SDMAC is Running(%x)!\n", sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)));
+		ret = 1;
+	}
+
+	enable_irq(SDMAC_CHTOIRQ(dev, sdmaid));
+
+	return ret;
+}
+
+/* returns 0 on success, else returns 1 if it fail */
+static int
+panasonic_sdmac_start(struct panasonic_udc *dev, struct sdma_setup *setup)
+{
+	u8		ret = 0;				/*_ Ìá¤êÃÍ _*/
+	u32		bakup = 0;				/*_ ¥ì¥¸¥¹¥¿ÊÝ´ÉÍÑ _*/
+	u32		tmp = 0;				/*_ ¥ì¥¸¥¹¥¿ÊÔ½¸ÍÑ _*/
+	int		sdmaid = setup->sdmaid;
+
+	DMA_PRINT( "%s: panasonic_udc = %p sdmaid = %d\n", __FUNCTION__, dev , sdmaid);
+
+	if(IS_SDMAC_STARTSTATE(dev, sdmaid) == 0){	/*_ Å¾Á÷Ää»ß¤Ê¤é¤Ð½èÍý¤¹¤ë _*/
+		/*_ ³ä¹þ¤ß¤ò°ìÃ¶¶Ø»ß¤¹¤ë _*/
+		bakup = sdmac_read(dev, USB_SDMAC_CHnIE(sdmaid));			/*_ ¸½ºßÃÍ¤ò°ì»þÊÝ´É _*/
+		sdmac_write(dev, USB_SDMAC_IRQ_ALLOFF, USB_SDMAC_CHnIE(sdmaid));				/*_ Á´³ä¹þ¤ß¥Ç¥£¥»¡¼¥Ö¥ë _*/
+		
+		/*_ Å¾Á÷¸µ¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É¤ò»ØÄê _*/
+		tmp = sdmac_read(dev, USB_SDMAC_CHnSRCAMODE(sdmaid));		/*_ ¸½ºßÃÍÆÉ½Ð¤· _*/
+		tmp &= 0xFFFFFFCB;											/*_ º£¤«¤é½ñ¹þ¤à¥Ó¥Ã¥È¤À¤±0¥¯¥ê¥¢ _*/
+		tmp |= (u32)setup->eSrc_amode;								/*_ ¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É _*/
+		tmp |= (u32)setup->eSrc_trtype;								/*_ Å¾Á÷¸µ¤Î·¿ÁªÂò _*/
+		sdmac_write(dev, tmp, USB_SDMAC_CHnSRCAMODE(sdmaid));		/*_ ¥ì¥¸¥¹¥¿¤ËÈ¿±Ç _*/
+		
+		/*_ Å¾Á÷Àè¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É¤ò»ØÄê _*/
+		tmp = sdmac_read(dev, USB_SDMAC_CHnDSTAMODE(sdmaid));		/*_ ¸½ºßÃÍÆÉ½Ð¤· _*/
+		tmp &= 0xFFFFFFCB;											/*_ º£¤«¤é½ñ¹þ¤à¥Ó¥Ã¥È¤À¤±0¥¯¥ê¥¢ _*/
+		tmp |= (u32)setup->eDis_amode;								/*_ ¥¢¥É¥ì¥Ã¥·¥ó¥°¥â¡¼¥É _*/
+		tmp |= (u32)setup->eDis_trtype;								/*_ Å¾Á÷Àè¤Î·¿ÁªÂò _*/
+		sdmac_write(dev, tmp, USB_SDMAC_CHnDSTAMODE(sdmaid));		/*_ ¥ì¥¸¥¹¥¿¤ËÈ¿±Ç _*/
+		
+		/*_ Å¾Á÷Àè¥¢¥É¥ì¥¹¤ò»ØÄê _*/
+		sdmac_write(dev, (u32)setup->pulDis, USB_SDMAC_CHnDSTSTRTADRS(sdmaid));	/*_ ¥Ç¥£¥¹¥Æ¥£¥Í¡¼¥·¥ç¥ó¥¢¥É¥ì¥¹ _*/
+		
+		/*_ ³ä¹þ¤ßÍ×µá¥¯¥ê¥¢ _*/
+		sdmac_write(dev, 0xFFFFFFFF, USB_SDMAC_CHnIR(sdmaid));				/*_ Í×µá¥Õ¥é¥°¥¯¥ê¥¢ _*/
+		
+		/*_ (°ìÃ¶¶Ø»ß¤·¤Æ¤¤¤¿)³ä¹þ¤ß¤òµö²Ä _*/
+		sdmac_write(dev, bakup, USB_SDMAC_CHnIE(sdmaid));			/*_ µö²Ä¥Õ¥é¥°¤ò¸µ¤ËÌá¤¹ _*/
+		
+		/*_ Å¾Á÷¥µ¥¤¥º¤ò»ØÄê _*/
+		sdmac_write(dev, (u32)setup->ulSize, USB_SDMAC_CHnSIZE(sdmaid));		/*_ Å¾Á÷¸ì¿ô _*/
+		
+		/*_ Å¾Á÷¸µ¥¢¥É¥ì¥¹¤ò»ØÄê _*/
+		sdmac_write(dev, (u32)setup->pulSrc, USB_SDMAC_CHnSRCSTRTADRS(sdmaid));	/*_ ¥½¡¼¥¹¥¢¥É¥ì¥¹ _*/
+		
+		/*_ µ¯Æ°Í×µá¤òÈ¯¹Ô _*/
+		tmp = 0x00000000;
+		tmp |= 0x00000000;								/*_ [31]=0:µ¯Æ°Í×µá _*/
+		tmp |= (u32)(0x1 << sdmaid);					/*_ Í×µá¤ò½Ð¤¹¥Á¥ã¥Í¥ë¤ËÂÐ±þ¤¹¤ë¥Ó¥Ã¥È¤ò¥»¥Ã¥È _*/
+		sdmac_write(dev, tmp, USB_SDMAC_STRT);			/*_ ¥ì¥¸¥¹¥¿¤ËÈ¿±Ç _*/
+	}
+	else{												/*_ Å¾Á÷Ää»ß¾õÂÖ°Ê³° _*/
+		/*_ »öÁ°¤ËÄä»ß¾õÂÖ¤Ç¤¢¤ë¤³¤È¤ò³ÎÇ§ºÑ¤ß¡£¤³¤³¤ËÍè¤ë¤³¤È¤Ï¤¢¤ê¤¨¤Ê¤¤ _*/
+		ERROR_PRINT( "\nSDMAC could not start request. SDMAC ch%d is Running(%x)! dma_state = %x\n", 
+				sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)), sdmaid, SDMAC_DIR(sdmaid) ? dev->dma_out_state : dev->dma_in_state );
+		ret = 1;
+	}
+
+#if 0	/* debug */
+	DMA_PRINT("SDMAC_CHnSTAT         :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnSTAT(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)));
+	DMA_PRINT("SDMAC_CHnIE           :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnIE(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnIE(sdmaid)));
+	DMA_PRINT("SDMAC_CHnSRCAMODE     :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnSRCAMODE(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnSRCAMODE(sdmaid)));
+	DMA_PRINT("SDMAC_CHnDSTAMODE     :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnDSTAMODE(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnDSTAMODE(sdmaid)));
+	DMA_PRINT("SDMAC_CHnDSTSTRTADRS  :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnDSTSTRTADRS(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnDSTSTRTADRS(sdmaid)));
+	DMA_PRINT("SDMAC_CHnID           :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnID(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnID(sdmaid)));
+	DMA_PRINT("SDMAC_CHnSIZE         :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnSIZE(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnSIZE(sdmaid)));
+	DMA_PRINT("SDMAC_CHnSRCSTRTADRS  :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_CHnSRCSTRTADRS(sdmaid)), sdmac_read(dev, USB_SDMAC_CHnSRCSTRTADRS(sdmaid)));
+	DMA_PRINT("SDMAC_STRT            :[%08x] %08x\n", (u32)USB_SDMAC_REG(dev, USB_SDMAC_STRT), sdmac_read(dev, USB_SDMAC_STRT));
+#endif
+
+	return ret;
+
+}
+
+/* returns 0 on success, else returns 1 if it fail */
+static int
+panasonic_sdmac_cancel(struct panasonic_udc *dev, int sdmaid)
+{
+	int ret;
+
+	DMA_PRINT( "%s: panasonic_udc = %p sdmaid = %d\n", __FUNCTION__, dev , sdmaid);
+
+	if(IS_SDMAC_STARTSTATE(dev, sdmaid) == 0){											/*_ Å¾Á÷Ää»ß¤Ê¤é¤ÐÃæ»ßÉÔÍ× _*/
+		ret = 1;
+	}else{
+		sdmac_write(dev, 0x80000000 | (1 << sdmaid), USB_SDMAC_STRT);					/*_ [31]=1:Ãæ»ßÍ×µá _*/
+		ret = 0;
+	}
+	
+	return ret;
+}
+
+/* returns 0 on success, else negative errno */
+static int
+panasonic_request_write_dma(struct panasonic_ep *ep, u32 buf, unsigned len, unsigned zero)
+{
+	u32 csr;
+	struct sdma_setup setup;
+	struct panasonic_udc *dev = ep->dev;
+	unsigned int sdmaid;
+	int ret;
+	u32 tmp;
+
+	DMA_PRINT("%s ep %d buf %08x len %d\n",
+		__FUNCTION__, ep->num, buf, len);
+
+	if(dev->dma_in_state != UDC_DMA_STATE_IDLE){
+		return -EBUSY;							/*_ USBIPDMA&SDMA¤¬µ¯Æ°Ãæ _*/
+	}
+
+	sdmaid = dev->dma_in_ch;
+
+	if(unlikely((IS_SDMAC_STARTSTATE(dev, sdmaid)) != 0)){
+		ERROR_PRINT( "\n SDMAC ch%d is abnormal state(%x)! dma_state = %x\n", 
+				sdmaid, sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)) ,dev->dma_in_state );
+		return -EBUSY;							/*_ sdma¤¬Å¾Á÷µ¯Æ°¾õÂÖÃæ _*/
+	}
+	
+	usb_set_index(dev, ep->num);
+	csr = usb_read(dev, ep->csr);
+	
+#if 0	/*_  2014/10/28 T.B.D FIFO¤¬°ìÇÕ¤Î¤È¤­¤ËDMAµ¯Æ°¤·¤¿¤éÌäÂê¤È¤Ê¤ë¡© °ìÃ¶ÊÝÎ± _*/
+		/*_ IN¤ÎPIO¥â¡¼¥É¤Ç¤ÏÁ÷¿®¤¹¤ëÁ°¤ËdoneµÚ¤Óqueueºï½ü¤ò¹Ô¤¦¤¿¤á¡¢DMAµ¯Æ°»þ¤ËFIFO¤¬°ìÇÕ¤Î¤³¤È¤Ï¤¢¤ê¤¦¤ë _*/
+		/*_ FIFO°ìÇÕ¤Î¤Þ¤ÞDMA¤òµ¯Æ°¤·¡¢³ä¤ê¹þ¤ßµö²Ä¤¹¤ë¤È¡¢PIOÍÑ¤Î¥Ç¡¼¥¿¤¬DMA¤ËÎ®¤ì¤³¤à¤«¤â¡© _*/
+		/*_ DMA¤òµ¯Æ°¤·¤Ê¤¤¤Ç¥­¥å¡¼¥¤¥ó¥°¤¹¤ë¤È¡¢IPR³ä¤ê¹þ¤ß¤Çqueue¤¬½¦¤ï¤ì¤ÆPIOÅ¾Á÷¤µ¤ì¤Æ¤·¤Þ¤¦ _*/
+		/*_ DMA¤Î¸å¤ÏÁ÷¿®´°Î»¤Ç³ä¤ê¹þ¤ß¤·¤Æ¤¤¤ë¤Î¤Ç¡¢DMA->DMA¤ÏÌäÂê¤Ê¤¤ _*/
+	if( (csr & USB_IN_PKT_RDY) ){	/*_ MCU_IN_PKT_RDY¤Ç¤âÎÉ¤¤¤Î¤«¡©Í×·ïÅù¡£_*/
+		printk( "USB_IN_PKT_RDY:csr=%x\n", csr );
+		DEBUG( "Hmm.. %d ep FIFO is not empty!\n", ep_index(ep) );
+		return 0;	/*_ FIFO¤Ë¤Þ¤À°ÊÁ°¤Î¥Ç¡¼¥¿¤¬»Ä¤Ã¤Æ¤¤¤ë¡£ _*/
+	}
+#endif
+
+	/*_ 2.  DMAFIFOnControl ¥ì¥¸¥¹¥¿ÀßÄê  _*/
+	tmp = ep->num|BIT4|BIT5;								/*_ EPÈÖ¹æ¡¢Init¡¢16bit¤òÀßÄê _*/
+	if(zero){
+		tmp |= BIT15;										/*_ AddNullPacket¤òÀßÄê _*/
+	}
+	usb_write( dev, tmp, DMA_FIFO1_CNT );
+
+#if 0	/*_ GerdaC 2015/1/14 IPR¤ò¹¹¿·¤·¤Ê¤¤¤è¤¦¤Ë0¤ò½ñ¤­¹þ¤à _*/
+	usb_clear( dev, IPR_CLEAR, ep->csr );					/*_ Å¾Á÷´°Î»¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+#else
+	usb_clear( dev, IPR_CLEAR|MCU_IN_PKT_RDY, ep->csr );	/*_ Å¾Á÷´°Î»¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+#endif
+
+	/*_ 3.  Endpoint configuraiton2 ¥ì¥¸¥¹¥¿ÀßÄê _*/
+	//BIT0 Enable DMA
+	//BIT5 DATA_END_INT_SEL		/*_ DATA_END_IN¤òÆþÎÏ¤·¤¿¥Ñ¥±¥Ã¥È»þ¤Ë³ä¹þ¤ß¤òÈ¯À¸¤µ¤»¤ë¤« _*/
+	usb_write( dev, BIT0|BIT5, EP_CONFIG2_REG );			/*_ DMA³«»Ï ½ªÎ»»þ¤Ë³ä¤ê¹þ¤ß¤òÈ¯À¸¤µ¤»¤ë¡£IN_CSR¤ËIPR_CLEAR¤¬Î©¤Ã¤Æ¡¢³ä¤ê¹þ¤ß¤¬È¯À¸¤¹¤ë¡£ _*/
+	DMA_PRINT( "begin dma in dma=0x%08x, len=%d CSR=%x IPR=%d\n", buf, len , csr, csr & USB_IN_PKT_RDY);
+
+	/*_ 4.  SDMAC¤òµ¯Æ° _*/
+	setup.sdmaid = sdmaid;
+	setup.pulSrc = buf;												/*_ Å¾Á÷¸µ¥¢¥É¥ì¥¹=Ç¤°Õ¥¢¥É¥ì¥¹ _*/
+	setup.eSrc_amode = USB_SDMAC_ADR_INC;							/*_ Å¾Á÷¸µ¥¢¥É¥ì¥Ã¥·¥ó¥°=¥¤¥ó¥¯¥ê¥á¥ó¥È _*/
+	setup.eSrc_trtype = USB_SDMAC_TRTYPE_NORMAL;					/*_ Å¾Á÷¸µ¤Î·¿ÁªÂò=ÄÌ¾ï¥á¥â¥ê _*/
+	setup.pulDis = USB_SDMAC_ADR_USBDEVICE;							/*_ Å¾Á÷Àè¥¢¥É¥ì¥¹=USB DEVICE IF _*/
+	setup.eDis_amode = USB_SDMAC_ADR_FIX;							/*_ Å¾Á÷Àè¥¢¥É¥ì¥Ã¥·¥ó¥°=¸ÇÄê _*/
+	setup.eDis_trtype = USB_SDMAC_TRTYPE_NORMAL;					/*_ Å¾Á÷Àè¤Î·¿ÁªÂò=ÄÌ¾ï¥á¥â¥ê _*/
+	setup.ulSize = len;												/*_ Å¾Á÷¥µ¥¤¥º _*/
+
+	ret = panasonic_sdmac_start(dev, &setup);
+	if(ret != 0){
+		usb_write(dev, 0, EP_CONFIG2_REG );						/*_ DMA½ªÎ» _*/
+		usb_write(dev, 0 , DMA_FIFO1_CNT );						/*_ DMA½ªÎ» _*/
+		ERROR_PRINT( "sdma busy -> pio mode \n" );
+		return -EBUSY;
+	}
+
+	dev->dma_in_state = UDC_DMA_STATE_IP_SDMA | ep->num;
+
+	return 0;
+}
+
+/* returns 0 on success, else negative errno */
+static int
+panasonic_request_read_dma(struct panasonic_ep *ep, u32 buf, unsigned len)
+{
+	u32 csr;
+	struct sdma_setup setup;
+	struct panasonic_udc *dev = ep->dev;
+	unsigned int sdmaid;
+	int ret;
+
+	DMA_PRINT("%s ep %d buf %08x len %d\n",
+		__FUNCTION__, ep->num, buf, len);
+
+	if(dev->dma_out_state != UDC_DMA_STATE_IDLE){
+		if((dev->dma_out_state & ep->num) != ep->num										/*_ Â¾EP¤¬DMAÃæ¡© _*/
+			|| (dev->dma_out_state & UDC_DMA_STATE_IP_SDMA) == UDC_DMA_STATE_IP_SDMA){		/*_ USBIPDMA&SDMA¤¬µ¯Æ°Ãæ¡© _*/
+			return -EBUSY;
+		}
+	}
+
+	sdmaid = dev->dma_out_ch;
+
+	if(unlikely((IS_SDMAC_STARTSTATE(dev, sdmaid)) != 0)){
+		ERROR_PRINT( "\n SDMAC ch%d is abnormal state(%x)! dma_state = %x\n", 
+				sdmaid, sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)) ,dev->dma_out_state );
+		return -EBUSY;							/*_ sdma¤¬Å¾Á÷µ¯Æ°¾õÂÖÃæ _*/
+	}
+
+	usb_set_index(dev, ep->num);
+	csr = usb_read(dev, ep->csr);
+
+#if 0	/*_ GerdaC 2014/12/26 ¤³¤³¤Çusb_clear¤·¤Æ¤·¤Þ¤¦¤È¡¢OPR¤ò¾Ãµî¤·¤Æ¤·¤Þ¤¦¤³¤È¤¬¤¢¤ë _*/
+	usb_clear( dev, SHORT_PACKET, ep->csr );		/*_ SHORT_PACKET¥Ó¥Ã¥È¤òÍî¤È¤¹¡£Å¾Á÷´°Î»¤òSHORT_PACKET¤ÇÈ½ÃÇ¤¹¤ë¡£ _*/
+#else
+	csr &= ~SHORT_PACKET;
+	usb_write(dev, (csr | MCU_OUT_PKT_RDY), ep->csr);
+#endif
+
+	usb_set(dev, DMA_BURST_MODE, DMA_IF_CTR);	//burst mode on
+
+	if(dev->dma_out_state == UDC_DMA_STATE_IDLE) {
+		dev_vdbg(dev->dev, "starting dma ep=%d\n", ep->num);
+		/*_ 2.  DMAFIFOnControl ¥ì¥¸¥¹¥¿ÀßÄê _*/
+		usb_write( dev, ep->num|BIT4|BIT5 , DMA_FIFO0_CNT );	/*_ ep, init, 16bit¤À¤±¥»¥Ã¥È¤¹¤ë _*/
+
+		/*_ 3.  Endpoint configuraiton2 ¥ì¥¸¥¹¥¿ÀßÄê _*/
+		/*_ BIT0 Enable DMA _*/
+		/*_ BIT1 ¥·¥ç¡¼¥È¥Ñ¥±¥Ã¥ÈÅ¾Á÷¸å¤ËDMAÅ¾Á÷¤ò»ß¤á¤ë _*/
+		/*_ BIT3 ¢¨BIT4¤Ï0 DATA_END_OUT¤ò½Ð¤¹¾ò·ï¡£¥·¥ç¡¼¥È¥Ñ¥±¥Ã¥È¤Î¸å¤Î¤ß¡£ _*/
+		/*_ BIT4 ¢¨BIT3¤Ï0 DATA_END_OUT¤ò½Ð¤¹¾ò·ï¡£¥Ñ¥±¥Ã¥ÈËè¡£ _*/
+		usb_write( dev, BIT0|BIT1|BIT4, EP_CONFIG2_REG );
+	}
+
+	/*_ 4.  SDMAC¤òµ¯Æ° _*/
+	setup.sdmaid = sdmaid;
+	setup.pulSrc = USB_SDMAC_ADR_USBDEVICE;							/*_ Å¾Á÷¸µ¥¢¥É¥ì¥¹=USB DEVICE IF _*/
+	setup.eSrc_amode = USB_SDMAC_ADR_FIX;							/*_ Å¾Á÷¸µ¥¢¥É¥ì¥Ã¥·¥ó¥°=¸ÇÄê _*/
+	setup.eSrc_trtype = USB_SDMAC_TRTYPE_NORMAL;					/*_ Å¾Á÷¸µ¤Î·¿ÁªÂò=ÄÌ¾ï¥á¥â¥ê _*/
+	setup.pulDis = buf;												/*_ Å¾Á÷Àè¥¢¥É¥ì¥¹=Ç¤°Õ¥¢¥É¥ì¥¹ _*/
+	setup.eDis_amode = USB_SDMAC_ADR_INC;							/*_ Å¾Á÷Àè¥¢¥É¥ì¥Ã¥·¥ó¥°=¥¤¥ó¥¯¥ê¥á¥ó¥È _*/
+	setup.eDis_trtype = USB_SDMAC_TRTYPE_NORMAL;					/*_ Å¾Á÷Àè¤Î·¿ÁªÂò=ÄÌ¾ï¥á¥â¥ê _*/
+	setup.ulSize = len;												/*_ Å¾Á÷¥µ¥¤¥º _*/
+
+	ret = panasonic_sdmac_start(dev, &setup);
+	if(ret != 0){
+		usb_write(dev, 0, EP_CONFIG2_REG );					/*_ DMA½ªÎ» _*/
+		usb_write(dev, 0 , DMA_FIFO0_CNT );					/*_ DMA½ªÎ» _*/
+
+		ERROR_PRINT( "sdma busy -> pio mode \n" );
+		return -EBUSY;
+	}
+	DMA_PRINT( "begin dma&sdma out\n" );
+
+	dev->dma_out_state = UDC_DMA_STATE_IP_SDMA | ep->num;
+
+	return 0;
+}
+
+
+#endif	/* CONFIG_USB_PANASONIC_ENABLE_DMA */
+
+/*---------------------------------------------------------------------------*/
+
+static int
+panasonic_enable(struct usb_ep *_ep, const struct usb_endpoint_descriptor *desc)
+{
+	struct panasonic_udc *dev;
+	struct panasonic_ep *ep;
+	u32 max;
+	u16 tmp;
+	unsigned long flags;
+
+	DEBUG_PRINT("%s: %s\n", __FUNCTION__, _ep->name);
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || !desc || ep->desc || _ep->name == ep0name
+			|| desc->bDescriptorType != USB_DT_ENDPOINT)
+		return -EINVAL;
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	max = usb_endpoint_maxp(desc) & 0x1fff;
+
+	spin_lock_irqsave(&dev->lock, flags);
+	
+	usb_set_index(dev, ep->num);
+
+	_ep->maxpacket = max & 0x7fff;
+	ep->desc = desc;
+	ep->is_in = usb_endpoint_dir_in(desc);
+
+	/* panasonic_ep_reset() has already been called */
+	ep->stopped = 0;
+	ep->wedged = 0;
+
+	if (usb_endpoint_xfer_bulk(desc)) {
+		/* catch some particularly blatant driver bugs */
+		if ((dev->gadget.speed == USB_SPEED_HIGH && max != 512) ||
+		    (dev->gadget.speed == USB_SPEED_FULL && max > 64)) {
+			spin_unlock_irqrestore(&dev->lock, flags);
+			return -ERANGE;
+		}
+	}
+
+	tmp = 0;
+	/* set direction, type, max packet */
+	tmp = !ep->is_in;
+	ep->is_iso = usb_endpoint_xfer_isoc(desc) ? 1 : 0;
+	if(ep->is_iso == 1){
+		tmp |= BIT2;	/*_ ISOÅ¾Á÷(ÄÌ¾ï)¥â¡¼¥É _*/
+	}
+	tmp |= ((max/8) << 4);
+
+	usb_write(dev, tmp, EP_CONFIG_REG);
+
+	if(ep->is_in == 1){
+		ep->csr = IN_CSR_REG;
+		usb_set(dev, IN_FIFO_FLUSH, ep->csr );
+		usb_set(dev, IN_FIFO_FLUSH, ep->csr );
+	}else{
+		ep->csr = OUT_CSR_REG;
+		usb_set(dev, OUT_FIFO_FLUSH, ep->csr );
+		usb_set(dev, OUT_FIFO_FLUSH, ep->csr );
+	}
+
+	dev_dbg(dev->dev, "enabled %s (ep%d%s-%s) max %04x cfg %04x\n",
+		_ep->name, desc->bEndpointAddress & 0x0f, PIPEDIR(desc->bEndpointAddress),
+		type_string(desc->bmAttributes), max,
+		usb_read(dev, EP_CONFIG_REG));
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	DEBUG_PRINT( "%s: enabled %s\n", __FUNCTION__, _ep->name );
+
+	return 0;
+}
+
+static void panasonic_ep_reset(struct panasonic_ep *ep)
+{
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	ep->desc = NULL;
+	INIT_LIST_HEAD(&ep->queue);
+
+	usb_ep_set_maxpacket_limit(&ep->ep, ~0);
+	ep->ep.ops = &panasonic_ep_ops;
+	
+	if(ep->num != 0){
+		/* disable irqs, endpoint */
+		pio_irq_disable(ep->dev, ep->num);
+
+		usb_set_index(ep->dev, ep->num);
+
+		usb_write(ep->dev, 0, EP_CONFIG2_REG );
+	}
+
+}
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+static void
+panasonic_dma_stop(struct panasonic_ep *ep)
+{
+	struct panasonic_udc *dev = ep->dev;
+
+	switch(get_dma_state_ep(ep))
+	{
+		case UDC_DMA_STATE_IP_ONLY:
+			dev_vdbg(dev->dev, "%s[%d]:stop dma ep=%d, dma_state = %x\n", __FUNCTION__, __LINE__,ep->num, dev->dma_out_state);
+
+			usb_set_index(dev, ep->num);
+			usb_write(dev, 0, EP_CONFIG2_REG );				/*_ DMA½ªÎ» _*/
+
+			if(ep->is_in){
+				usb_write(dev, 0 , DMA_FIFO1_CNT );			/*_ DMA½ªÎ» _*/
+				dev->dma_in_state = UDC_DMA_STATE_IDLE;
+			}else{
+				usb_write(dev, 0 , DMA_FIFO0_CNT );			/*_ DMA½ªÎ» _*/
+				dev->dma_out_state = UDC_DMA_STATE_IDLE;
+			}
+			break;
+
+		case UDC_DMA_STATE_IP_SDMA:
+			{
+				int sdmaid;
+				int ret;
+
+				if(ep->is_in){
+					sdmaid = dev->dma_in_ch;
+				}else{
+					sdmaid = dev->dma_out_ch;
+				}
+				ret = panasonic_sdmac_cancel(dev, sdmaid);
+				if(ret != 0){
+					ERROR_PRINT( "%s:Odd State!! dam_state = %x, CHnSTAT = %x\n",__FUNCTION__
+						, ep->is_in ? dev->dma_in_state : dev->dma_out_state, sdmac_read(dev, USB_SDMAC_CHnSTAT(sdmaid)) );
+				}
+			}
+			break;
+
+		case UDC_DMA_STATE_IDLE:
+		default:
+			break;
+	}
+}
+#endif
+
+static int panasonic_disable(struct usb_ep *_ep)
+{
+	struct panasonic_ep *ep;
+	unsigned long flags;
+
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || !ep->desc || _ep->name == ep0name)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	panasonic_dequeue_all(ep);
+	panasonic_ep_reset(ep);
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	panasonic_dma_stop(ep);
+#endif
+	dev_vdbg(ep->dev->dev, "disabled %s\n", _ep->name);
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static struct usb_request *
+panasonic_alloc_request(struct usb_ep *_ep, gfp_t gfp_flags)
+{
+	struct panasonic_ep *ep;
+	struct panasonic_request *req;
+
+	DEBUG_PRINT( "%s: %s %s\n", __FUNCTION__, _ep->name, (_ep) ? "":"EP is wrong !!");
+
+	if (!_ep)
+		return NULL;
+	ep = container_of(_ep, struct panasonic_ep, ep);
+
+	req = kzalloc(sizeof(*req), gfp_flags);
+	if (!req)
+		return NULL;
+
+	INIT_LIST_HEAD(&req->queue);
+
+	return &req->req;
+}
+
+static void
+panasonic_free_request(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct panasonic_ep *ep;
+	struct panasonic_request *req;
+
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || !_req)
+		return;
+
+	req = container_of(_req, struct panasonic_request, req);
+	WARN_ON(!list_empty(&req->queue));
+	kfree(req);
+}
+
+void
+panasonic_done(struct panasonic_ep *ep, struct panasonic_request *req, int status)
+{
+	struct panasonic_udc *dev;
+	unsigned stopped = ep->stopped;
+	u32 index;
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+#if 0	/*_  2014/10/9 T.B.D panasonic_udc_ep0.c ¤Ç½èÍý¤ò¹Ô¤¦¤¿¤áÉÔÍ×¡£³ÎÇ§¸åºï½ü _*/
+	if (ep->num == 0) {
+		if (ep->dev->protocol_stall) {
+			ep->stopped = 1;
+			set_halt(ep);
+		}
+		allow_status(ep);
+	}
+#endif
+
+	list_del_init(&req->queue);
+
+	if (req->req.status == -EINPROGRESS)
+		req->req.status = status;
+	else
+		status = req->req.status;
+
+	dev = ep->dev;
+	if (use_dma && ep->dma)
+		usb_gadget_unmap_request(&dev->gadget, &req->req,
+				ep->is_in);
+
+	if (status && status != -ESHUTDOWN)
+		dev_vdbg(dev->dev, "complete %s req %p stat %d len %u/%u buf %p\n",
+			ep->ep.name, &req->req, status,
+			req->req.actual, req->req.length, req->req.buf);
+
+	/* don't modify queue heads during completion callback */
+	ep->stopped = 1;
+	/* Read current index (completion may modify it) */
+	index = usb_read(dev, INDEX_REG );
+
+	spin_unlock(&dev->lock);	/*_  2014/10/9 T.B.D BP3¤Ç¤Ïunlock¤¹¤ë¤Èdma_irq¤Î¤È¤­¤Ë¤ª¤«¤·¤¤Æ°ºî¤Ë¤Ê¤Ã¤¿¤È¤Î¤³¤È¡£Í×Ä´À° _*/
+	req->req.complete(&ep->ep, &req->req);
+	spin_lock(&dev->lock);		/*_  2014/10/9 T.B.D BP3¤Ç¤Ïunlock¤¹¤ë¤Èdma_irq¤Î¤È¤­¤Ë¤ª¤«¤·¤¤Æ°ºî¤Ë¤Ê¤Ã¤¿¤È¤Î¤³¤È¡£Í×Ä´À° _*/
+	/* Restore index */
+	usb_set_index(dev, index );
+	ep->stopped = stopped;
+}
+
+/* returns: 0: still running, 1: completed */
+static int
+panasonic_write_fifo(struct panasonic_ep *ep, struct panasonic_request *req)
+{
+	unsigned count, max;
+	int status;
+	int is_last, is_short, isODD;
+
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	dev_vdbg(ep->dev->dev, "write_fifo %s actual %d len %d\n",
+		ep->ep.name, req->req.actual, req->req.length);
+
+	max = ep->ep.maxpacket;
+
+	/*
+	 * Keep loading the endpoint until the final packet is loaded,
+	 * or the endpoint buffer is full.
+	 */
+ top:
+
+	usb_set_index(ep->dev, ep->num);
+
+	while ((usb_read(ep->dev, ep->csr) & MCU_IN_PKT_RDY) != MCU_IN_PKT_RDY) {
+		count = panasonic_write_packet(ep, req, max);
+		isODD = count%2;
+		usb_set(ep->dev, MCU_IN_PKT_RDY | ((isODD)?ODD_IN_PKT:0), ep->csr );
+
+		/* last packet is usually short (or a zlp) */
+		if( unlikely(count != max) ){
+			is_last = is_short = 1;
+		}else{
+			if( likely(req->req.length != req->req.actual) || req->req.zero )
+				is_last = 0;
+			else
+				is_last = 1;
+			/* interrupt/iso maxpacket may not fill the fifo */
+			is_short = unlikely( max < ep->ep.maxpacket );
+		}
+
+		DEBUG_PRINT("%s: wrote %s %d bytes%s%s %d left %p\n", __FUNCTION__,
+			ep->ep.name, count, is_last ? "/L" : "", is_short ? "/S" : "",
+			req->req.length - req->req.actual, req);
+
+		/* requests complete when all IN data is in the FIFO */
+		if( is_last ){
+			panasonic_done(ep, req, 0);
+			if (!list_empty(&ep->queue)) {
+				req = list_entry(ep->queue.next,
+						struct panasonic_request,
+						queue);
+				DEBUG_PRINT( "%s(%d):\n", __FUNCTION__, __LINE__);
+				status = panasonic_kick_dma(ep, req);
+
+				if (status < 0){
+					if ((usb_read(ep->dev, ep->csr)
+							& MCU_IN_PKT_RDY) != MCU_IN_PKT_RDY)
+						goto top;
+				}
+			}else{
+				/*_ done¸å¤ÎIPR³ä¤ê¹þ¤ß¤ò¼õ¿®¤·¤Ê¤¤¤è¤¦¤Ë³ä¤ê¹þ¤ß¶Ø»ß _*/
+				pio_irq_disable(ep->dev, ep->num);
+			}
+			return 1;
+		}
+	}
+	return 0;
+}
+
+static int
+panasonic_read_packet(struct panasonic_ep *ep, u8 *buf,
+	struct panasonic_request *req)
+{
+	unsigned bufferspace, count, is_short;
+	unsigned i;
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	bufferspace = req->req.length - req->req.actual;
+
+	/* read all bytes from this packet */
+	count = usb_read(ep->dev, OUT_WRT_CNT_REG );
+	req->req.actual += min( count, bufferspace );
+
+	dev_vdbg(ep->dev->dev, "read packet %s req %p len %u count %u\n",
+		ep->ep.name, req, count,
+		usb_read(ep->dev, OUT_WRT_CNT_REG));
+
+	is_short = (count < ep->ep.maxpacket);
+
+	DEBUG_PRINT("read %s %02x, %d bytes%s req %p %d/%d\n",
+	      ep->ep.name, usb_read(ep->dev, ep->csr), count, is_short ? "/S" : "", req, req->req.actual, req->req.length);
+
+#define SETBUF_1BYTE( x )																						\
+	if( unlikely(bufferspace == 0) ){																			\
+		if( req->req.status != -EOVERFLOW ) DEBUG_EP0("%s overflow i=%d count=%d\n", ep->ep.name, i, count );	\
+		req->req.status = -EOVERFLOW;																			\
+	} else {																									\
+		*buf++ = (x);																							\
+		bufferspace--;																							\
+	}
+	
+	for( i=0 ; i < count ; i+=2 ){
+		u32 tmp = usb_read(ep->dev, ep->fifo);			/*_ ÆÉ¤á¤ë¤Î¤Ï2¥Ð¥¤¥ÈÃ±°Ì _*/
+		FIFO_PRINT("fifo>0x%04x\n",tmp);
+		
+		SETBUF_1BYTE( tmp & 0xff );
+		if( count - i == 1 ) break;			/*_ ºÇ¸å¤Î°ì¥Ð¥¤¥È¤ò¥Ð¥Ã¥Õ¥¡¤Ë½ñ¤­½ª¤¨¤¿¤Î¤Ç½ªÎ»¤¹¤ë _*/
+		SETBUF_1BYTE( (tmp>>8) & 0xff );
+	}
+	
+	usb_clear(ep->dev, MCU_OUT_PKT_RDY, ep->csr );
+
+	return is_short;
+}
+
+/* returns: 0: still running, 1: completed */
+static int
+panasonic_read_fifo(struct panasonic_ep *ep, struct panasonic_request *req)
+{
+	u8 *buf;
+	unsigned is_short;
+	int status = -1;
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	dev_vdbg(ep->dev->dev, "read_fifo %s actual %d len %d\n",
+		ep->ep.name, req->req.actual, req->req.length);
+ top:
+
+	do {
+		buf = req->req.buf + req->req.actual;
+		prefetchw(buf);
+
+		is_short = panasonic_read_packet(ep, buf, req);
+
+		/* completion */
+		if (unlikely(is_short ||
+				((req->req.actual == req->req.length)
+				 && !req->req.zero))) {
+
+			panasonic_done(ep, req, 0);
+
+			if (!list_empty(&ep->queue)) {
+				req = list_entry(ep->queue.next,
+					struct panasonic_request, queue);
+
+				status = panasonic_kick_dma(ep, req);
+				if ((status < 0) &&
+				    (usb_read(ep->dev, ep->csr) & MCU_OUT_PKT_RDY) == MCU_OUT_PKT_RDY)
+					goto top;
+			}else{
+				pio_irq_disable(ep->dev, ep->num);
+			}
+			return 1;
+		}
+	} while ((usb_read(ep->dev, ep->csr) & MCU_OUT_PKT_RDY) == MCU_OUT_PKT_RDY);
+
+	return 0;
+}
+
+/* returns 0 on success, else negative errno */
+static int
+panasonic_kick_dma(struct panasonic_ep *ep, struct panasonic_request *req)
+{
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	unsigned size;
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	if (!use_dma || (ep->num == 0) || (ep->num >= UDC_MAX_ENDPOINTS) || !ep->dma)
+		return -EINVAL;
+
+	dev_vdbg(ep->dev->dev, "kick_dma %s req %p dma %08llx, length %d\n",
+		ep->ep.name, req, (unsigned long long) req->req.dma, req->req.length);
+
+	size = req->req.length;
+
+	/* device-to-host transfer */
+	if (ep->is_in) {
+		/* initialize platform's dma controller */
+		if (panasonic_request_write_dma(ep, req->req.dma, size, req->req.zero))
+			/* unable to obtain DMA channel; return error and use pio mode */
+			return -EBUSY;
+		req->req.actual += size;
+	/* host-to-device transfer */
+	} else {
+		/* initialize platform's dma controller */
+		if (panasonic_request_read_dma(ep, req->req.dma, size))
+			/* unable to obtain DMA channel; return error and use pio mode */
+			return -EBUSY;
+	}
+
+	pio_irq_enable(ep->dev, ep->num);
+
+	return 0;
+#else
+	return -EBUSY;
+#endif	/* CONFIG_USB_PANASONIC_ENABLE_DMA */
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int
+panasonic_queue(struct usb_ep *_ep, struct usb_request *_req, gfp_t gfp_flags)
+{
+	struct panasonic_request *req;
+	struct panasonic_ep *ep;
+	struct panasonic_udc *dev;
+	unsigned long flags;
+	int status = -1;
+
+	req = container_of(_req, struct panasonic_request, req);
+	if (!_req || !_req->complete || !_req->buf
+			|| !list_empty(&req->queue))
+		return -EINVAL;
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return -EINVAL;
+	dev = ep->dev;
+	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+
+	/* set up dma mapping in case the caller didn't */
+	if (use_dma && ep->dma) {
+		status = usb_gadget_map_request(&dev->gadget, _req,
+				ep->is_in);
+		if (status)
+			return status;
+	}
+
+	DEBUG_PRINT("%s queue req %p, len %d buf %p dma %08lx %s\n",
+		_ep->name, _req, _req->length, _req->buf,
+		(unsigned long) _req->dma, _req->zero ? "zero" : "!zero");
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	_req->status = -EINPROGRESS;
+	_req->actual = 0;
+
+	QUEUE_LOG("[queue] ep:%d, list_empty(&ep->queue)=%d, !ep->stopped=%d, len=%d\n",
+		ep->num,list_empty(&ep->queue),likely(!ep->stopped), req->req.length );
+
+	/* kickstart this i/o queue? */
+	if (list_empty(&ep->queue) && !ep->stopped) {
+		u32 csr;
+		QUEUE_LOG("%s:%d\n",__FUNCTION__,__LINE__);
+
+		/* maybe there's no control data, just status ack */
+		if (ep->num == 0){
+			/* EP0 */
+			QUEUE_LOG( "%s:%d\n", __FUNCTION__, __LINE__ );
+			list_add_tail(&req->queue, &ep->queue);
+			panasonic_udc_ep0_kick(dev, ep);
+			req = 0;
+		}else{
+			/* EP1-EP8 */
+			/* try dma first */
+			status = panasonic_kick_dma(ep, req);
+
+			if (status < 0) {
+				/* dma failed (most likely in use by another endpoint)
+				 * fallback to pio
+				 */
+				status = 0;
+
+				if (ep->is_in){
+					QUEUE_LOG( "%s:%d\n", __FUNCTION__, __LINE__ );
+					pio_irq_enable(dev, ep->num);
+					status = panasonic_write_fifo(ep, req);
+				}else{
+					usb_set_index(dev, ep->num);
+					csr = usb_read(dev, ep->csr);
+					QUEUE_LOG( "%s:%d:IRQ_REG=0x%04x, IRQ_ENA_REG=0x%08x req=%p ep=%d csr=%04x\n",
+						__FUNCTION__, __LINE__, usb_read(dev, IRQ_REG), usb_read(dev, IRQ_ENA_REG), req, ep->num, csr );
+
+					if ((csr & MCU_OUT_PKT_RDY) == MCU_OUT_PKT_RDY){
+						status = panasonic_read_fifo(ep, req);
+					}
+
+					if(status == 0){
+						/*_ Queue¤ËÆþ¤ì¤ë¾ì¹ç¤Î¤ß¡¢³ä¹þ¤ß¤òÍ­¸ú¤Ë¤¹¤ë¡£¤½¤¦¤·¤Ê¤¤¤È¡¢¶õÆÉ¤ß¤·¤ÆMCU_OUT_PKT_RDY¤ò¾Ã¤·¤Æ¤·¤Þ¤¦¾ì¹ç¤¬¤¢¤ë¡£ _*/
+						pio_irq_enable(dev, ep->num);
+					}
+				}
+
+				if (unlikely(status != 0)) {
+					if (status > 0)
+						status = 0;
+					req = NULL;
+				}
+			}
+		}
+	}
+	if (likely(req)){
+		QUEUE_LOG( "Q%d IRQ=%x,IRQ_ENA=%x\n", ep->num, usb_read(dev, IRQ_REG), usb_read(dev, IRQ_ENA_REG) );
+		list_add_tail(&req->queue, &ep->queue);
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+/* dequeue ALL requests */
+static void
+panasonic_dequeue_all(struct panasonic_ep *ep)
+{
+	struct panasonic_request *req;
+
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	/* called with spinlock held */
+	ep->stopped = 1;
+
+	while (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next,
+				struct panasonic_request,
+				queue);
+		panasonic_done(ep, req, -ESHUTDOWN);
+	}
+}
+
+/* dequeue JUST ONE request */
+static int
+panasonic_dequeue(struct usb_ep *_ep, struct usb_request *_req)
+{
+	struct panasonic_ep *ep;
+	struct panasonic_request *req;
+	unsigned long flags;
+	int stopped;
+
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0) || !_req)
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	stopped = ep->stopped;
+	ep->stopped = 1;
+
+	/* make sure it's still queued on this endpoint */
+	list_for_each_entry(req, &ep->queue, queue) {
+		if (&req->req == _req)
+			break;
+	}
+	if (&req->req != _req) {
+		spin_unlock_irqrestore(&ep->dev->lock, flags);
+		return -EINVAL;
+	}
+
+	/* queue head may be partially complete */
+	if (ep->queue.next == &req->queue) {
+		dev_dbg(ep->dev->dev, "unlink (%s) pio\n", _ep->name);
+		panasonic_done(ep, req, -ECONNRESET);
+	}
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	panasonic_dma_stop(ep);
+#endif
+
+	req = NULL;
+	ep->stopped = stopped;
+
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int
+panasonic_set_halt_and_wedge(struct usb_ep *_ep, int value, int wedged)
+{
+	struct panasonic_ep *ep;
+	unsigned long flags;
+	int ret = 0;
+	u32 csr;
+
+	DEBUG_PRINT( "%s: %s halt=%d wedged=%d\n", __FUNCTION__, _ep->name, value, wedged);
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return -EINVAL;
+	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return -ESHUTDOWN;
+	if (ep->desc /* not ep0 */ && usb_endpoint_xfer_isoc(ep->desc))
+		return -EINVAL;
+
+	spin_lock_irqsave(&ep->dev->lock, flags);
+	usb_set_index(ep->dev, ep->num);
+
+	if( ep->num == 0 ){
+		/* EP0 */
+		DEBUG_PRINT( "SEND_STALL" );
+		ERROR_PRINT( "EP0 send stall in %s : ep->csr=0x%x\n", __FUNCTION__, usb_read(ep->dev, ep->csr) );
+		usb_set( ep->dev, EP0_CLEAR_OPR|EP0_SEND_STALL, ep->csr );	/*_ CLEAR_OPR¤ÇÎÉ¤¤¤Î¤«¡©¥Ç¡¼¥¿¥¹¥Æ¡¼¥¸¤Î¥±¥¢¤âÉ¬Í×¡© _*/
+	}else if( ep->is_in ){
+		csr = usb_read( ep->dev, ep->csr );
+		if( value && ((csr & USB_IN_PKT_RDY) || !list_empty(&ep->queue)) ){
+			/*
+			 * Attempts to halt IN endpoints will fail (returning -EAGAIN)
+			 * if any transfer requests are still queued, or if the controller
+			 * FIFO still holds bytes that the host hasn?t collected.
+			 */
+			spin_unlock_irqrestore(&ep->dev->lock, flags);
+			DEBUG_PRINT( "Attempt to halt IN endpoint failed (returning -EAGAIN) %d %d\n", (csr & USB_IN_PKT_RDY), !list_empty(&ep->queue) );
+			return -EAGAIN;
+		}
+		if( value ){
+			DEBUG_PRINT( "IN_SEND_STALL" );
+			usb_set( ep->dev, IN_SEND_STALL, ep->csr );
+		}else {
+			usb_clear(ep->dev, IN_SEND_STALL, ep->csr );
+			usb_set( ep->dev, IN_RST_DATA_PID, ep->csr );
+			if( !list_empty(&ep->queue) ){
+				DEBUG_PRINT("Force Enable IRQ(%d)", ep->num );
+				pio_irq_enable(ep->dev, ep->num);	/*_ queue¤Ë´û¤ËÎ¯¤Þ¤Ã¤Æ¤¤¤ë¾ì¹ç¡¢³ä¹þ¤ß¤òÍ­¸ú¤Ë¤¹¤ë _*/
+				DEBUG_PRINT( "csr=0x%04x, ir=0x%04x, en=0x%04x\n", usb_read(ep->dev, ep->csr), usb_read(ep->dev, IRQ_REG),usb_read(ep->dev, IRQ_ENA_REG) );
+			}
+		}
+	
+	}else{
+		//OUT EP
+		if (value){
+			DEBUG_PRINT("OUT_SEND_STALL");
+#if 0	/*_ GerdaC 2015/1/14 usb_set¤ò»È¤¦¤ÈOPR¤ò¾Ãµî¤·¤Æ¤·¤Þ¤¦¤³¤È¤¬¤¢¤ë _*/
+			usb_set(ep->dev, OUT_SEND_STALL, ep->csr);
+#else
+			csr = usb_read( ep->dev, ep->csr );
+			usb_write(ep->dev, csr | MCU_IN_PKT_RDY| OUT_SEND_STALL, ep->csr);
+#endif
+		}else {
+#if 0	/*_ GerdaC 2015/1/14 usb_clear/usb_set¤ò»È¤¦¤ÈOPR¤ò¾Ãµî¤·¤Æ¤·¤Þ¤¦¤³¤È¤¬¤¢¤ë _*/
+			usb_clear(ep->dev, OUT_SEND_STALL, ep->csr);
+			usb_set(ep->dev, OUT_RST_DATA_PID, ep->csr);
+#else
+			csr = usb_read( ep->dev, ep->csr );
+			csr &= ~OUT_SEND_STALL;
+			usb_write(ep->dev, csr | MCU_IN_PKT_RDY | OUT_RST_DATA_PID , ep->csr);
+#endif
+			if( !list_empty(&ep->queue) ){
+				DEBUG_PRINT("Force Enable IRQ(%d)", ep->num );
+				pio_irq_enable(ep->dev, ep->num);	/*_ queue¤Ë´û¤ËÎ¯¤Þ¤Ã¤Æ¤¤¤ë¾ì¹ç¡¢³ä¹þ¤ß¤òÍ­¸ú¤Ë¤¹¤ë _*/
+				DEBUG_PRINT( "csr=0x%04x, ir=0x%04x, en=0x%04x\n", usb_read(ep->dev, ep->csr), usb_read(ep->dev, IRQ_REG),usb_read(ep->dev, IRQ_ENA_REG) );
+			}
+		}
+	}
+	
+	if( value ){
+		DEBUG_PRINT( "halt ep=%d\n", ep->num );
+		ep->stopped = 1;
+		if (wedged)
+			ep->wedged = 1;
+
+	} else {
+		DEBUG_PRINT( "Dehalt ep=%d\n", ep->num );
+		ep->stopped = 0;
+		ep->wedged = 0;
+	}
+	spin_unlock_irqrestore(&ep->dev->lock, flags);
+
+	return ret;
+}
+
+int
+panasonic_set_halt(struct usb_ep *_ep, int value)
+{
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	return panasonic_set_halt_and_wedge(_ep, value, 0);
+}
+
+static int
+panasonic_set_wedge(struct usb_ep *_ep)
+{
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	if (!_ep || _ep->name == ep0name)
+		return -EINVAL;
+	return panasonic_set_halt_and_wedge(_ep, 1, 1);
+}
+
+static int
+panasonic_fifo_status(struct usb_ep *_ep)
+{
+	u32 csr;
+	int count = 0;
+	struct panasonic_ep *ep;
+	unsigned long flags;
+	
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if( !_ep ){
+		ERROR_PRINT( "%s, bad ep\n", __FUNCTION__ );
+		return -ENODEV;
+	}
+	
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+	
+	/* LPD can't report unclaimed bytes from IN fifos */
+	if( ep->is_in ) return -EOPNOTSUPP;
+	
+	spin_lock_irqsave( &ep->dev->lock, flags );
+	usb_set_index( ep->dev, ep->num );
+	
+	csr = usb_read(ep->dev, ep->csr);
+	if( ep->dev->gadget.speed != USB_SPEED_UNKNOWN || csr & MCU_OUT_PKT_RDY ){
+		count = usb_read(ep->dev, OUT_WRT_CNT_REG);
+	}
+	spin_unlock_irqrestore( &ep->dev->lock, flags );
+	
+	return count;
+}
+
+static void
+panasonic_fifo_flush(struct usb_ep *_ep)
+{
+	struct panasonic_ep *ep;
+	unsigned long flags;
+	u32 csr;
+
+	DEBUG_PRINT( "%s: %s\n", __FUNCTION__, _ep->name );
+
+	ep = container_of(_ep, struct panasonic_ep, ep);
+	if (!_ep || (!ep->desc && ep->num != 0))
+		return;
+	if(ep->num == 0)
+		return;
+	if (!ep->dev->driver || ep->dev->gadget.speed == USB_SPEED_UNKNOWN)
+		return;
+
+	spin_lock_irqsave( &ep->dev->lock, flags );
+	usb_set_index( ep->dev, ep->num );
+
+#if 0	/*_ GerdaC 2015/1/14 usb_set¤ò»È¤¦¤ÈIPR/OPR¤ò¾Ãµî¤·¤Æ¤·¤Þ¤¦¤³¤È¤¬¤¢¤ë _*/
+	if(ep->is_in){
+		usb_set(ep->dev, IN_FIFO_FLUSH, IN_CSR_REG);
+	}else{
+		usb_set(ep->dev, OUT_FIFO_FLUSH, OUT_CSR_REG);
+	}
+#else
+	csr = usb_read(ep->dev, ep->csr);
+
+	if(ep->is_in){
+		csr &= ~MCU_IN_PKT_RDY;
+		usb_write(ep->dev, csr | IN_FIFO_FLUSH, IN_CSR_REG);
+	}else{
+		usb_write(ep->dev, csr | OUT_FIFO_FLUSH | MCU_OUT_PKT_RDY, OUT_CSR_REG);
+	}
+#endif
+
+	spin_unlock_irqrestore( &ep->dev->lock, flags );
+
+}
+
+static struct usb_ep_ops panasonic_ep_ops = {
+	.enable        = panasonic_enable,
+	.disable       = panasonic_disable,
+
+	.alloc_request = panasonic_alloc_request,
+	.free_request  = panasonic_free_request,
+
+	.queue         = panasonic_queue,
+	.dequeue       = panasonic_dequeue,
+
+	.set_halt      = panasonic_set_halt,
+	.set_wedge     = panasonic_set_wedge,
+	.fifo_status   = panasonic_fifo_status,
+	.fifo_flush    = panasonic_fifo_flush,
+};
+
+/*---------------------------------------------------------------------------*/
+
+static int
+panasonic_get_frame(struct usb_gadget *_gadget)
+{
+	struct panasonic_udc *dev;
+	unsigned long flags;
+	u32 frame;
+
+	DEBUG_PRINT( "%s: usb_gadget = %p\n", __FUNCTION__, _gadget );
+
+	if (!_gadget)
+		return -ENODEV;
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+	spin_lock_irqsave(&dev->lock, flags);
+
+	frame = usb_read(dev, SOF_CNT_REG);							//Bit0 - Bit10 Framenumber Bit11 - Bit13 uFrame
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+	return ( (frame & 0xfff) << 3 ) | ( (frame >> 11) & 0x7 );	// frame12bit + uframe 3bit
+}
+
+static int
+panasonic_wakeup(struct usb_gadget *_gadget)
+{
+#if 1	/*_  2014/11/10 T.B.D wakeupÌ¤¼ÂÁõ _*/
+	DEBUG_PRINT( "%s: usb_gadget = %p\n", __FUNCTION__, _gadget );
+
+	/* host may not have enabled remote wakeup */
+	return -ENOTSUPP;
+#else
+	struct panasonic_udc *dev;
+	u8 tmp;
+	unsigned long flags;
+
+	if (!_gadget)
+		return 0;
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+
+	spin_lock_irqsave(&dev->lock, flags);
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+#endif
+}
+
+static int
+panasonic_set_selfpowered(struct usb_gadget *_gadget, int value)
+{
+	struct panasonic_udc *dev;
+
+	DEBUG_PRINT( "%s: usb_gadget = %p\n", __FUNCTION__, _gadget );
+
+	if (!_gadget)
+		return -ENODEV;
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+
+	dev->is_selfpowered = value;
+
+	return 0;
+}
+
+static int
+panasonic_pullup(struct usb_gadget *_gadget, int is_on)
+{
+	struct panasonic_udc *dev;
+	unsigned long flags;
+	
+	DEBUG_PRINT( "%s: usb_gadget = %p %s\n", __FUNCTION__, _gadget , 
+					(is_on) == 0 ? "FUNCTION_DISABLE":"FUNCTION_ENABLE");
+
+	if (!_gadget)
+		return -ENODEV;
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+
+	if(strcmp(dev->driver->function,dummy_name) == 0){
+		printk("%s: found dummy gadget driver\n",__FUNCTION__);
+		return 0;
+	}
+
+	spin_lock_irqsave(&dev->lock, flags);
+	dev->softconnect = (is_on != 0);
+	if (is_on){
+		usbtop_clear(dev, USBSEL|DNPULLDOWN|DPPULLDOWN , USB_SEL );
+		usb_set(dev, FUNCTION_ENABLE, USB_CSR );
+	}
+	else{
+		usb_clear(dev, FUNCTION_ENABLE, USB_CSR );
+		usbtop_set(dev, USBSEL|DNPULLDOWN|DPPULLDOWN, USB_SEL );
+	}
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return 0;
+}
+
+static int panasonic_start(struct usb_gadget *_gadget,
+		struct usb_gadget_driver *driver);
+static int panasonic_stop(struct usb_gadget *_gadget,
+		struct usb_gadget_driver *driver);
+
+static const struct usb_gadget_ops panasonic_ops = {
+	.get_frame	= panasonic_get_frame,
+	.wakeup		= panasonic_wakeup,
+	.set_selfpowered = panasonic_set_selfpowered,
+	.pullup		= panasonic_pullup,
+	.udc_start	= panasonic_start,
+	.udc_stop	= panasonic_stop,
+};
+
+/*---------------------------------------------------------------------------*/
+#if 0	/*_  2014/10/14 T.B.D °ìÃ¶¥«¥Ã¥È¡£¸åÆü¸¡Æ¤ _*/
+static ssize_t
+registers_show(struct device *_dev, struct device_attribute *attr, char *buf)
+{
+	struct panasonic_udc *dev;
+	char *next;
+	unsigned size, t;
+	unsigned long flags;
+	u8 t1, t2;
+	int i;
+	const char *s;
+
+	dev = dev_get_drvdata(_dev);
+	next = buf;
+	size = PAGE_SIZE;
+	spin_lock_irqsave(&dev->lock, flags);
+
+	if (dev->driver)
+		s = dev->driver->driver.name;
+	else
+		s = "(none)";
+
+	/* Main Control Registers */
+	t = scnprintf(next, size, "%s version %s,"
+		"chiprev %02x, locctl %02x\n"
+		"irqenb0 %02x irqenb1 %02x "
+		"irqstat0 %02x irqstat1 %02x\n",
+		driver_name, driver_vers, dev->chiprev,
+		panasonic_read(dev, LOCCTL),
+		panasonic_read(dev, IRQENB0),
+		panasonic_read(dev, IRQENB1),
+		panasonic_read(dev, IRQSTAT0),
+		panasonic_read(dev, IRQSTAT1));
+	size -= t;
+	next += t;
+
+	/* DMA */
+	t1 = panasonic_read(dev, DMAREQ);
+	t = scnprintf(next, size, "\ndmareq %02x: %s %s%s%s%s\n",
+		t1, ep_name[(t1 & 0x01) + 1],
+		t1 & (1 << DMA_CONTROL_DACK) ? "dack " : "",
+		t1 & (1 << DMA_REQUEST_ENABLE) ? "reqenb " : "",
+		t1 & (1 << DMA_REQUEST) ? "req " : "",
+		t1 & (1 << DMA_BUFFER_VALID) ? "valid " : "");
+	size -= t;
+	next += t;
+
+	/* USB Control Registers */
+	t1 = panasonic_read(dev, USBCTL1);
+	if (t1 & (1 << VBUS_PIN)) {
+		if (t1 & (1 << USB_HIGH_SPEED))
+			s = "high speed";
+		else if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+			s = "powered";
+		else
+			s = "full speed";
+	} else
+		s = "not attached";
+	t = scnprintf(next, size,
+		"usbctl0 %02x usbctl1 %02x addr 0x%02x (%s)\n",
+		panasonic_read(dev, USBCTL0), t1,
+		panasonic_read(dev, OURADDR), s);
+	size -= t;
+	next += t;
+
+	/* Endpoint Registers */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; ++i) {
+		struct panasonic_ep *ep;
+
+		ep = &dev->ep[i];
+		if (i && !ep->desc)
+			continue;
+
+		t1 = panasonic_ep_read(ep, EP_CFG);
+		t2 = panasonic_ep_read(ep, EP_RSPSET);
+		t = scnprintf(next, size,
+			"\n%s\tcfg %02x rsp (%02x) %s%s%s%s%s%s%s%s"
+			"irqenb %02x\n",
+			ep->ep.name, t1, t2,
+			(t2 & (1 << ALT_NAK_OUT_PACKETS)) ? "NAK " : "",
+			(t2 & (1 << HIDE_STATUS_PHASE)) ? "hide " : "",
+			(t2 & (1 << AUTOVALIDATE)) ? "auto " : "",
+			(t2 & (1 << INTERRUPT_MODE)) ? "interrupt " : "",
+			(t2 & (1 << CONTROL_STATUS_PHASE_HANDSHAKE)) ? "status " : "",
+			(t2 & (1 << NAK_OUT_PACKETS_MODE)) ? "NAKmode " : "",
+			(t2 & (1 << ENDPOINT_TOGGLE)) ? "DATA1 " : "DATA0 ",
+			(t2 & (1 << ENDPOINT_HALT)) ? "HALT " : "",
+			panasonic_ep_read(ep, EP_IRQENB));
+		size -= t;
+		next += t;
+
+		t = scnprintf(next, size,
+			"\tstat0 %02x stat1 %02x avail %04x "
+			"(ep%d%s-%s)%s\n",
+			panasonic_ep_read(ep, EP_STAT0),
+			panasonic_ep_read(ep, EP_STAT1),
+			(panasonic_ep_read(ep, EP_AVAIL1) << 8) | panasonic_ep_read(ep, EP_AVAIL0),
+			t1 & 0x0f,
+			ep->is_in ? "in" : "out",
+			type_string(t1 >> 5),
+			ep->stopped ? "*" : "");
+		size -= t;
+		next += t;
+
+		t = scnprintf(next, size,
+			"\tep_transfer %06x\n",
+			((panasonic_ep_read(ep, EP_TRANSFER2) & 0xff) << 16) |
+			((panasonic_ep_read(ep, EP_TRANSFER1) & 0xff) << 8) |
+			((panasonic_ep_read(ep, EP_TRANSFER0) & 0xff)));
+		size -= t;
+		next += t;
+
+		t1 = panasonic_ep_read(ep, EP_BUFF_STATES) & 0x03;
+		t2 = (panasonic_ep_read(ep, EP_BUFF_STATES) >> 2) & 0x03;
+		t = scnprintf(next, size,
+			"\tbuf-a %s buf-b %s\n",
+			buf_state_string(t1),
+			buf_state_string(t2));
+		size -= t;
+		next += t;
+	}
+
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	return PAGE_SIZE - size;
+}
+static DEVICE_ATTR_RO(registers);
+#endif
+
+/*---------------------------------------------------------------------------*/
+
+static void
+panasonic_set_fifo_mode(struct panasonic_udc *dev, int mode)
+{
+	int i;
+	int blkSz;
+	unsigned short fifoUsed = 0;
+
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	INIT_LIST_HEAD(&dev->gadget.ep_list);
+
+	switch (mode) {
+	case 0:
+		/* ep1¡Áep4 assain 1024byte(512*2) */
+		blkSz = 1024;
+		for (i = 1; i < UDC_MAX_ENDPOINTS; ++i) {
+
+			list_add_tail(&dev->ep[i].ep.ep_list, &dev->gadget.ep_list);
+			dev->ep[i].fifo_size = blkSz;
+
+			usb_set_index(dev, dev->ep[i].num);
+			usb_clear(dev, EP_SINGLE, EP_CONFIG_REG );					/*_ ¥À¥Ö¥ë¥Ð¥Ã¥Õ¥¡¤òÀßÄê¡£Maxp¥µ¥¤¥º¤Ïpanasonic_enable¤ÇÀßÄê _*/
+
+			usb_write(dev, fifoUsed/8, FIFO_START );					/*_ FIFO¤Î³«»Ï¥ª¥Õ¥»¥Ã¥È¡£8¤Ç³ä¤Ã¤Æ»ØÄê _*/
+			usb_write(dev, blkSz/8,   FIFO_SIZE );						/*_ FIFO¤Î¥µ¥¤¥º¡£8¤Ç³ä¤Ã¤Æ»ØÄê _*/
+			fifoUsed +=blkSz;
+		}
+		break;
+	default:
+		ERROR_PRINT( "%s: Undefined fifo mode! mode -> %d\n", __FUNCTION__, mode );
+		break;
+	}
+
+}
+
+/*---------------------------------------------------------------------------*/
+
+static void
+panasonic_usb_reset(struct panasonic_udc *dev)
+{
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	usb_write(dev, 0, IRQ_ENA_REG);			/*_ ³ä¹þ¤ßÌµ¸ú _*/
+
+#if 0	/*_  2014/10/24  panasonic_usb_reinit¤Ë°ÜÆ° _*/
+	panasonic_set_fifo_mode(dev, (fifo_mode <= MAX_FIFO_MODE) ? fifo_mode : 0);
+#endif
+	dev->gadget.speed = USB_SPEED_UNKNOWN;
+	dev->usb_address = 0;
+	dev->ep0state = WAIT_FOR_SETUP;
+
+}
+
+static void
+panasonic_usb_reinit(struct panasonic_udc *dev)
+{
+	int i;
+
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	/* basic endpoint init */
+	for (i = 0; i < UDC_MAX_ENDPOINTS; ++i) {
+		struct panasonic_ep *ep = &dev->ep[i];
+
+		ep->ep.name = ep_name[i];
+		ep->dev = dev;
+		ep->num = i;
+		ep->not_empty = 0;
+		ep->fifo = ep_fifo[i];
+
+		if (use_dma 
+			&& ep->num !=0
+			&& (dma_ep & (1 << ep->num)) != 0){
+			ep->dma = 1;
+		}
+		panasonic_ep_reset(ep);
+	}
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	/*_ DMAÄä»ß½èÍý(FIFO0) _*/
+	usb_write(dev, BIT4, DMA_FIFO0_CNT);
+	while( usb_read(dev, DMA_FIFO0_CNT) & BIT4 );	/*_ ½é´ü²½´°Î»ÂÔ¤Á T.B.D _*/
+
+	if( usb_read(dev, DMA_FIFO0_STATUS) & 0xff00 ){	/*_ µÛ½Ð¤·¡£¥´¥ß¤¬»Ä¤Ã¤Æ¤¤¤ë¤È¡¢¼¡²ó¼ºÇÔ¤¹¤ë¡©¤½¤â¤½¤â¥´¥ß¤Ï²¿¡© _*/
+		ERROR_PRINT( "%s:%d DMA FIFO is not empty! DMA_FIFO0_STATUS is0x%x\n", __FUNCTION__, __LINE__, usb_read(dev, DMA_FIFO0_STATUS) );
+		flushOutDMAFIFO0(dev);
+	}
+
+	/*_ DMAÄä»ß½èÍý(FIFO1) _*/
+	usb_write(dev, BIT4, DMA_FIFO1_CNT);
+	while( usb_read(dev, DMA_FIFO1_CNT) & BIT4 );	/*_ ½é´ü²½´°Î»ÂÔ¤Á T.B.D¡¡_*/
+
+	if( usb_read(dev, DMA_FIFO1_STATUS) & 0xff00 ){	/*_ µÛ½Ð¤·¡£¥´¥ß¤¬»Ä¤Ã¤Æ¤¤¤ë¤È¡¢¼¡²ó¼ºÇÔ¤¹¤ë¡©¤½¤â¤½¤â¥´¥ß¤Ï²¿¡© _*/
+		ERROR_PRINT( "%s:%d DMA FIFO is not empty! DMA_FIFO1_STATUS is0x%x\n", __FUNCTION__, __LINE__, usb_read(dev, DMA_FIFO1_STATUS) );
+		flushOutDMAFIFO1(dev);
+	}
+#endif
+
+	/*_  2014/10/24 panasonic_usb_reset¤«¤é°ÜÆ° _*/
+	panasonic_set_fifo_mode(dev, (fifo_mode <= MAX_FIFO_MODE) ? fifo_mode : 0);
+
+	usb_ep_set_maxpacket_limit(&dev->ep[0].ep, 64);
+
+	dev->gadget.ep0 = &dev->ep[0].ep;
+	dev->ep[0].stopped = 0;
+	dev->ep[0].csr = EP0_CSR_REG;
+	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
+}
+
+static void
+panasonic_ep0_start(struct panasonic_udc *dev)
+{
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	usb_set(dev, USB_CSR_ENABLE_SUSPEND, USB_CSR );
+	usb_write(dev, EP0_INTERRUPT|VBUS_INTERRUPT, IRQ_ENA_REG );	//Enable interrupts
+
+}
+
+static int
+panasonic_activate(void)
+{
+	void __iomem		*rst_ctrl, *usbd_clk, *sdma_base;
+	int ret = 0;
+
+	DEBUG_PRINT( "%s:\n", __FUNCTION__);
+
+	rst_ctrl = ioremap_nocache(0x9C010000, 0x100);
+	if(!rst_ctrl){
+		ERROR_PRINT( "%s: ioremap(0x9C010000) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err;
+	}
+
+	usbd_clk = ioremap_nocache(0x9C011010, 0x20);
+	if(!usbd_clk){
+		ERROR_PRINT( "%s: ioremap(0x9C011010) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err_dclk;
+	}
+
+	sdma_base = ioremap_nocache(0x9C000000, 0x20);
+	if(!sdma_base){
+		ERROR_PRINT( "%s: ioremap(0x9C000000) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err_sdma;
+	}
+
+	/*_ USB-DEVICEµÚ¤Ó¼þÊÕ²óÏ©¤Î½é´ü²½¤ò¹Ô¤¦ _*/
+	
+	/*_ 1-1. USB0 PHYÍÑ¥ê¥»¥Ã¥È¤ò¡¢¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ RSTCTRL3¥ì¥¸¥¹¥¿¤ÎUSB-PHYNRST¥Ó¥Ã¥È(bit5)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000020, (void __iomem*)((u32)rst_ctrl+0x0C));
+
+	/*_ 1-2. USB1 PHYÍÑ¥ê¥»¥Ã¥È¤ò¡¢¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ RSTCTRL20¥ì¥¸¥¹¥¿¤ÎUSB-PHYNRST¥Ó¥Ã¥È(bit0)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000001, (void __iomem*)((u32)rst_ctrl+0x80));
+	
+	/*_ 2. PHYÍÑ¥¯¥í¥Ã¥¯¤ò¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ CGCTRL3¤ÎUSBPHYCLKCG¥Ó¥Ã¥È(bit11)=1¤ËÀßÄê _*/
+	usb_ioset32(0x00000800, (void __iomem*)((u32)usbd_clk+0x04));
+
+	/*_ 2-1. USB0 PHYÍÑ¥¯¥í¥Ã¥¯¤ò¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ CGCTRL2¤ÎUSB0PHYCLKCG¥Ó¥Ã¥È(bit2)=1¤ËÀßÄê _*/
+	usb_ioset32(0x00000004, (void __iomem*)((u32)usbd_clk));
+	
+	/*_ 2-2. USB1 PHYÍÑ¥¯¥í¥Ã¥¯¤ò¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ CGCTRL2¤ÎUSB0PHYCLKCG¥Ó¥Ã¥È(bit3)=1¤ËÀßÄê _*/
+	usb_ioset32(0x00000008, (void __iomem*)((u32)usbd_clk));
+	
+	/*_ 3-1. USB0ÍÑÁ´ÂÎÀ©¸æÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL3¥ì¥¸¥¹¥¿¤ÎUSB-TOPNRST¥Ó¥Ã¥È(bit6)=1¤ËÀßÄê _*/
+	usb_ioset32(0x00000040, (void __iomem*)((u32)rst_ctrl+0x0C));
+
+	/*_ 3-2. USB1ÍÑÁ´ÂÎÀ©¸æÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL20¥ì¥¸¥¹¥¿¤ÎUSB-TOPNRST¥Ó¥Ã¥È(bit3)=1¤ËÀßÄê _*/
+	usb_ioset32(0x00000008, (void __iomem*)((u32)rst_ctrl+0x80));
+	
+	/*_ 4-1. USB0ÍÑÁ´ÂÎÀ©¸æÍÑ¥¯¥í¥Ã¥¯¤ò¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ CGCTRL2¥ì¥¸¥¹¥¿¤ÎUSBTCLKCG¥Ó¥Ã¥È¡Êbit0)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000001, usbd_clk);
+
+	/*_ 4-2. USB1ÍÑÁ´ÂÎÀ©¸æÍÑ¥¯¥í¥Ã¥¯¤ò¥¤¥Í¡¼¥Ö¥ë _*/
+	/*_ CGCTRL2¥ì¥¸¥¹¥¿¤ÎUSBTCLKCG¥Ó¥Ã¥È¡Êbit1)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000002, usbd_clk);
+#if 0
+	/*_ 5-1. USB0ÍÑÁ´ÂÎÀ©¸æÍÑ¥ì¥¸¥¹¥¿¤òÀßÄê _*/
+	/*_ USB_SEL¥ì¥¸¥¹¥¿¤ÇDPPULLDOWN¥Ó¥Ã¥È(bit2)¡¢DNPULLDOWN¥Ó¥Ã¥È(bit1)¡¢USB_SEL¥Ó¥Ã¥È(bit0)¤ò0¤ËÀßÄê _*/
+	/*_ move panasonic_pullup _*/
+
+	/*_ 5-2. USB1ÍÑÁ´ÂÎÀ©¸æÍÑ¥ì¥¸¥¹¥¿¤òÀßÄê _*/
+	/*_ USB_SEL¥ì¥¸¥¹¥¿¤ÇDPPULLDOWN¥Ó¥Ã¥È(bit2)¡¢DNPULLDOWN¥Ó¥Ã¥È(bit1)¡¢USB_SEL¥Ó¥Ã¥È(bit0)¤ò0¤ËÀßÄê _*/
+	/*_ move panasonic_pullup _*/
+#endif
+	/*_ 6-1. USB0-DEVICEÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL0¥ì¥¸¥¹¥¿¤ÎUSBHNRST¥Ó¥Ã¥È(bit13)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00002000, rst_ctrl);
+
+	/*_ 6-2. USB1-DEVICEÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL20¥ì¥¸¥¹¥¿¤ÎUSBHNRST¥Ó¥Ã¥È(bit1)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000002, (void __iomem*)((u32)rst_ctrl+0x80));
+
+	/*_ 7-1. USB0-DEVICE DMAÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL3¥ì¥¸¥¹¥¿¤ÎUSB_DEVICE_DMANRST¥Ó¥Ã¥È(bit12)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00001000, (void __iomem*)((u32)rst_ctrl+0x0C));
+
+	/*_ 7-2. USB1-DEVICE DMAÍÑ¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	/*_ RSTCTRL20¥ì¥¸¥¹¥¿¤ÎUSB_DEVICE_DMANRST¥Ó¥Ã¥È(bit4)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000010, (void __iomem*)((u32)rst_ctrl+0x80));
+
+	/*_ 8-1.  USB-DEVICEÍÑ¥¯¥í¥Ã¥¯¤ò²ò½ü _*/
+	/*_ CGCTRL3¥ì¥¸¥¹¥¿¤ÎUSBDCLKCG¥Ó¥Ã¥È(bit15)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00008000, (void __iomem*)((u32)usbd_clk+0x04));
+
+	/*_ 8-2.  USB-DEVICEÍÑ¥¯¥í¥Ã¥¯¤ò²ò½ü _*/
+	/*_ CGCTRL2¥ì¥¸¥¹¥¿¤ÎUSBDCLKCG¥Ó¥Ã¥È(bit6)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000040, (void __iomem*)((u32)usbd_clk));
+
+	/*_ 9. SDMAC¤Î¥ê¥»¥Ã¥È¤ò²ò½ü _*/
+	usb_ioset32(0x00000001, rst_ctrl);					/*_ RSTCTRL0¥ì¥¸¥¹¥¿¤ÎSTRMNRST¥Ó¥Ã¥È(bit0)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000001, (void __iomem*)(rst_ctrl+0x68));		/*_ RSTCTRL14¥ì¥¸¥¹¥¿¤ÎMCUSTMRS¥Ó¥Ã¥È(bit0)¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000080, (void __iomem*)((u32)usbd_clk+0x04));		/*_ CGCTRL3¥ì¥¸¥¹¥¿¤ÎSRTMCLKCG¥Ó¥Ã¥È(bit7)¤ò1¤ËÀßÄê _*/
+
+	usb_ioclear32(0x00000080, (void __iomem*)((u32)sdma_base+0x04));	/*_ IOBRESET¥ì¥¸¥¹¥¿  RST[7]¥Ó¥Ã¥È¤ò0¤ËÀßÄê _*/
+	usb_ioclear32(0x000001C0, (void __iomem*)((u32)sdma_base+0x0C));	/*_ IOBPERIRESET¥ì¥¸¥¹¥¿¤ÎA_RST(bit8)¡¢RST[7]¥Ó¥Ã¥È¡¢RST[6]¥Ó¥Ã¥È¤ò0¤ËÀßÄê _*/
+	usb_ioclear32(0x00000006, (void __iomem*)((u32)sdma_base+0x10));	/*_ IOBPERICLKSTOP¥ì¥¸¥¹¥¿¤ÎPDCLKSTP¥Ó¥Ã¥È(bit2)¡¢PDCLKSTP¥Ó¥Ã¥È(bit1)¤ò0¤ËÀßÄê _*/
+
+#if 0 /*_ debug _*/
+	{
+		u32 reg1,reg2,reg3;
+		reg1 = ioread32(rst_ctrl);
+		reg3 = ioread32((void __iomem*)((u32)rst_ctrl+0x0c));
+		DEBUG_PRINT("RSTCTRL0(0x%08x)=%08x\nRSTCTRL3(0x%08x)=%08x\n", (u32)rst_ctrl, reg1, ((u32)rst_ctrl+0x0c), reg3);
+
+		reg2 = ioread32(usbd_clk);
+		reg3 = ioread32((void __iomem*)((u32)usbd_clk+0x04));
+		DEBUG_PRINT("CGCTRL2(0x%08x)=%08x\nCGCTRL3(0x%08x)=%08x\n", (u32)usbd_clk, reg2, ((u32)usbd_clk+0x04), reg3);
+
+		reg1 = ioread32((void __iomem*)((u32)sdma_base+0x04));
+		reg2 = ioread32((void __iomem*)((u32)sdma_base+0x0c));
+		reg3 = ioread32((void __iomem*)((u32)sdma_base+0x10));
+		DEBUG_PRINT("IOBRESET(0x%08x)=%08x\nIOBPERIRESET(0x%08x)=%08x\nIOBPERICLKSTOP(0x%08x)=%08x\n", 
+				((u32)sdma_base+0x04), reg1, ((u32)sdma_base+0x0c), reg2, ((u32)sdma_base+0x10), reg3);
+	}
+#endif
+
+	/*_ 10.  1ms¥¦¥§¥¤¥È  (PHY PLL¡§È¯¿¶ÂÔ¤Á)¡£ _*/
+	mdelay(1);
+
+	iounmap(sdma_base);
+err_sdma:
+	iounmap(usbd_clk);
+err_dclk:
+	iounmap(rst_ctrl);
+err:
+	return ret;
+
+}
+
+/* when a driver is successfully registered, it will receive
+ * control requests including set_configuration(), which enables
+ * non-control requests.  then usb traffic follows until a
+ * disconnect is reported.  then a host may connect again, or
+ * the driver might get unbound.
+ */
+static int panasonic_start(struct usb_gadget *_gadget,
+		struct usb_gadget_driver *driver)
+{
+	struct panasonic_udc *dev;
+	unsigned i;
+	int ret;
+
+	DEBUG_PRINT( "%s: usb_gadget = %p\n", __FUNCTION__, _gadget );
+	
+
+	if (!driver || !driver->unbind || !driver->setup ||
+	    driver->max_speed < USB_SPEED_FULL)
+		return -EINVAL;
+
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+
+	if(strcmp(driver->function,dummy_name) == 0){
+		printk("%s: found dummy gadget driver\n",__FUNCTION__);
+		dev->driver = driver;
+		return 0;
+	}
+
+	for (i = 0; i < UDC_MAX_ENDPOINTS; ++i)
+		dev->ep[i].irqs = 0;
+	/* hook up the driver ... */
+	dev->softconnect = 1;
+	driver->driver.bus = NULL;
+	dev->driver = driver;
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	/*_ SDMAC ¼õ¿®ÍÑch¤Î½é´ü²½ _*/
+	ret = panasonic_sdmac_init(dev, dev->dma_out_ch, USB_SDMAC_PRI_LV5, USB_SDMAC_IRQ_WRITEDONE | USB_SDMAC_IRQ_TRSTOP);
+	if(ret != 0){
+		return -EINVAL;
+	}
+
+	/*_ SDMAC Á÷¿®ÍÑch¤Î½é´ü²½ _*/
+	ret = panasonic_sdmac_init(dev, dev->dma_in_ch, USB_SDMAC_PRI_LV5, USB_SDMAC_IRQ_TRSTOP);
+	if(ret != 0){
+		return -EINVAL;
+	}
+#endif
+
+	/* ... then enable host detection and ep0; and we're ready
+	 * for set_configuration as well as eventual disconnect.
+	 */
+	panasonic_ep0_start(dev);
+
+	dev_dbg(dev->dev, "%s ready\n", driver->driver.name);
+
+	return 0;
+}
+
+static void
+stop_activity(struct panasonic_udc *dev, struct usb_gadget_driver *driver)
+{
+	int i;
+
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	/* don't disconnect if it's not connected */
+	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
+		driver = NULL;
+
+	/* stop hardware; prevent new request submissions;
+	 * and kill any outstanding requests.
+	 */
+	panasonic_usb_reset(dev);
+	for (i = 0; i < UDC_MAX_ENDPOINTS; i++)
+		panasonic_dequeue_all(&dev->ep[i]);
+
+	/* report disconnect; the driver is already quiesced */
+	if (driver) {
+		spin_unlock(&dev->lock);
+		driver->disconnect(&dev->gadget);
+		spin_lock(&dev->lock);
+	}
+
+	panasonic_usb_reinit(dev);
+}
+
+
+static int
+panasonic_deactivate(void)
+{
+	void __iomem		*rst_ctrl, *usbd_clk, *sdma_base;
+	int ret = 0;
+
+	DEBUG_PRINT( "%s:\n", __FUNCTION__);
+
+	rst_ctrl = ioremap_nocache(0x9C010000, 0x100);
+	if(!rst_ctrl){
+		ERROR_PRINT( "%s: ioremap(0x9C010000) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err;
+	}
+
+	usbd_clk = ioremap_nocache(0x9C011010, 0x10);
+	if(!usbd_clk){
+		ERROR_PRINT( "%s: ioremap(0x9C011010) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err_clk;
+	}
+
+	sdma_base = ioremap_nocache(0x9C000000, 0x20);
+	if(!sdma_base){
+		ERROR_PRINT( "%s: ioremap(0x9C000000) fault\n", __FUNCTION__);
+		ret = -EFAULT;
+		goto err_sdma;
+	}
+
+#if 0	/*_  2014/11/7 T.B.D SDMA¤Î¥ê¥»¥Ã¥È Â¾¥â¥¸¥å¡¼¥ë¤ÇSDMAC¤¬»ÈÍÑÃæ¤Î¾ì¹ç¤Ï¥ê¥»¥Ã¥ÈÉÔ²Ä _*/
+	usb_ioset32(0x00000180, (void __iomem*)((u32)sdma_base+0x0C));		/*_ IOBPERIRESET¥ì¥¸¥¹¥¿¤ÎA_RST(bit8)¡¢RST[7]¥Ó¥Ã¥È¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000080, (void __iomem*)((u32)sdma_base+0x04));		/*_ IOBRESET¥ì¥¸¥¹¥¿  RST[7]¥Ó¥Ã¥È¤ò1¤ËÀßÄê _*/
+	usb_ioset32(0x00000002, (void __iomem*)((u32)sdma_base+0x10));		/*_ IOBPERICLKSTOP¥ì¥¸¥¹¥¿¤ÎPDCLKSTP¥Ó¥Ã¥È(bit1)¤ò1¤ËÀßÄê _*/
+
+	usb_ioclear32(0x00000001, rst_ctrl);								/*_ RSTCTRL0¥ì¥¸¥¹¥¿¤ÎSTRMNRST¥Ó¥Ã¥È(bit0)¤ò0¤ËÀßÄê _*/
+	usb_ioclear32(0x00000080, (void __iomem*)((u32)usbd_clk+0x04));		/*_ CGCTRL3¥ì¥¸¥¹¥¿¤ÎSRTMCLKCG¥Ó¥Ã¥È(bit7)¤ò0¤ËÀßÄê _*/
+#endif
+
+	/*_ USB0-DEVICE DMA¤ò¥ê¥»¥Ã¥È _*/
+	usb_ioclear32(0x00001000, (void __iomem*)((u32)rst_ctrl+0x0C));
+	
+	/*_ USB1-DEVICE DMA¤ò¥ê¥»¥Ã¥È _*/
+	usb_ioclear32(0x00000010, (void __iomem*)((u32)rst_ctrl+0x80));
+	
+	/*_ USB0-DEVICE¤ò¥ê¥»¥Ã¥È _*/
+	usb_ioclear32(0x00002000, rst_ctrl);
+	
+	/*_ USB1-DEVICE¤ò¥ê¥»¥Ã¥È _*/
+	usb_ioclear32(0x00000002, (void __iomem*)((u32)rst_ctrl+0x80));
+#if 0
+	/*_ USB0ÍÑÁ´ÂÎÀ©¸æÍÑ¥ì¥¸¥¹¥¿¤òÀßÄê _*/
+	/*_ USB_SEL¥ì¥¸¥¹¥¿¤ÇDPPULLDOWN¥Ó¥Ã¥È(bit2)¡¢DNPULLDOWN¥Ó¥Ã¥È(bit1)¡¢USB_SEL¥Ó¥Ã¥È(bit0)¤ò1¤ËÀßÄê _*/
+	/*_ move panasonic_pullup _*/
+
+	/*_ USB1ÍÑÁ´ÂÎÀ©¸æÍÑ¥ì¥¸¥¹¥¿¤òÀßÄê _*/
+	/*_ USB_SEL¥ì¥¸¥¹¥¿¤ÇDPPULLDOWN¥Ó¥Ã¥È(bit2)¡¢DNPULLDOWN¥Ó¥Ã¥È(bit1)¡¢USB_SEL¥Ó¥Ã¥È(bit0)¤ò1¤ËÀßÄê _*/
+	/*_ move panasonic_pullup _*/
+#endif
+	/*_ USB0-DEVICEÍÑ¥¯¥í¥Ã¥¯¤òÄä»ß _*/
+	usb_ioclear32(0x00008000, (void __iomem*)((u32)usbd_clk+0x04));
+	/*_ USB1-DEVICEÍÑ¥¯¥í¥Ã¥¯¤òÄä»ß _*/
+	usb_ioclear32(0x00000040, (void __iomem*)((u32)usbd_clk));
+	
+	iounmap(sdma_base);
+err_sdma:
+	iounmap(usbd_clk);
+err_clk:
+	iounmap(rst_ctrl);
+err:
+	return ret;
+
+}
+
+static int panasonic_stop(struct usb_gadget *_gadget,
+		struct usb_gadget_driver *driver)
+{
+	struct panasonic_udc *dev;
+	unsigned long flags;
+
+	dev = container_of(_gadget, struct panasonic_udc, gadget);
+
+	DEBUG_PRINT( "%s: _gadget %p, driver %p dev %p\n", __FUNCTION__, _gadget, driver, dev);
+
+	spin_lock_irqsave(&dev->lock, flags);
+	stop_activity(dev, driver);
+	spin_unlock_irqrestore(&dev->lock, flags);
+
+	dev->driver = NULL;
+
+	dev_dbg(dev->dev, "unregistered driver '%s'\n", (driver) ? driver->driver.name : "NULL");
+
+	return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+
+/*_ SDMA INÃæ»ß´°Î»³ä¤ê¹þ¤ß½èÍý¡£Àµ¾ï¤ÊÅ¾Á÷´°Î»¤Î¾ì¹ç¤Ï¡¢panasonic_dma_in¤Ç½èÍý¤¹¤ë _*/
+static void
+panasonic_handle_dma_in(struct panasonic_ep *ep)
+{
+	struct panasonic_udc *dev = ep->dev;
+	int sdmaid = dev->dma_in_ch;
+
+	if (unlikely((dev->dma_in_state & UDC_DMA_STATE_IP_SDMA) != UDC_DMA_STATE_IP_SDMA))
+		return;
+
+	usb_set_index(ep->dev, ep->num);
+
+	usb_write(dev, 0, EP_CONFIG2_REG );						/*_ DMA½ªÎ» _*/
+	usb_write(dev, 0 , DMA_FIFO1_CNT );						/*_ DMA½ªÎ» _*/
+	DMA_PRINT( "Cancel DMA write ep=%d\n", ep->num );
+
+	if(is_sdma_cancel(dev, sdmaid)){
+		sdmac_write(dev, 0x80000000 | 1 << sdmaid, USB_SDMAC_PARTRESET0);					/*_ [31]=1:¥ê¥»¥Ã¥ÈÍ×µá _*/
+	}
+
+	dev->dma_in_state = UDC_DMA_STATE_IDLE;
+
+}
+
+/*_ SDMA INÅ¾Á÷´°Î»»þ½èÍý _*/
+static void
+panasonic_dma_in(struct panasonic_ep *ep)
+{
+	struct panasonic_udc *dev = ep->dev;
+	struct panasonic_request *req;
+	u16 csr;
+	u32 time=0;
+	int status = -1;
+
+	if (unlikely((dev->dma_in_state & UDC_DMA_STATE_IP_SDMA) != UDC_DMA_STATE_IP_SDMA))
+		return;
+
+	usb_set_index(dev, ep->num);
+	csr = usb_read(dev, ep->csr);
+
+	if((csr & MCU_IN_PKT_RDY) == MCU_IN_PKT_RDY){
+		/*_ Host¤«¤éINÅ¾Á÷¤ò¼õ¿®¤·¤¿¤¬¥Ç¡¼¥¿¤¬FIFOÆâ¤Ë»Ä¤Ã¤Æ¤¤¤ë¡©BP3¤Ç¤½¤¦¤¤¤¦¥±¡¼¥¹¤¬¤¢¤Ã¤¿¤é¤·¤¤ _*/
+		ERROR_PRINT("%s:Received the last of IN transfer, but transfer is incomplete!!!",__FUNCTION__);
+		while( usb_read( dev, ep->csr ) & MCU_IN_PKT_RDY ){
+			ERROR_PRINT( "Wait csr 0x%04x:", usb_read( dev, ep->csr ) );
+			time++;
+			if( 1000 < time ){
+				ERROR_PRINT( "dma in transfer is time out!\n" );
+				return;	/*_ Reset¤Ç¤ÎÉüµ¢¤ò´üÂÔ¤¹¤ë¡£ _*/
+			}
+		}
+	}
+
+	usb_clear( dev, IPR_CLEAR, ep->csr );					/*_ Å¾Á÷´°Î»¥Ó¥Ã¥È¤òÍî¤È¤¹ _*/
+
+	usb_write(dev, 0, EP_CONFIG2_REG );						/*_ DMA½ªÎ» _*/
+	usb_write(dev, 0 , DMA_FIFO1_CNT );						/*_ DMA½ªÎ» _*/
+	DMA_PRINT( "END DMA write ep=%d\n", ep->num );
+
+	dev->dma_in_state = UDC_DMA_STATE_IDLE;
+
+	if (!list_empty(&ep->queue)){
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+	}else{
+		return;
+	}
+
+	DMA_PRINT( "IN done dma. dma_count=%d, DMA_FIFO1_STATUS=0x%04x csr = %x\n\n"
+		, (usb_read( dev, DMA_COUNT_H )<<16) + usb_read( dev, DMA_COUNT_L ), usb_read(dev, DMA_FIFO1_STATUS) , usb_read(dev, ep->csr));
+	
+	panasonic_done(ep, req, 0);
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+		status = panasonic_kick_dma(ep, req);
+		if (status < 0){
+			status = 0;
+			pio_irq_enable(dev, ep->num);
+			status = panasonic_write_fifo(ep, req);
+		}
+	}else{
+		pio_irq_disable(dev, ep->num);
+	}
+}
+
+static void
+panasonic_handle_dma_out(struct panasonic_ep *ep)
+{
+	struct panasonic_request *req;
+	struct panasonic_udc *dev = ep->dev;
+	u16 csr;
+	u32 count;
+	int status = -1;
+	int sdmaid = dev->dma_out_ch;
+
+	if (unlikely((dev->dma_out_state & UDC_DMA_STATE_IP_SDMA) != UDC_DMA_STATE_IP_SDMA))
+		return;
+
+	usb_set_index(dev, ep->num);
+
+	csr = usb_read(dev, ep->csr);
+	if((csr & SHORT_PACKET) == SHORT_PACKET) {
+#if 0	/*_ GerdaC 2015/1/14 usb_clear¤Ç¤ÏOPR¤ò¾Ãµî¤¹¤ë¤³¤È¤¬¤¢¤ë _*/
+		usb_clear( ep->dev, SHORT_PACKET, ep->csr );
+#else
+		csr &= ~SHORT_PACKET;
+		usb_write(dev, (csr | MCU_OUT_PKT_RDY), ep->csr);
+#endif
+	}
+
+	if(is_sdma_cancel(dev, sdmaid)){						/*_ SDMAÃæ»ßÍ×µá¡© _*/
+		dev_vdbg(dev->dev, "%s[%d]:stop dma ep=%d, dma_state = %x\n", __FUNCTION__, __LINE__,ep->num, dev->dma_out_state);
+
+		usb_write(dev, 0, EP_CONFIG2_REG );					/*_ DMA½ªÎ» _*/
+		usb_write(dev, 0 , DMA_FIFO0_CNT );					/*_ DMA½ªÎ» _*/
+
+		sdmac_write(dev, 0x80000000 | 1 << sdmaid, USB_SDMAC_PARTRESET0);					/*_ [31]=1:¥ê¥»¥Ã¥ÈÍ×µá _*/
+		dev->dma_out_state = UDC_DMA_STATE_IDLE;
+	}else{
+		dev->dma_out_state = UDC_DMA_STATE_IP_ONLY | ep->num;
+	}
+
+	if (!list_empty(&ep->queue)){
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+	}else{
+		return;
+	}
+
+	/*_ Å¾Á÷¥µ¥¤¥º¤òSDMA¤«¤é»»½Ð _*/
+	count = sdmac_read(dev, USB_SDMAC_CHnDSTSTRTADRS(sdmaid)) - (u32)req->req.dma;
+	req->req.actual += count;
+	dev_vdbg(dev->dev, "OUT done dma. sdma_count=%u, count=%d, byte_remain=%d, Out_write_count=%d\n", 
+				count, (usb_read(dev, DMA_FIFO0_STATUS) >> 8), (usb_read(dev, DMA_FIFO0_STATUS) >> 1) & 0x0001, usb_read(ep->dev, OUT_WRT_CNT_REG ));
+
+	panasonic_done(ep, req, 0);
+	if (!list_empty(&ep->queue)) {
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+		status = panasonic_kick_dma(ep, req);
+		if (status < 0){
+			status = 0;
+			usb_set_index(dev, ep->num);
+			csr = usb_read(dev, ep->csr);
+			if ((csr & MCU_OUT_PKT_RDY) == MCU_OUT_PKT_RDY){
+				status = panasonic_read_fifo(ep, req);
+			}
+			if(status == 0){
+				pio_irq_enable(dev, ep->num);
+			}
+		}
+	}
+}
+#endif /* CONFIG_USB_PANASONIC_ENABLE_DMA */
+/*---------------------------------------------------------------------------*/
+
+
+static void
+panasonic_handle_ep_in(struct panasonic_ep *ep)
+{
+	u32 csr;
+	struct panasonic_request *req;
+
+	usb_set_index(ep->dev, ep->num);
+	csr = usb_read(ep->dev, ep->csr);
+
+	DEBUG_PRINT( "%s: EP%d, csr %x, IPR = %d\n", __FUNCTION__, ep->num, csr, !!(csr & MCU_IN_PKT_RDY) );
+
+	if( csr & IN_SENT_STALL ){
+		DEBUG_PRINT("IN_SENT_STALL\n");
+		usb_clear( ep->dev, IN_SENT_STALL, ep->csr );
+	}
+
+	if( !ep->desc ){
+		DEBUG_PRINT( "%s: NO EP DESC\n", __FUNCTION__ );
+		return;
+	}
+
+	if (unlikely(list_empty(&ep->queue)))
+		return;
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	if( get_dma_state_ep(ep) == UDC_DMA_STATE_IP_SDMA) {
+		panasonic_dma_in(ep);
+	}else
+#endif
+	{
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+		if((csr & MCU_IN_PKT_RDY) == 0){
+			panasonic_write_fifo(ep, req);
+		}
+	}
+}
+
+static void
+panasonic_handle_ep_out(struct panasonic_ep *ep)
+{
+	u32 csr;
+	struct panasonic_request *req;
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	int state;
+#endif
+
+	usb_set_index(ep->dev, ep->num);
+	csr = usb_read(ep->dev, ep->csr);
+
+	dev_vdbg(ep->dev->dev, "%s: EP%d, csr %x OPR = %d, SPK=%d\n", __FUNCTION__, ep->num, csr, !!(csr & MCU_OUT_PKT_RDY) , !!(csr & SHORT_PACKET));
+
+	if( csr & OUT_SENT_STALL ){
+		DEBUG_PRINT("OUT_SENT_STALL\n");
+		usb_clear( ep->dev, OUT_SENT_STALL, ep->csr );
+	}
+
+	if( !ep->desc ){
+		DEBUG_PRINT( "%s: NO EP DESC\n", __FUNCTION__ );
+		return;
+	}
+
+	if (unlikely(list_empty(&ep->queue)))
+		return;
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	state = get_dma_state_ep(ep);
+	if(state == UDC_DMA_STATE_IP_SDMA){
+		if( (csr & SHORT_PACKET) == SHORT_PACKET ){
+			int ret;
+
+			ret = panasonic_sdmac_cancel(ep->dev, ep->dev->dma_out_ch);		/*_ sdmaÅ¾Á÷Ãæ»ßÍ×µá _*/
+			if(ret != 0){
+				ERROR_PRINT( "%s:Odd State!! dam_state = %x, CHnSTAT = %x\n" , __FUNCTION__
+					, ep->dev->dma_out_state, sdmac_read(ep->dev, USB_SDMAC_CHnSTAT(ep->dev->dma_out_ch)) );
+			}
+			/*_  2014/11/7 SDMA¤ÎÃæ»ß´°Î»³ä¤ê¹þ¤ß¤ÎÁ°¤Ë¼¡¤ÎOUTÅ¾Á÷¤ò½¦¤Ã¤Æ¤·¤Þ¤¦¤³¤È¤¬¤¢¤ë¡£ _*/
+			/*_ queue¤Î½çÈÖ¤¬¤º¤ì¤Æ¤·¤Þ¤¦¤Î¤Ç¡¢USB IP¤Î³ä¤ê¹þ¤ß¶Ø»ß¤¹¤ë _*/
+			pio_irq_disable(ep->dev, ep->num);
+			/*_ Â³¤­¤Ïpanasonic_irq_dma¤Ë¤Æ¼Â»Ü _*/
+		}else {
+			DEBUG_PRINT("EP%d:DMA mode, Ignore interrupt\n", ep->num);
+		}
+	}else if(state == UDC_DMA_STATE_IP_ONLY){
+		DEBUG_PRINT("EP%d:ShortPacket interrupt was received, but the dam_status is strange(%d)!!\n", ep->num, ep->dev->dma_out_state);
+	}else
+#endif
+	if((csr & MCU_OUT_PKT_RDY) == MCU_OUT_PKT_RDY){
+		req = list_entry(ep->queue.next, struct panasonic_request, queue);
+		panasonic_read_fifo(ep, req);
+	}
+
+}
+
+static void
+panasonic_handle_ep(struct panasonic_ep *ep)
+{
+	DEBUG_PRINT( "%s: EP%d\n", __FUNCTION__, ep->num );
+
+	pio_irq_clear(ep->dev, ep->num);
+	ep->irqs++;
+
+	if (ep->is_in)
+		panasonic_handle_ep_in(ep);
+	else
+		panasonic_handle_ep_out(ep);
+}
+
+
+static irqreturn_t panasonic_irq(int irq, void *_dev)
+{
+	struct panasonic_udc *dev = _dev;
+	u32 intr;
+	u32 en;
+	u8 num;
+
+	DEBUG_PRINT("\n\n");
+
+	spin_lock(&dev->lock);
+	/* Platform/devcice interrupt handler */
+	intr = usb_read(dev, IRQ_REG);
+	en = usb_read(dev, IRQ_ENA_REG);
+
+	DEBUG_PRINT("[i%04x,e%04x]",intr,en);
+	DEBUG_PRINT("%s: %p (on state %s)\n", __FUNCTION__, _dev, STATE_NAMES(dev->ep0state));
+
+	if( intr & RESET_INTERRUPT ){
+		DEBUG_PRINT("BUS RESET\n");
+		usb_write(dev, RESET_INTERRUPT, IRQ_REG);
+		stop_activity(dev, dev->driver);
+		panasonic_ep0_start(dev);
+	}
+	if( intr & RESUME_INTERRUPT ){
+		DEBUG_PRINT("USB resume\n");
+		usb_write(dev, RESUME_INTERRUPT, IRQ_REG);
+		if( dev->gadget.speed != USB_SPEED_UNKNOWN
+			&& dev->driver
+			&& dev->driver->resume ){
+			dev->driver->resume(&dev->gadget);
+		}
+	}
+	if( intr & SUSPEND_INTERRUPT ){
+		DEBUG_PRINT("USB suspend.\n" );
+		usb_write(dev, SUSPEND_INTERRUPT, IRQ_REG);
+		usb_gadget_set_state(&dev->gadget, USB_STATE_SUSPENDED);
+		if( dev->gadget.speed != USB_SPEED_UNKNOWN 
+			&& dev->driver 
+			&& dev->driver->suspend ){
+			dev->driver->suspend(&dev->gadget);
+		}
+	}
+	if( intr & VBUS_INTERRUPT ){
+		DEBUG_PRINT("USB vbus\n");
+		usb_write( dev, VBUS_INTERRUPT, IRQ_REG );
+	}
+
+	/* EP0 Interrupt */
+	if( en & intr & EP0_INTERRUPT ){
+		DEBUG_PRINT("USB_IN_INT_EP0 (control)\n");
+		usb_write(dev, EP0_INTERRUPT, IRQ_REG);
+		panasonic_udc_handle_ep0(dev, intr);
+	}
+
+	/* EPn Interrupt */
+	for (num = 1; num < UDC_MAX_ENDPOINTS; num++) {
+		struct panasonic_ep *ep;
+		u8 t;
+
+		/* does this endpoint's FIFO and queue need tending? */
+		t = 1 << num;
+		if ((en & intr & t) == 0)
+			continue;
+
+		DEBUG_PRINT("USB_INT_EP%d \n", num);
+
+		ep = &dev->ep[num];
+		panasonic_handle_ep(ep);
+	}
+
+	spin_unlock(&dev->lock);
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+static irqreturn_t panasonic_irq_dma(int irq, void *_dev)
+{
+	struct panasonic_udc *dev = _dev;
+	unsigned int sdmaid;
+	eSDMAC_IRQTYPE irqreg;
+
+	DEBUG_PRINT("\n\n");
+
+	spin_lock(&dev->lock);
+
+	sdmaid = dev->dma_out_ch;
+	irqreg = sdmac_read(dev, USB_SDMAC_CHnID(sdmaid));
+	if( (irqreg & USB_SDMAC_IRQ_WRITEDONE) == USB_SDMAC_IRQ_WRITEDONE )	/*_ OUTÊý¸þ¥é¥¤¥ÈDONE ¤Þ¤¿¤ÏÃæ»ßÍ×µá _*/
+	{
+		u8 i= dev->dma_out_state & UDC_DMA_EP_MASK;
+
+		DEBUG_PRINT("%s:EP%d OUT[i%08x]\n",__FUNCTION__, i, irqreg);
+
+		panasonic_handle_dma_out(&dev->ep[i]);
+
+		/*_ ¥Á¥ã¥Í¥ë³ä¹þ¤ßÍ×°ø¥ì¥¸¥¹¥¿¥¯¥ê¥¢ _*/
+		sdmac_set(dev, irqreg, USB_SDMAC_CHnIR(sdmaid));
+	}
+
+	sdmaid = dev->dma_in_ch;
+	irqreg = sdmac_read(dev, USB_SDMAC_CHnID(sdmaid));
+	if( (irqreg & USB_SDMAC_IRQ_TRSTOP) == USB_SDMAC_IRQ_TRSTOP )	/*_ Ãæ»ßÍ×µá _*/
+	{
+		u8 i= dev->dma_in_state & UDC_DMA_EP_MASK;
+
+		DEBUG_PRINT("%s:EP%d IN[i%08x]\n",__FUNCTION__, i, irqreg);
+		panasonic_handle_dma_in(&dev->ep[i]);
+
+		/*_ ¥Á¥ã¥Í¥ë³ä¹þ¤ßÍ×°ø¥ì¥¸¥¹¥¿¥¯¥ê¥¢ _*/
+		sdmac_set(dev, irqreg, USB_SDMAC_CHnIR(sdmaid));
+	}
+
+	spin_unlock(&dev->lock);
+
+	return IRQ_HANDLED;
+
+}
+#endif
+
+static void
+panasonic_gadget_release(struct device *_dev)
+{
+	struct panasonic_udc *dev = dev_get_drvdata(_dev);
+
+	DEBUG_PRINT( "%s: device = %p\n", __FUNCTION__, _dev );
+
+	kfree(dev);
+}
+
+/*---------------------------------------------------------------------------*/
+
+static void
+panasonic_remove(struct panasonic_udc *dev)
+{
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	usb_del_gadget_udc(&dev->gadget);
+
+	/* start with the driver above us */
+	if (dev->driver) {
+		/* should have been done already by driver model core */
+		dev_warn(dev->dev, "pci remove, driver '%s' is still registered\n",
+			dev->driver->driver.name);
+		usb_gadget_unregister_driver(dev->driver);
+	}
+
+	(void)panasonic_deactivate();
+
+	free_irq(dev->usb_irq, dev);
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	free_irq(dev->dma_out_irq, dev);
+	free_irq(dev->dma_in_irq, dev);
+#endif
+
+	iounmap(dev->base_addr);
+
+#if 0	/*_  2014/10/16 T.B.D registers_showÍÑ¡£°ìÃ¶ºï½ü _*/
+	device_remove_file(dev->dev, &dev_attr_registers);
+#endif
+	dev_info(dev->dev, "unbind\n");
+}
+
+static struct panasonic_udc *panasonic_probe_init(struct device *dev, unsigned int irq)
+{
+	struct panasonic_udc *ret;
+
+	DEBUG_PRINT( "%s: device = %p\n", __FUNCTION__, dev );
+
+	if (!irq) {
+		dev_dbg(dev, "No IRQ!\n");
+		return ERR_PTR(-ENODEV);
+	}
+
+	/* alloc, and start init */
+	ret = kzalloc(sizeof(*ret), GFP_KERNEL);
+	if (!ret)
+		return ERR_PTR(-ENOMEM);
+
+	if (panasonic_deactivate() != 0){
+		kfree(ret);
+		return ERR_PTR(-EFAULT);
+	}
+
+	spin_lock_init(&ret->lock);
+	ret->usb_irq = irq;
+	ret->dev = dev;
+	ret->is_selfpowered = 1; 	/* Self Powered */
+	ret->gadget.ops = &panasonic_ops;
+	ret->gadget.max_speed = USB_SPEED_HIGH;
+
+	/* the "gadget" abstracts/virtualizes the controller */
+	ret->gadget.name = driver_name;
+
+	return ret;
+}
+
+static int
+panasonic_probe_fin(struct panasonic_udc *dev, unsigned int irqflags)
+{
+	int ret;
+
+	DEBUG_PRINT( "%s: panasonic_udc = %p\n", __FUNCTION__, dev );
+
+	//panasonic_deactivate();	/*_  2014/11/7 panasonic_probe_init´Ø¿ô¤Ø°ÜÆ° _*/
+
+	ret = panasonic_activate();
+	if(ret != 0){
+		ERROR_PRINT( "%s: panasonic_activate fail ret =%d\n", __FUNCTION__,ret );
+		goto err;
+	}
+
+	panasonic_usb_reset(dev);
+	panasonic_usb_reinit(dev);
+
+	ret = request_irq(dev->usb_irq, panasonic_irq, irqflags, driver_name, dev);
+	if (ret) {
+		dev_err(dev->dev, "request interrupt %i failed\n", dev->usb_irq);
+		goto err;
+	}
+
+	/* done */
+	dev_info(dev->dev, "%s\n", driver_desc);
+	dev_info(dev->dev, "usb_irq %i, mem %p, %s\n",
+		dev->usb_irq, dev->base_addr, (use_dma) ? "DMA":"PIO");
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	if(use_dma !=0)
+	{
+		dev_info(dev->dev, "dma_irq_out %i, dma_irq_in %i\n",
+			dev->dma_out_irq, dev->dma_in_irq);
+	}
+#endif	/* CONFIG_USB_PANASONIC_ENABLE_DMA */
+	dev_info(dev->dev, "version: %s\n", driver_vers);
+
+#if 0	/*_  2014/10/16 T.B.D registers_showÍÑ¡£°ìÃ¶ºï½ü _*/
+	ret = device_create_file(dev->dev, &dev_attr_registers);
+	if (ret)
+		goto err_irq;
+#endif
+	ret = usb_add_gadget_udc_release(dev->dev, &dev->gadget,
+			panasonic_gadget_release);
+	if (ret)
+		goto err_add_udc;
+
+	return 0;
+
+ err_add_udc:
+#if 0	/*_  2014/10/16 T.B.D registers_showÍÑ¡£°ìÃ¶ºï½ü _*/
+	device_remove_file(dev->dev, &dev_attr_registers);
+ err_irq:
+#endif
+	free_irq(dev->usb_irq, dev);
+ err:
+	return ret;
+}
+
+/*---------------------------------------------------------------------------*/
+
+static int
+panasonic_plat_probe(struct platform_device *pdev)
+{
+	struct panasonic_udc *dev;
+	int ret;
+	unsigned int irqflags;
+	resource_size_t base, len;
+	struct resource *iomem, *iomem_usbtop, *irq_res;
+	resource_size_t base_usbtop, len_usbtop;
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	resource_size_t base_sdmac, len_sdmac;
+	struct resource *iomem_sdmac, *irq_res_sdmac_out, *irq_res_sdmac_in;
+#endif
+
+	DEBUG_PRINT( "%s: platform_device = %p\n", __FUNCTION__, pdev );
+
+	irq_res = platform_get_resource(pdev, IORESOURCE_IRQ, USB_RES_DEVICE_IRQ);
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, USB_RES_IP_MEM);
+	iomem_usbtop = platform_get_resource(pdev, IORESOURCE_MEM, USB_RES_USBTOP_MEM);
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	irq_res_sdmac_out = platform_get_resource(pdev, IORESOURCE_IRQ, USB_RES_SDMAC_IRQ_RX);
+	irq_res_sdmac_in = platform_get_resource(pdev, IORESOURCE_IRQ, USB_RES_SDMAC_IRQ_TX);
+	iomem_sdmac = platform_get_resource(pdev, IORESOURCE_MEM, USB_RES_SDMAC_MEM);
+	if (!irq_res || !iomem || !iomem_usbtop || !irq_res_sdmac_out || !irq_res_sdmac_in || !iomem_sdmac) {
+#else
+	if (!irq_res || !iomem || !iomem_usbtop) {
+#endif
+		dev_err(&pdev->dev, "must provide irq/base addr");
+		return -EINVAL;
+	}
+
+	dev = panasonic_probe_init(&pdev->dev, irq_res->start);
+	if (IS_ERR(dev))
+		return PTR_ERR(dev);
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	dev->dma_out_ch = SDMAC_RX_CH(pdev->id);
+	dev->dma_out_irq = irq_res_sdmac_out->start;
+
+	dev->dma_in_ch = SDMAC_TX_CH(pdev->id);
+	dev->dma_in_irq = irq_res_sdmac_in->start;
+#endif
+
+#define GET_IRQFLAGS(r, f)							\
+	f = 0;											\
+	if ((r)->flags & IORESOURCE_IRQ_HIGHEDGE)		\
+		(f) |= IRQF_TRIGGER_RISING;					\
+	if ((r)->flags & IORESOURCE_IRQ_LOWEDGE)		\
+		(f) |= IRQF_TRIGGER_FALLING;				\
+	if ((r)->flags & IORESOURCE_IRQ_HIGHLEVEL)		\
+		(f) |= IRQF_TRIGGER_HIGH;					\
+	if ((r)->flags & IORESOURCE_IRQ_LOWLEVEL)		\
+		(f) |= IRQF_TRIGGER_LOW;
+
+	GET_IRQFLAGS(irq_res, irqflags);
+
+	base = iomem->start;
+	len = resource_size(iomem);
+
+	if (!request_mem_region(base, len, driver_name)) {
+		dev_dbg(dev->dev, "get request memory region!\n");
+		ret = -EBUSY;
+		goto err;
+	}
+	dev->base_addr = ioremap_nocache(base, len);
+	if (!dev->base_addr) {
+		dev_dbg(dev->dev, "can't map memory\n");
+		ret = -EFAULT;
+		goto err_req;
+	}
+
+	DEBUG_PRINT( "%s: dev->base_addr = %p\n", __FUNCTION__, dev->base_addr );
+		
+	base_usbtop = iomem_usbtop->start;
+	len_usbtop = resource_size(iomem_usbtop);
+
+	dev->usbtop_base_addr = ioremap_nocache(base_usbtop, len_usbtop);
+	if (!dev->usbtop_base_addr) {
+		dev_dbg(dev->dev, "can't map memory\n");
+		ret = -EFAULT;
+		goto err_io_ip;
+	}
+		
+	DEBUG_PRINT( "%s: dev->usbtop_base_addr = %p\n", __FUNCTION__, dev->usbtop_base_addr );
+
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	base_sdmac = iomem_sdmac->start;
+	len_sdmac = resource_size(iomem_sdmac);
+
+	/*_  2014/10/27 sdma¤ÏÂ¾¥â¥¸¥å¡¼¥ë¤Ç¤âmapping¤¹¤ë¤¿¤árequest_mem_region¤ò¹Ô¤ï¤Ê¤¤ _*/
+	dev->sdmac_base_addr = ioremap_nocache(base_sdmac, len_sdmac);
+	if (!dev->sdmac_base_addr) {
+		dev_dbg(dev->dev, "can't map memory\n");
+		ret = -EFAULT;
+		goto err_io_top;
+	}
+
+	DEBUG_PRINT( "%s: dev->sdmac_base_addr = %p\n", __FUNCTION__, dev->sdmac_base_addr );
+#endif
+
+	ret = panasonic_probe_fin(dev, irqflags);
+	if (ret)
+		goto err_io;
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	GET_IRQFLAGS(irq_res_sdmac_out, irqflags);
+	ret = request_irq(dev->dma_out_irq, panasonic_irq_dma, irqflags, driver_name, dev);
+	if (ret) {
+		free_irq(dev->usb_irq, dev);
+		dev_err(dev->dev, "request interrupt %i failed\n", dev->dma_out_irq);
+		goto err_io;
+	}
+
+	GET_IRQFLAGS(irq_res_sdmac_in, irqflags);
+	ret = request_irq(dev->dma_in_irq, panasonic_irq_dma, irqflags, driver_name, dev);
+	if (ret) {
+		free_irq(dev->usb_irq, dev);
+		free_irq(dev->dma_out_irq, dev);
+		dev_err(dev->dev, "request interrupt %i failed\n", dev->dma_in_irq);
+		goto err_io;
+	}
+#endif	/* CONFIG_USB_PANASONIC_ENABLE_DMA */
+
+	platform_set_drvdata(pdev, dev);
+
+	return 0;
+
+ err_io:
+#ifdef CONFIG_USB_PANASONIC_ENABLE_DMA
+	iounmap(dev->sdmac_base_addr);
+ err_io_top:
+#endif
+	iounmap(dev->usbtop_base_addr);
+ err_io_ip:
+	iounmap(dev->base_addr);
+ err_req:
+	release_mem_region(base, len);
+ err:
+	return ret;
+}
+
+static int
+panasonic_plat_remove(struct platform_device *pdev)
+{
+	struct panasonic_udc *dev = platform_get_drvdata(pdev);
+
+	DEBUG_PRINT( "%s: platform_device = %p\n", __FUNCTION__, pdev );
+
+	panasonic_remove(dev);
+
+	release_mem_region(pdev->resource[0].start,
+		resource_size(&pdev->resource[0]));
+
+	kfree(dev);
+
+	return 0;
+}
+
+#define DEVICE_NUM	ARRAY_SIZE( device_res )
+static struct platform_device *panasonic_udc_device[DEVICE_NUM];
+
+static struct platform_driver panasonic_plat_driver = {
+	.probe   = panasonic_plat_probe,
+	.remove  = panasonic_plat_remove,
+	.driver  = {
+		.name  = driver_name,
+		.owner = THIS_MODULE,
+	},
+	/* FIXME .suspend, .resume */
+};
+MODULE_ALIAS("platform:panasonic");
+
+static int __init panasonic_init(void)
+{
+	int ret;
+	int i, isSomeone;
+
+	DEBUG_PRINT( "%s:driver=%p\n", __FUNCTION__, &panasonic_plat_driver);
+
+	ret = -1;
+	isSomeone=0;
+	for( i=0 ; i < DEVICE_NUM ; i++ ){
+		
+		panasonic_udc_device[i] = platform_device_register_simple( driver_name, i, (struct resource*)device_res[i] , ARRAY_SIZE(device_res[i]));
+		if( IS_ERR(panasonic_udc_device[i]) ){
+			ERROR_PRINT( "platform_device_register_simple() failed.\n" );
+			panasonic_udc_device[i] = NULL;
+			continue;
+		}
+		isSomeone=1;
+	}
+	
+	if( isSomeone ){
+		ret = platform_driver_register(&panasonic_plat_driver);
+		if( ret ){
+			ERROR_PRINT( "platform_driver_register() failed.\n" );
+			for( i=0 ; i < DEVICE_NUM ; i++ ){
+				if( panasonic_udc_device[i] == NULL ) continue;
+				platform_device_unregister( panasonic_udc_device[i] );
+				panasonic_udc_device[i] = NULL;
+		}
+		}
+	}
+	
+	return ret;
+}
+module_init(panasonic_init);
+
+static void __exit panasonic_cleanup(void)
+{
+	int i;
+	DEBUG_PRINT( "%s:\n", __FUNCTION__);
+	
+	for( i=0 ; i < DEVICE_NUM ; i++ ){
+		if( panasonic_udc_device[i] == NULL ) continue;
+		platform_device_unregister( panasonic_udc_device[i] );
+		panasonic_udc_device[i] = NULL;
+	}
+	platform_driver_unregister(&panasonic_plat_driver);
+}
+module_exit(panasonic_cleanup);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR("Panasonic.");
+MODULE_LICENSE("GPL");
diff -uNr linux-3.14.19/drivers/usb/gadget/u_iap2.h linux-gerda/drivers/usb/gadget/u_iap2.h
--- linux-3.14.19/drivers/usb/gadget/u_iap2.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/u_iap2.h	2017-06-22 09:52:55.367039174 +0900
@@ -0,0 +1,16 @@
+/*
+ * u_iap2.h
+ *
+ * Copyright (C) 2015 Panasonic
+ */
+
+#ifndef __U_IAP2_H
+#define __U_IAP2_H
+
+#include <linux/usb/composite.h>
+
+struct f_iap2_opts {
+	struct usb_function_instance func_inst;
+};
+
+#endif /* __U_IAP2_H */
diff -uNr linux-3.14.19/drivers/usb/gadget/udc-core.c linux-gerda/drivers/usb/gadget/udc-core.c
--- linux-3.14.19/drivers/usb/gadget/udc-core.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/gadget/udc-core.c	2017-06-22 09:52:55.367039174 +0900
@@ -28,6 +28,10 @@
 #include <linux/usb/ch9.h>
 #include <linux/usb/gadget.h>
 
+#if 1
+//#include <linux/kobject.h>
+#endif
+
 /**
  * struct usb_udc - describes one usb device controller
  * @driver - the gadget driver pointer. For use by the class code
@@ -106,9 +110,34 @@
 
 /* ------------------------------------------------------------------------- */
 
+enum usb_device_state old_gadget_state = USB_STATE_NOTATTACHED; 
 static void usb_gadget_state_work(struct work_struct *work)
 {
 	struct usb_gadget	*gadget = work_to_gadget(work);
+#if 1	
+	/* inform user space if state is changed,
+	   do NOT implement this in usb_gadget_set_state()
+	   whichi maybe called from interrupt context */
+	if (old_gadget_state != gadget->state){
+		int found = 0;
+		struct usb_udc		*udc = NULL;
+		mutex_lock(&udc_lock);
+		list_for_each_entry(udc, &udc_list, list)
+			if (udc->gadget == gadget){
+				found = 1;
+				break;
+			}
+		mutex_unlock(&udc_lock);
+
+		if (found){
+			printk("%s: state change: %s -> %s\n",__func__,
+				usb_state_string(old_gadget_state),usb_state_string(gadget->state));
+			kobject_uevent(&udc->dev.kobj,KOBJ_CHANGE);
+		}
+
+		old_gadget_state = gadget->state;
+	}
+#endif
 
 	sysfs_notify(&gadget->dev.kobj, NULL, "state");
 }
@@ -116,7 +145,9 @@
 void usb_gadget_set_state(struct usb_gadget *gadget,
 		enum usb_device_state state)
 {
+
 	gadget->state = state;
+
 	schedule_work(&gadget->work);
 }
 EXPORT_SYMBOL_GPL(usb_gadget_set_state);
@@ -546,6 +577,15 @@
 		return ret;
 	}
 
+#if 1
+	/* for application to recongnize the port number */
+	ret = add_uevent_var(env, "USB_UDC_DEV_NAME=%s", dev_name(dev));
+	if (ret) {
+		dev_err(dev, "failed to add uevent dev_name\n");
+		return ret;
+	}
+#endif
+
 	if (udc->driver) {
 		ret = add_uevent_var(env, "USB_UDC_DRIVER=%s",
 				udc->driver->function);
diff -uNr linux-3.14.19/drivers/usb/host/ehci-hcd.c linux-gerda/drivers/usb/host/ehci-hcd.c
--- linux-3.14.19/drivers/usb/host/ehci-hcd.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-hcd.c	2017-06-22 09:52:55.771039162 +0900
@@ -4,6 +4,7 @@
  * Maintainer: Alan Stern <stern@rowland.harvard.edu>
  *
  * Copyright (c) 2000-2004 by David Brownell
+ * Copyright (C) 2015, Panasonic Corporation
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -48,6 +49,10 @@
 #if defined(CONFIG_PPC_PS3)
 #include <asm/firmware.h>
 #endif
+#ifdef CONFIG_USB_PANASONIC_HOST	/*_ GerdaC 2014/12/24 _*/
+#include "ehci-panasonic.h"
+#include "../core/usb-panasonic.h"	/* for USBH_DDVERSION */
+#endif
 
 /*-------------------------------------------------------------------------*/
 
@@ -85,8 +90,11 @@
  * code).  In an attempt to avoid trouble, we will use a minimum scheduling
  * length of 512 frames instead of 256.
  */
+#ifdef CONFIG_USB_PANASONIC_HOST		/*_ GerdaC 2015/1/13 _*/
+#define	EHCI_TUNE_FLS		2	/* (small) 256-frame schedule */
+#else
 #define	EHCI_TUNE_FLS		1	/* (medium) 512-frame schedule */
-
+#endif
 /* Initial IRQ latency:  faster than hw default */
 static int log2_irq_thresh = 0;		// 0 to 6
 module_param (log2_irq_thresh, int, S_IRUGO);
@@ -629,11 +637,21 @@
 	ehci->last_periodic_enable = ktime_get_real();
 
 	temp = HC_VERSION(ehci, ehci_readl(ehci, &ehci->caps->hc_capbase));
+
+/*_ @LINUXHOST:V0204nx[11/05/25] ãƒ‰ãƒ©ã‚¤ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±è¿½åŠ  _*//*_ GerdaC 2015/1/5 _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+	ehci_info (ehci,
+		"USB %x.%x started, EHCI %x.%02x(v%04x)%s\n",
+		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
+		temp >> 8, temp & 0xff,USBH_DDVERSION,
+		ignore_oc ? ", overcurrent ignored" : "");
+#else
 	ehci_info (ehci,
 		"USB %x.%x started, EHCI %x.%02x%s\n",
 		((ehci->sbrn & 0xf0)>>4), (ehci->sbrn & 0x0f),
 		temp >> 8, temp & 0xff,
 		ignore_oc ? ", overcurrent ignored" : "");
+#endif
 
 	ehci_writel(ehci, INTR_MASK,
 		    &ehci->regs->intr_enable); /* Turn On Interrupts */
@@ -1300,7 +1318,19 @@
 #define	PLATFORM_DRIVER		ehci_hcd_sead3_driver
 #endif
 
+#ifdef CONFIG_USB_PANASONIC_HOST	/*_ GerdaC 2014/12/24 _*/
+#include "ehci-panasonic.c"
+#define	PLATFORM_DEVICE_INIT	panasonic_ehci_device_init
+#define PLATFORM_DEVICE_EXIT	panasonic_ehci_device_exit
+#define	PLATFORM_DRIVER			panasonic_ehci_driver
+#endif
+
+/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ›ã‚¹ãƒˆåˆæœŸåŒ–/çµ‚äº†å¤–éƒ¨å…¬é–‹å¯¾å¿œ _*//*_ GerdaC 2015/1/8 _*/
+#ifdef CONFIG_USB_PANASONIC_EHCI_EXPORT
+int ehci_hcd_init(void)
+#else
 static int __init ehci_hcd_init(void)
+#endif
 {
 	int retval = 0;
 
@@ -1328,7 +1358,13 @@
 #endif
 
 #ifdef PLATFORM_DRIVER
+#ifdef PLATFORM_DEVICE_INIT	/*_ GerdaC 2015/1/5 _*/
+	if( PLATFORM_DEVICE_INIT() < 0 ) goto clean0;
+#endif
 	retval = platform_driver_register(&PLATFORM_DRIVER);
+#ifdef PLATFORM_DEVICE_EXIT	/*_ GerdaC 2015/1/5 _*/
+	if (retval < 0) PLATFORM_DEVICE_EXIT();
+#endif
 	if (retval < 0)
 		goto clean0;
 #endif
@@ -1377,8 +1413,14 @@
 	return retval;
 }
 module_init(ehci_hcd_init);
+EXPORT_SYMBOL(ehci_hcd_init);	/*_ GerdaC 2015/1/5 _*/
 
+/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ›ã‚¹ãƒˆåˆæœŸåŒ–/çµ‚äº†å¤–éƒ¨å…¬é–‹å¯¾å¿œ _*//*_ GerdaC 2015/1/8 _*/
+#ifdef CONFIG_USB_PANASONIC_EHCI_EXPORT
+void ehci_hcd_cleanup(void)
+#else
 static void __exit ehci_hcd_cleanup(void)
+#endif
 {
 #ifdef XILINX_OF_PLATFORM_DRIVER
 	platform_driver_unregister(&XILINX_OF_PLATFORM_DRIVER);
@@ -1389,6 +1431,9 @@
 #ifdef PLATFORM_DRIVER
 	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
+#ifdef PLATFORM_DEVICE_EXIT	/*_ GerdaC 2015/1/5 _*/
+	PLATFORM_DEVICE_EXIT();
+#endif
 #ifdef PS3_SYSTEM_BUS_DRIVER
 	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
 #endif
@@ -1398,3 +1443,4 @@
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
+EXPORT_SYMBOL(ehci_hcd_cleanup);	/*_ GerdaC 2015/1/8 _*/
diff -uNr linux-3.14.19/drivers/usb/host/ehci-hub.c linux-gerda/drivers/usb/host/ehci-hub.c
--- linux-3.14.19/drivers/usb/host/ehci-hub.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-hub.c	2017-06-22 09:52:55.931039158 +0900
@@ -781,6 +781,18 @@
 	usb_get_urb(urb);
 	atomic_inc(&urb->use_count);
 	atomic_inc(&urb->dev->urbnum);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	urb->setup_dma = dma_map_single_local(
+			hcd->self.controller,
+			urb->setup_packet,
+			sizeof(struct usb_ctrlrequest),
+			DMA_TO_DEVICE);
+	urb->transfer_dma = dma_map_single_local(
+			hcd->self.controller,
+			urb->transfer_buffer,
+			urb->transfer_buffer_length,
+			DMA_FROM_DEVICE);
+#else
 	urb->setup_dma = dma_map_single(
 			hcd->self.controller,
 			urb->setup_packet,
@@ -791,6 +803,7 @@
 			urb->transfer_buffer,
 			urb->transfer_buffer_length,
 			DMA_FROM_DEVICE);
+#endif
 	urb->context = done;
 	return urb;
 }
@@ -918,7 +931,12 @@
 
 		switch (wValue) {
 		case USB_PORT_FEAT_ENABLE:
+/*_ @LINUXHOST:V0204nx[11/05/25] ãƒãƒ¼ãƒˆå¤‰åŒ–è¦å› ãŒã‚¯ãƒªã‚¢ã•ã‚Œã‚‹å•é¡Œã«å¯¾å¿œ _*//*_ GerdaC 2015/1/6 _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+			ehci_writel(ehci, temp & ~(PORT_PE | PORT_RWC_BITS), status_reg);
+#else
 			ehci_writel(ehci, temp & ~PORT_PE, status_reg);
+#endif
 			break;
 		case USB_PORT_FEAT_C_ENABLE:
 			ehci_writel(ehci, temp | PORT_PEC, status_reg);
@@ -961,9 +979,20 @@
 			clear_bit(wIndex, &ehci->port_c_suspend);
 			break;
 		case USB_PORT_FEAT_POWER:
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS	/*_ GPIOã«ã‚ˆã‚‹Vbusåˆ¶å¾¡ã‚’ãƒ«ãƒ¼ãƒˆãƒãƒ–å‡¦ç†ã«å®Ÿè£… _*/
+			if (HCS_PPC (ehci->hcs_params)) {
+				unsigned long int val0;
+				val0 = readl(hcd->gpio_regs);
+				val0 &= _REG_GPODATA[USB_ADDR_TO_CH(hcd->rsrc_start)][1];
+				writel(val0, hcd->gpio_regs);
+			}
+				ehci_writel(ehci, temp & ~PORT_POWER,
+						status_reg);
+#else   /* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci, temp & ~PORT_POWER,
 						status_reg);
+#endif	/* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
 			break;
 		case USB_PORT_FEAT_C_CONNECTION:
 			ehci_writel(ehci, temp | PORT_CSC, status_reg);
@@ -1196,10 +1225,23 @@
 			set_bit(wIndex, &ehci->suspended_ports);
 			break;
 		case USB_PORT_FEAT_POWER:
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS	/*_ GPIOã«ã‚ˆã‚‹Vbusåˆ¶å¾¡ã‚’ãƒ«ãƒ¼ãƒˆãƒãƒ–å‡¦ç†ã«å®Ÿè£… _*/
+			if (HCS_PPC (ehci->hcs_params))
+				ehci_writel(ehci, temp | PORT_POWER,
+						status_reg);
+
+			unsigned long int val0;
+			val0 = readl(hcd->gpio_regs);
+			val0 &= _REG_GPODATA[USB_ADDR_TO_CH(hcd->rsrc_start)][1];
+			val0 |= _REG_GPODATA[USB_ADDR_TO_CH(hcd->rsrc_start)][2];
+			writel(val0, hcd->gpio_regs);
+			break;
+#else   /* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
 			if (HCS_PPC (ehci->hcs_params))
 				ehci_writel(ehci, temp | PORT_POWER,
 						status_reg);
 			break;
+#endif	/* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
 		case USB_PORT_FEAT_RESET:
 			if (temp & (PORT_SUSPEND|PORT_RESUME))
 				goto error;
diff -uNr linux-3.14.19/drivers/usb/host/ehci-intrmem.c linux-gerda/drivers/usb/host/ehci-intrmem.c
--- linux-3.14.19/drivers/usb/host/ehci-intrmem.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-intrmem.c	2017-06-22 09:52:55.931039158 +0900
@@ -0,0 +1,205 @@
+/*
+ * Copyright (C) 2010, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+#define INTERMEM_CONFIG_NUM	ARRAY_SIZE( intermem_configuration )
+
+typedef struct _INTERMEM_GROUP{
+	const INTERMEM_CONFIG* nodeConfig;	/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã®è¨­å®š _*/
+	u8*		topAddress;					/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã§æ‰±ã†ãƒ¡ãƒ¢ãƒªã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹(CPUç”¨) _*/
+	u8*		topAddress_dma;				/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã§æ‰±ã†ãƒ¡ãƒ¢ãƒªã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹(DMAç”¨) _*/
+	u8*		bottomAddress;				/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã§æ‰±ã†ãƒ¡ãƒ¢ãƒªã®æœ€å¾Œå°¾ã‚¢ãƒ‰ãƒ¬ã‚¹(CPUç”¨) _*/
+	
+	int		waitingNum;					/*_ ä»•äº‹å¾…ã¡ãƒŽãƒ¼ãƒ‰ã®æ•° _*/
+	int*	waitingStack;				/*_ ä»•äº‹å¾…ã¡ã‚¹ã‚¿ãƒƒã‚¯ _*/
+	
+	u8*		workingCheckTable;			/*_ ä»•äº‹ä¸­ç®¡ç†ãƒ†ãƒ¼ãƒ–ãƒ« _*/
+} INTERMEM_GROUP;
+
+typedef struct _INTERMEM_TOP{
+	INTERMEM_GROUP	groups[INTERMEM_CONFIG_NUM];	/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã®å®Ÿä½“ _*/
+	u8*				topAddress;						/*_ INTERMEMå†…ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹(CPUç”¨) _*/
+	spinlock_t		lock;
+} INTERMEM_TOP;
+
+#define INTERMEM_LOCK( EHCI )										\
+	{	unsigned long lockflags;									\
+		spin_lock_irqsave( &(EHCI)->intermem->lock, lockflags );
+
+#define INTERMEM_UNLOCK( EHCI )											\
+		spin_unlock_irqrestore( &(EHCI)->intermem->lock, lockflags );	\
+	}
+
+
+/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è§£æ”¾ã™ã‚‹ _*/
+static inline void freeGroups( INTERMEM_GROUP* gr )
+{
+	int i;
+	
+	if( !gr ) return;
+	
+	for( i=0 ; i < INTERMEM_CONFIG_NUM ; i++ ){
+		if( gr[i].waitingStack )		kfree( gr[i].waitingStack );
+		if( gr[i].workingCheckTable )	kfree( gr[i].workingCheckTable );
+	}
+}
+
+/*_ ãƒ—ãƒ¼ãƒ«ã‚’é–‹æ”¾ã™ã‚‹ _*/
+static void usbh_sharemem_finish( struct ehci_hcd *ehci )
+{
+	INTERMEM_TOP* top;
+	
+	top = ehci->intermem;
+	if( !top ) return;
+	ehci->intermem = NULL;
+	
+/*_ @LINUXHOST:V0302nx[11/11/11] IOREMAPã‚’ã‚³ãƒ³ãƒ•ã‚£ã‚°ã§é¸æŠžã§ãã‚‹ã‚ˆã†ã«å¤‰æ›´ _*/
+#ifdef CONFIG_USB_PANASONIC_EHCI_IOREMAP
+	iounmap( top->topAddress );
+#endif
+	freeGroups( top->groups );
+	kfree( top );
+}
+
+
+/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç¢ºä¿ã™ã‚‹ _*/
+static inline int allocateGroups( INTERMEM_GROUP* gr, u8* address, u8* dma )
+{
+	size_t usedBufferSize;
+	int i, j, num;
+	
+	usedBufferSize = 0;
+	
+	for( i=0 ; i < INTERMEM_CONFIG_NUM ; i++, gr++ ){
+		gr->nodeConfig = &intermem_configuration[i];
+		num = gr->nodeConfig->num;
+		gr->topAddress =		address	+ usedBufferSize;
+		gr->topAddress_dma =	dma		+ usedBufferSize;
+		usedBufferSize +=		num * gr->nodeConfig->size;
+		gr->bottomAddress =		address	+ usedBufferSize -1;
+		if( INTERMEM_SIZE < usedBufferSize )
+			return -1;
+		
+		gr->waitingStack = kzalloc( sizeof(int) * num, GFP_ATOMIC );
+		if( !gr->waitingStack ) return -1;
+		
+		gr->workingCheckTable = kzalloc( sizeof(u8) * num, GFP_ATOMIC );
+		if( !gr->workingCheckTable ) return -1;
+		
+		/*_ åˆæœŸQueã‚’è¨­å®š _*/
+		gr->waitingNum = num;
+		for( j=0 ; j < num ; j++ ) gr->waitingStack[j] = num -j -1;
+	}
+	return 0;
+}
+
+/*_ ãƒ—ãƒ¼ãƒ«ã‚’ç¢ºä¿ã—ã€åˆæœŸåŒ–ã‚’è¡Œã† _*/
+static int usbh_sharemem_init( struct ehci_hcd *ehci )
+{
+	u8* address;
+	u8* dma;
+	
+	assert( ehci->intermem == NULL );
+	ehci->intermem = kzalloc( sizeof(INTERMEM_TOP), GFP_ATOMIC );
+	if( !ehci->intermem ) return -1;
+	spin_lock_init( &ehci->intermem->lock );
+	dma = address = (u8*)( (u32)ehci_to_hcd(ehci)->rsrc_start ) + INTERMEM_OFFSET;	/*_ 64ãƒ“ãƒƒãƒˆã‹ã‚‰ç›´æŽ¥ã‚­ãƒ£ã‚¹ãƒˆã™ã‚‹ã¨ãƒ¯ãƒ¼ãƒ‹ãƒ³ã‚° _*/
+
+/*_ @LINUXHOST:V0302nx[11/11/11] IOREMAPã‚’ã‚³ãƒ³ãƒ•ã‚£ã‚°ã§é¸æŠžã§ãã‚‹ã‚ˆã†ã«å¤‰æ›´ _*/
+#ifdef CONFIG_USB_PANASONIC_EHCI_IOREMAP
+	address = ioremap_nocache( (resource_size_t)address, INTERMEM_SIZE );
+	assert( address != NULL );
+#endif
+	memset( address, 0x00, INTERMEM_SIZE );
+	ehci->intermem->topAddress = address;
+	
+	if( allocateGroups( ehci->intermem->groups, address, dma ) ){
+		printk( "%s: allocateGroups fail.\n", __FUNCTION__ );
+		usbh_sharemem_finish( ehci );
+		return -1;
+	}
+	
+	return 0;
+}
+
+
+/*_  ã‚µã‚¤ã‚ºã‚’æŒ‡å®šã—ã¦ã€é©ã—ãŸã‚°ãƒ«ãƒ¼ãƒ—ã‚’å–å¾—ã™ã‚‹ã€‚ _*/
+static inline INTERMEM_GROUP* getSuitableGroupFromSize( INTERMEM_TOP* top, size_t size )
+{
+	int i;
+	INTERMEM_GROUP* gr;
+	
+	if( top == NULL ) return NULL;
+	
+	for( i = INTERMEM_CONFIG_NUM-1 ; 0 <= i ; i-- ){	/*_ 1024ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä¸Šã«æŒã£ã¦ã„ããŸã‚ã«ã€é€†ã‹ã‚‰æŽ¢ã™ _*/
+		gr = &top->groups[i];
+		if( gr->waitingNum != 0 && size <= gr->nodeConfig->size ) return gr;
+	}
+	return NULL;
+}
+
+/*_  ãƒ—ãƒ¼ãƒ«ã‹ã‚‰ãƒ¡ãƒ¢ãƒªã‚’ç¢ºä¿ã™ã‚‹ _*/
+static void* usbh_malloc_share( struct ehci_hcd *ehci, size_t size, dma_addr_t* dma )
+{
+	int index, offset;
+	INTERMEM_GROUP* gr;
+	void* ret;
+	
+	ret = NULL;
+	
+	INTERMEM_LOCK( ehci );
+	gr = getSuitableGroupFromSize( ehci->intermem, size );
+	if( gr ){
+		index = gr->waitingStack[ gr->waitingNum -1 ];	/*_ ä»•äº‹å¾…ã¡ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ãƒŽãƒ¼ãƒ‰ã‚’å–å¾— _*/
+		gr->waitingNum--;								/*_ ä»•äº‹å¾…ã¡äººæ•°æ¸›å°‘ _*/
+		assert( gr->workingCheckTable[ index ] == 0 );	/*_ æ—¢ã«ä»•äº‹ã‚’ã—ã¦ã„ã‚‹ã¨ãŠã‹ã—ã„ _*/
+		gr->workingCheckTable[index] = 1;				/*_ ä»•äº‹ä¸­ã‚’ã‚»ãƒƒãƒˆ _*/
+		
+		offset = gr->nodeConfig->size * index;			/*_ ãƒŽãƒ¼ãƒ‰ã®ç•ªå·ã¨ãƒŽãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã‹ã‚‰ã€ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—ã™ã‚‹ _*/
+		ret = (void*) ( gr->topAddress + offset );		/*_ ã‚°ãƒ«ãƒ¼ãƒ—ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹ã¨ã‚°ãƒ«ãƒ¼ãƒ—å†…ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¶³ã—ã€ãƒŽãƒ¼ãƒ‰ã«å¯¾å¿œã™ã‚‹ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’è¨ˆç®—ã™ã‚‹ _*/
+		if( dma ) *dma = (dma_addr_t) ( gr->topAddress_dma + offset );	/*_ DMAã‚¢ãƒ‰ãƒ¬ã‚¹ã‚‚åŒæ§˜ã®è¨ˆç®— _*/
+	}
+	INTERMEM_UNLOCK( ehci );
+	
+/*_ printk("%s:size=%u, ret=%p, dma=%08x\n", __FUNCTION__, size, ret, (dma==NULL)?NULL:*dma ); _*/
+	return ret;
+}
+
+
+/*_  æŒ‡å®šã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å«ã‚“ã§ã„ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã‚’è¿”ã™ _*/
+static inline INTERMEM_GROUP* getGroupFromAddress( INTERMEM_TOP* top, void* ptr )
+{
+	int i;
+	INTERMEM_GROUP* gr;
+	
+	if( top == NULL ) return NULL;
+	
+	for( i = INTERMEM_CONFIG_NUM-1 ; 0 <= i ; i-- ){	/*_ 1024ã®ãƒãƒƒãƒ•ã‚¡ã‚’ä¸Šã«æŒã£ã¦ã„ããŸã‚ã«ã€é€†ã‹ã‚‰æŽ¢ã™ _*/
+		gr = &top->groups[i];
+		if( gr->topAddress <= (u8*)ptr && (u8*)ptr <= gr->bottomAddress ) return gr;
+	}
+	return NULL;
+}
+
+/*_  usbh_malloc_shareã§ç¢ºä¿ã—ãŸãƒ¡ãƒ¢ãƒªã‚’é–‹æ”¾ã™ã‚‹ _*/
+static void usbh_free_share( struct ehci_hcd *ehci, void* ptr )
+{
+	int index, offset;
+	INTERMEM_GROUP* gr;
+	
+	INTERMEM_LOCK( ehci );
+	gr = getGroupFromAddress( ehci->intermem, ptr );
+	if( gr ){
+		offset = ( (u8*)ptr - gr->topAddress );		/*_ ã‚°ãƒ«ãƒ¼ãƒ—å†…ã‚ªãƒ•ã‚»ãƒƒãƒˆ _*/
+		index  = offset / gr->nodeConfig->size;		/*_ ã‚°ãƒ«ãƒ¼ãƒ—å†…ã‚ªãƒ•ã‚»ãƒƒãƒˆã¨ãƒŽãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚ºã‹ã‚‰ã€ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—ã™ã‚‹ _*/
+		assert( gr->workingCheckTable[index] );		/*_ ä»•äº‹ã‚’ã—ã¦ã„ãªã„çŠ¶æ…‹ã§ã“ã“ã«æ¥ã‚‹ã®ã¯ãŠã‹ã—ã„ _*/
+		
+		gr->workingCheckTable[ index ] = 0;			/*_ ä»•äº‹å®Œäº†ã‚’è¨˜éŒ² _*/
+		gr->waitingStack[ gr->waitingNum ] = index;	/*_ ãƒŽãƒ¼ãƒ‰ã‚’ä»•äº‹å¾…ã¡ã‚¹ã‚¿ãƒƒã‚¯ã«æˆ»ã™ _*/
+		gr->waitingNum++;							/*_ ä»•äº‹å¾…ã¡äººæ•°å¢—åŠ  _*/
+	}
+	INTERMEM_UNLOCK( ehci );
+}
+
diff -uNr linux-3.14.19/drivers/usb/host/ehci-mem.c linux-gerda/drivers/usb/host/ehci-mem.c
--- linux-3.14.19/drivers/usb/host/ehci-mem.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-mem.c	2017-06-22 09:52:55.775039162 +0900
@@ -34,6 +34,9 @@
 /*-------------------------------------------------------------------------*/
 
 /* Allocate the key transfer structures from the previously allocated pool */
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+#include "ehci-intrmem.c"
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 
 static inline void ehci_qtd_init(struct ehci_hcd *ehci, struct ehci_qtd *qtd,
 				  dma_addr_t dma)
@@ -51,7 +54,11 @@
 	struct ehci_qtd		*qtd;
 	dma_addr_t		dma;
 
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	qtd = dma_pool_alloc_local (ehci->qtd_pool, flags, &dma);
+#else
 	qtd = dma_pool_alloc (ehci->qtd_pool, flags, &dma);
+#endif
 	if (qtd != NULL) {
 		ehci_qtd_init(ehci, qtd, dma);
 	}
@@ -60,7 +67,11 @@
 
 static inline void ehci_qtd_free (struct ehci_hcd *ehci, struct ehci_qtd *qtd)
 {
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	dma_pool_free_local (ehci->qtd_pool, qtd, qtd->qtd_dma);
+#else
 	dma_pool_free (ehci->qtd_pool, qtd, qtd->qtd_dma);
+#endif
 }
 
 
@@ -73,8 +84,17 @@
 	}
 	if (qh->dummy)
 		ehci_qtd_free (ehci, qh->dummy);
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	usbh_free_share ( ehci, (void *)qh->hw );
+	usbh_free_share ( ehci, (void *)qh );
+#else   /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	dma_pool_free_local(ehci->qh_pool, qh->hw, qh->qh_dma);
+#else
 	dma_pool_free(ehci->qh_pool, qh->hw, qh->qh_dma);
+#endif
 	kfree(qh);
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 }
 
 static struct ehci_qh *ehci_qh_alloc (struct ehci_hcd *ehci, gfp_t flags)
@@ -82,11 +102,23 @@
 	struct ehci_qh		*qh;
 	dma_addr_t		dma;
 
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	qh = usbh_malloc_share( ehci, sizeof *qh, NULL );
+	if (!qh)
+		goto done;
+	qh->hw = (struct ehci_qh_hw*) usbh_malloc_share( ehci, sizeof(struct ehci_qh_hw), &dma );
+#else   /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	qh = kzalloc(sizeof *qh, GFP_ATOMIC);
 	if (!qh)
 		goto done;
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	qh->hw = (struct ehci_qh_hw *)
+		dma_pool_alloc_local(ehci->qh_pool, flags, &dma);
+#else
 	qh->hw = (struct ehci_qh_hw *)
 		dma_pool_alloc(ehci->qh_pool, flags, &dma);
+#endif
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	if (!qh->hw)
 		goto fail;
 	memset(qh->hw, 0, sizeof *qh->hw);
@@ -103,10 +135,21 @@
 	}
 done:
 	return qh;
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+fail1:
+	usbh_free_share( ehci, (void*)qh->hw );
+fail:
+	usbh_free_share( ehci, (void*)qh );
+#else   /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 fail1:
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	dma_pool_free_local(ehci->qh_pool, qh->hw, qh->qh_dma);
+#else
 	dma_pool_free(ehci->qh_pool, qh->hw, qh->qh_dma);
+#endif
 fail:
 	kfree(qh);
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	return NULL;
 }
 
@@ -132,10 +175,12 @@
 		dma_pool_destroy (ehci->qtd_pool);
 	ehci->qtd_pool = NULL;
 
+#ifndef  CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
 	if (ehci->qh_pool) {
 		dma_pool_destroy (ehci->qh_pool);
 		ehci->qh_pool = NULL;
 	}
+#endif  /* ! CONFIG_USB_PANASONIC_HOST_INTRMEM */
 
 	if (ehci->itd_pool)
 		dma_pool_destroy (ehci->itd_pool);
@@ -145,15 +190,33 @@
 		dma_pool_destroy (ehci->sitd_pool);
 	ehci->sitd_pool = NULL;
 
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	if (ehci->periodic)
+		usbh_free_share( ehci, (void*)ehci->periodic );
+#else
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	if (ehci->periodic)
+		dma_free_coherent_local (ehci_to_hcd(ehci)->self.controller,
+			ehci->periodic_size * sizeof (u32),
+			ehci->periodic, ehci->periodic_dma);
+#else
 	if (ehci->periodic)
 		dma_free_coherent (ehci_to_hcd(ehci)->self.controller,
 			ehci->periodic_size * sizeof (u32),
 			ehci->periodic, ehci->periodic_dma);
+#endif
+#endif  /* ! CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	ehci->periodic = NULL;
 
 	/* shadow periodic table */
 	kfree(ehci->pshadow);
 	ehci->pshadow = NULL;
+
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	/* internal memory finish */
+	usbh_sharemem_finish( ehci );
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
+
 }
 
 /* remember to add cleanup code (above) if you add anything here */
@@ -161,6 +224,12 @@
 {
 	int i;
 
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	/* internal memory init */
+	i = usbh_sharemem_init( ehci );
+	if(i < 0) goto fail;
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
+
 	/* QTDs for control/bulk/intr transfers */
 	ehci->qtd_pool = dma_pool_create ("ehci_qtd",
 			ehci_to_hcd(ehci)->self.controller,
@@ -171,6 +240,7 @@
 		goto fail;
 	}
 
+#ifndef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
 	/* QHs for control/bulk/intr transfers */
 	ehci->qh_pool = dma_pool_create ("ehci_qh",
 			ehci_to_hcd(ehci)->self.controller,
@@ -180,6 +250,8 @@
 	if (!ehci->qh_pool) {
 		goto fail;
 	}
+#endif  /* ! CONFIG_USB_PANASONIC_HOST_INTRMEM */
+
 	ehci->async = ehci_qh_alloc (ehci, flags);
 	if (!ehci->async) {
 		goto fail;
@@ -205,11 +277,22 @@
 		goto fail;
 	}
 
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	ehci->periodic = usbh_malloc_share( ehci, (ehci->periodic_size * 4), &ehci->periodic_dma );
+#else   /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	/* Hardware periodic table */
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+	ehci->periodic = (__le32 *)
+		dma_alloc_coherent_local (ehci_to_hcd(ehci)->self.controller,
+			ehci->periodic_size * sizeof(__le32),
+			&ehci->periodic_dma, 0);
+#else
 	ehci->periodic = (__le32 *)
 		dma_alloc_coherent (ehci_to_hcd(ehci)->self.controller,
 			ehci->periodic_size * sizeof(__le32),
 			&ehci->periodic_dma, 0);
+#endif
+#endif  /* CONFIG_USB_PANASONIC_HOST_INTRMEM */
 	if (ehci->periodic == NULL) {
 		goto fail;
 	}
diff -uNr linux-3.14.19/drivers/usb/host/ehci-panasonic-register-gerdac.h linux-gerda/drivers/usb/host/ehci-panasonic-register-gerdac.h
--- linux-3.14.19/drivers/usb/host/ehci-panasonic-register-gerdac.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-panasonic-register-gerdac.h	2017-06-22 09:52:55.939039157 +0900
@@ -0,0 +1,397 @@
+/*
+ * Copyright (C) 2011, Panasonic Corporation 
+ */
+
+#if defined(CONFIG_USB_PANASONIC_GERDAC)
+
+/*_------------------------------------------------------------------------
+    ãƒ¬ã‚¸ã‚¹ã‚¿ãƒžã‚¯ãƒ­
+------------------------------------------------------------------------_*/
+#define USBHD_RSTCTRL0_REG			(0x9C010000)	/*_ reset control register0 _*/
+#define USBHD_RSTCTRL3_REG			(0x9C01000C)	/*_ reset control register3 _*/
+#define USBHD_RSTCTRL14_REG			(0x9C010068)	/*_ reset control register14 _*/
+#define USBHD_RSTCTRL20_REG			(0x9C010080)	/*_ reset control register20 _*/
+
+#define USBHD_CGCTRL2_REG			(0x9C011010)	/*_ clock gating register2 _*/
+#define USBHD_CGCTRL3_REG			(0x9C011014)	/*_ clock gating register3 _*/
+
+/*GPIO24,25ã‚’VBUSã¨ã—ã¦ä½¿ç”¨*//*_ GerdaC 2015/1/13 _*/
+#define		USBHD_FSEL_REG					0x9C0160CC
+#define			USBHD_B_FSEL_VBUS				0x00000088
+#define		USBHD_GPONOE_REG				0x9C016060
+#define			USBHD_B_GPONOE_ON				0x01000000
+#define		USBHD_IECTRL_REG				0x9C016000
+#define			USBHD_B_IECTRL_ON				0x02000000
+
+#define			USBHD_B_HTC_VBUS_ACT			0x00000002		/*VBUSé›»æºåˆ¶å¾¡æ¥µæ€§	LowActive(è©•ä¾¡ãƒœãƒ¼ãƒ‰) */
+
+/*_------------------------------------------------------------------------
+    ã‚¹ãƒˆãƒªãƒ¼ãƒ é–¢é€£ãƒžã‚¯ãƒ­
+------------------------------------------------------------------------_*/
+#define IOBRESET					(0x9C000004)	/*_ ãƒªã‚»ãƒƒãƒˆãƒ¬ã‚¸ã‚¹ã‚¿  _*/
+#define IOBPERIRESET				(0x9C00000C)	/*_ å‘¨è¾ºãƒ‡ãƒã‚¤ã‚¹ãƒªã‚»ãƒƒãƒˆ ãƒ¬ã‚¸ã‚¹ã‚¿ _*/
+
+/*_------------------------------------------------------------------------
+	EHCIãƒ›ã‚¹ãƒˆé–¢é€£ãƒžã‚¯ãƒ­
+------------------------------------------------------------------------_*/
+#define USBH_USBSEL_REG_0		(0x9C008000)	/* PHY USB Select register */
+#define USBH_USBSEL_REG_1		(0x9C038000)	/* PHY USB Select register */
+
+#define INTERNAL_EHCI_BASE_ADR_0	(0x9C00A000)	/*_  host #0 EHCI Base Address _*/
+#define INTERNAL_EHCI_IRQ_NUM_0		(159)		/*_  host #0 EHCI IRQ NUM _*/
+
+#define INTERNAL_EHCI_BASE_ADR_1	(0x9C03A000)	/*_  host #1 EHCI Base Address _*/
+#define INTERNAL_EHCI_IRQ_NUM_1		(164)		/*_  host #1 EHCI IRQ NUM _*/
+
+#define USBH_EHCI_BURSTSIZE         (0x00001010)    /*_  BURSTSIZE _*/
+#define USBH_EHCI_TXFILLTUNING      TXFIFO_DEFAULT  /*_  TXFILLTUNING _*/
+#define INTERNAL_EHCI_MEM_LEN       (0x200)         /*_  EHCI core region _*/
+#define INTERNAL_EHCI_CAPS_BASE     (0x0100)        /*_  EHCI CAPS BASE _*/
+#define INTERNAL_EHCI_REGS_BASE     (0x0140)        /*_  EHCI REGS BASE _*/
+#define INTERNAL_EHCI_DBGR_BASE     (0x1000)		/*_  EHCI DEBUG_REG BASE _*/
+#define USBH_IOBASEADDR       		(0x0)			/*_  IO Base Address _*/
+/*_ @LINUXHOST:fx[13/04/19] Vbuså®‰å®šå¾…ã¡ç”¨å‡¦ç† _*/
+#ifdef CONFIG_USB_PANASONIC_VBUSWAIT
+#define INTERNAL_EHCI_VBUSWAIT_TIME      (5)  		/*_ Vbuså®‰å®šå¾…ã¡æ™‚é–“ (ms) _*/
+#endif	/* CONFIG_USB_PANASONIC_VBUSWAIT */
+
+#define BIT0	(1<<0)
+#define BIT1	(1<<1)
+#define BIT2	(1<<2)
+#define BIT3	(1<<3)
+#define BIT4	(1<<4)
+#define BIT5	(1<<5)
+#define BIT6	(1<<6)
+#define BIT7	(1<<7)
+#define BIT8	(1<<8)
+#define BIT9	(1<<9)
+#define BIT10	(1<<10)
+#define BIT11	(1<<11)
+#define BIT12	(1<<12)
+#define BIT13	(1<<13)
+#define BIT14	(1<<14)
+#define BIT15	(1<<15)
+
+/*_ ã‚¯ãƒ­ãƒƒã‚¯èµ·å‹• _*/
+static inline void internal_host_peripheryhw_init( void )
+{
+	void __iomem *vptr;
+	unsigned long int val0;
+
+	/*_ 1-1. USB0ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL3_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT6, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 1-2. USB1ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL20_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT3, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 2. PHYç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’ã‚¤ãƒãƒ¼ãƒ–ãƒ« _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL3_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT11, vptr);
+	iounmap(vptr);
+
+	/*_ 2-1. USB0 PHYç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’ã‚¤ãƒãƒ¼ãƒ–ãƒ« _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT2, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 2-2. USB1 PHYç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’ã‚¤ãƒãƒ¼ãƒ–ãƒ« _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT3, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 3-1. USB0ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’ã‚¤ãƒãƒ¼ãƒ–ãƒ« _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT0, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 3-2. USB1ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’ã‚¤ãƒãƒ¼ãƒ–ãƒ« _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT1, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 4-1. USB0ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã§Hostã‚’è¨­å®š _*/
+	vptr = ioremap_nocache(USBH_USBSEL_REG_0 , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT0, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 4-2. USB1ç”¨å…¨ä½“åˆ¶å¾¡ç”¨ãƒ¬ã‚¸ã‚¹ã‚¿ã§Hostã‚’è¨­å®š _*/
+	vptr = ioremap_nocache(USBH_USBSEL_REG_1 , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT0, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 5-1. USB0-HOSTç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL0_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT14, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 5-2. USB1-HOSTç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL20_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT2, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 6-1. USB0-HOSTç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL3_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT14, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 6-2. USB1-HOSTç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT5, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 7. SDMACã®ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	/*_ ã‚¹ãƒˆãƒªãƒ¼ãƒ ç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL0_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT0, vptr);
+	iounmap(vptr);
+
+	/*_ ãƒ¡ãƒ¢ãƒªã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ©(STRM)ç”¨ãƒªã‚»ãƒƒãƒˆã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL14_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT0, vptr);
+	iounmap(vptr);
+
+	/*_ ã‚¹ãƒˆãƒªãƒ¼ãƒ ç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’è§£é™¤ _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL3_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 | BIT7, vptr);
+	iounmap(vptr);
+
+	/*_ ã‚¹ãƒˆãƒªãƒ¼ãƒ å…¨ä½“åˆ¶å¾¡ã®ãƒªã‚»ãƒƒãƒˆè§£é™¤ _*/
+	vptr = ioremap_nocache(IOBRESET , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~(BIT7), vptr);
+	iounmap(vptr);
+
+	/*_ å‘¨è¾ºãƒ‡ãƒã‚¤ã‚¹IF ãƒªã‚»ãƒƒãƒˆè§£é™¤ _*/
+	vptr = ioremap_nocache(IOBPERIRESET , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~(BIT8), vptr);
+	iounmap(vptr);
+
+	/*_ 8. 1msã‚¦ã‚§ã‚¤ãƒˆã—ã¾ã™ _*/
+	msleep(1);
+
+}
+
+/*_ ã‚¯ãƒ­ãƒƒã‚¯åœæ­¢ _*/
+static inline void internal_host_peripheryhw_end( void )
+{
+	/*_ ãƒªã‚»ãƒƒãƒˆ _*/
+	void __iomem *vptr;
+	unsigned long int val0;
+
+	/*_ 1-1. ãƒªã‚¹ãƒˆå‡¦ç†ã‚’åœæ­¢ _*/
+	vptr = ioremap_nocache(INTERNAL_EHCI_BASE_ADR_0+INTERNAL_EHCI_REGS_BASE , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~(BIT4 | BIT5), vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 1-2. ãƒªã‚¹ãƒˆå‡¦ç†ã‚’åœæ­¢ _*/
+	vptr = ioremap_nocache(INTERNAL_EHCI_BASE_ADR_1+INTERNAL_EHCI_REGS_BASE , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~(BIT4 | BIT5), vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 2. 1msã‚¦ã‚§ã‚¤ãƒˆã—ã¾ã™ _*/
+	msleep(1);
+
+	/*_ 3-1. USB0-HOSTã‚’ãƒªã‚»ãƒƒãƒˆ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL0_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~BIT14, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 3-2. USB1-HOSTã‚’ãƒªã‚»ãƒƒãƒˆ _*/
+	vptr = ioremap_nocache(USBHD_RSTCTRL20_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~BIT2, vptr);
+	iounmap(vptr);
+#endif
+
+	/*_ 4-1. USB0-HOSTç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’åœæ­¢ _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL3_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~BIT14, vptr);
+	iounmap(vptr);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	/*_ 4-2. USB1-HOSTç”¨ã‚¯ãƒ­ãƒƒã‚¯ã‚’åœæ­¢ _*/
+	vptr = ioremap_nocache(USBHD_CGCTRL2_REG , 4 );
+	val0 = readl(vptr);
+	writel( val0 & ~BIT5, vptr);
+	iounmap(vptr);
+#endif
+
+}
+
+
+/*_ USBãƒ›ã‚¹ãƒˆ ãƒªã‚½ãƒ¼ã‚¹æ§‹é€ ä½“ _*/
+static const struct resource host_res[][2] = {
+	{/*_  host #0 _*/
+		{
+			.start	= INTERNAL_EHCI_BASE_ADR_0,
+			.end	= INTERNAL_EHCI_BASE_ADR_0 + INTERNAL_EHCI_MEM_LEN - 1,
+			.flags	= IORESOURCE_MEM,
+		}, {
+			.start	= INTERNAL_EHCI_IRQ_NUM_0,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	{/*_  host #1 _*/
+		{
+			.start	= INTERNAL_EHCI_BASE_ADR_1,
+			.end	= INTERNAL_EHCI_BASE_ADR_1 + INTERNAL_EHCI_MEM_LEN - 1,
+			.flags	= IORESOURCE_MEM,
+		}, {
+			.start	= INTERNAL_EHCI_IRQ_NUM_1,
+			.flags	= IORESOURCE_IRQ,
+		},
+	},
+#endif
+};
+
+
+
+#ifdef CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+/*_------------------------------------------------------------------------
+	EHCI å†…è”µãƒ¡ãƒ¢ãƒªå®šç¾©
+------------------------------------------------------------------------_*/
+#define INTERMEM_SIZE	8192		/*_ å†…è”µãƒ¡ãƒ¢ãƒªã§ä½¿ç”¨å¯èƒ½ãªãƒ¡ãƒ¢ãƒªã®é‡ _*/
+#define INTERMEM_OFFSET	0x2000		/*_ EHCIã®ãƒ¬ã‚¸ã‚¹ã‚¿ã‹ã‚‰ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ _*/
+
+typedef struct _INTERMEM_CONFIG{	/*_ å†…è”µãƒ¡ãƒ¢ãƒªãƒ—ãƒ¼ãƒ«ã€ä¸€ã‚°ãƒ«ãƒ¼ãƒ—åˆ†ã®è¨­å®š _*/
+	int size;						/*_ ãƒŽãƒ¼ãƒ‰ã®ã‚µã‚¤ã‚º _*/
+	int num;						/*_ ãƒŽãƒ¼ãƒ‰ã®æ•° _*/
+} INTERMEM_CONFIG;
+
+static const INTERMEM_CONFIG intermem_configuration[]={
+	{	1024,	1},					/*_ periodicã§ä½¿ç”¨ã™ã‚‹ã€‚ãƒšãƒ¼ã‚¸å¢ƒç•Œã«ç½®ã‹ãªã„ã¨å‹•ä½œã—ãªã„ã€‚DEFAULT_I_TDPS*4byteå¿…è¦ _*/
+	{	128,	56},				/*_ qhç­‰ã§ä½¿ç”¨ã™ã‚‹ _*/
+};
+#endif	/*_ CONFIG_USB_PANASONIC_HOST_INTRMEM _*/
+
+/*_-------------------------------------------------------------------------
+	GPIOã«ã‚ˆã‚‹USBãƒ›ã‚¹ãƒˆ(RootHub) Vbusåˆ¶å¾¡ â€»æ³¨æ„ è¤‡æ•°ãƒ›ã‚¹ãƒˆæœªå¯¾å¿œ
+--------------------------------------------------------------------------_*/
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+#define USB_ADDR_TO_CH(adr)	((adr)==INTERNAL_EHCI_BASE_ADR_0 ? 0 : 1)
+
+/*_  Vbusåˆ¶å¾¡GPIOå®šç¾© GPIO88,89 _*/
+unsigned long int _REG_FSEL[2][3] ={
+	/* addr        mask        write_data */
+	{0x9C01614C, 0xFFFFFFF0, 0x00000000},
+	{0x9C01614C, 0xFFFFFF0F, 0x00000000},
+};
+unsigned long int _REG_GPOOE[2][3] ={
+	/* addr        mask        write_data */
+	{0x9C016088, 0xFEFFFFFF, 0x01000000},
+	{0x9C016088, 0xFDFFFFFF, 0x02000000},
+};
+unsigned long int _REG_GPODATA[2][3] ={
+	/* addr        mask        write_data */
+	{0x9C016068, 0xFEFFFFFF, 0x01000000},
+	{0x9C016068, 0xFDFFFFFF, 0x02000000},
+};
+
+/*_  Vbusåˆ¶å¾¡GPIOåˆæœŸåŒ–å‡¦ç† _*/
+/*_  use PORT88,89 to GPIO (FSEL11) _*/
+/*_  init PORT88,89 (out port) _*/
+#define USBH_RHP_VBUS_INIT()	usbh_rhp_vbus_init()
+
+static inline void usbh_rhp_vbus_init( void )
+{
+	void __iomem *fsel, *gpooe;
+	unsigned long int val0;
+
+	fsel = ioremap_nocache(_REG_FSEL[0][0], 4 );
+	val0 = readl(fsel);
+	val0 &= _REG_FSEL[0][1];
+	val0 |= _REG_FSEL[0][2];
+	writel( val0, fsel);
+	iounmap(fsel);
+
+	gpooe = ioremap_nocache(_REG_GPOOE[0][0], 4 );
+	val0 = readl(gpooe);
+	val0 &= _REG_GPOOE[0][1];
+	val0 |= _REG_GPOOE[0][2];
+	writel( val0, gpooe);
+	iounmap(gpooe);
+
+#ifndef CONFIG_USB_PANASONIC_SINGLE_HOST
+	fsel = ioremap_nocache(_REG_FSEL[1][0], 4 );
+	val0 = readl(fsel);
+	val0 &= _REG_FSEL[1][1];
+	val0 |= _REG_FSEL[1][2];
+	writel( val0, fsel);
+	iounmap(fsel);
+
+	gpooe = ioremap_nocache(_REG_GPOOE[1][0], 4 );
+	val0 = readl(gpooe);
+	val0 &= _REG_GPOOE[1][1];
+	val0 |= _REG_GPOOE[1][2];
+	writel( val0, gpooe);
+	iounmap(gpooe);
+#endif
+}
+
+/*_  Vbusåˆ¶å¾¡ãƒžã‚¯ãƒ­å®šç¾© _*/
+#define USBH_RHP_VBUS_OFF            (0)
+#define USBH_RHP_VBUS_ON             (1)
+#define USBH_RHP_VBUS_SET(id, _flag)	usbh_rhp_vbus_set(id, _flag)
+
+static inline void usbh_rhp_vbus_set( int id, int _flag )
+{
+	void __iomem *gpodata;
+	unsigned long int val0;
+	
+	gpodata = ioremap_nocache( _REG_GPODATA[id][0], 4 );
+	val0 = readl(gpodata);
+	val0 &= _REG_GPODATA[id][1];
+	
+	if(_flag)
+		val0 |= _REG_GPODATA[id][2];
+
+	writel( val0, gpodata);
+	iounmap(gpodata);
+}
+
+
+#endif /* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
+
+#endif /* CONFIG_USB_PANASONIC_GERDAC */
+
diff -uNr linux-3.14.19/drivers/usb/host/ehci-panasonic.c linux-gerda/drivers/usb/host/ehci-panasonic.c
--- linux-3.14.19/drivers/usb/host/ehci-panasonic.c	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-panasonic.c	2017-06-22 09:52:55.923039158 +0900
@@ -0,0 +1,234 @@
+/*
+ * Panasonic EHCI Host Controller Driver
+ *
+ * Based on "ehci-ixp4xx.c" by Vladimir Barinov <vbarinov@embeddedalley.com>
+ *
+ * Copyright (C) 2010, Panasonic Corporation 
+ *
+ * This file is licensed under
+ * the terms of the GNU General Public License version 2. This program
+ * is licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ */
+
+#include <linux/platform_device.h>
+#include "../core/usb-panasonic.h"
+
+/*_---------------------------------------------------------------------------
+     panasonicç”¨ hc_driver
+---------------------------------------------------------------------------_*/
+static int panasonic_ehci_setup( struct usb_hcd *hcd )	/*_ hc_driver.resetã®å®Ÿè£… _*/
+{
+	struct ehci_hcd		*ehci = hcd_to_ehci(hcd);
+	int					retval;
+	
+	ehci->caps = hcd->regs + INTERNAL_EHCI_CAPS_BASE;
+	
+	hcd->has_tt = 1;
+	
+	retval = ehci_setup(hcd);
+	if( retval ) return retval;
+	/* BURSTSIZE */
+	_WRITEL ( USBH_EHCI_BURSTSIZE, &ehci->regs->burstsize );
+	
+	/* TXFILLTUNING */
+	_WRITEL ( USBH_EHCI_TXFILLTUNING, &ehci->regs->txfill_tuning );
+	
+	return retval;
+}
+
+static const struct hc_driver panasonic_ehci_hc_driver = {
+	.description		= hcd_name,
+	.product_desc		= "panasonic EHCI Host Controller",
+	.hcd_priv_size		= sizeof(struct ehci_hcd),
+	.irq				= ehci_irq,
+	.flags				= HCD_MEMORY | HCD_USB2 | HCD_BH,
+	.reset				= panasonic_ehci_setup,	/*_ resetã®ã¿ç‹¬è‡ªã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã€‚ _*/
+	.start				= ehci_run,
+	.stop				= ehci_stop,
+	.shutdown			= ehci_shutdown,
+	.urb_enqueue		= ehci_urb_enqueue,
+	.urb_dequeue		= ehci_urb_dequeue,
+	.endpoint_disable	= ehci_endpoint_disable,
+	.endpoint_reset		= ehci_endpoint_reset,
+	.get_frame_number	= ehci_get_frame,
+	.hub_status_data	= ehci_hub_status_data,
+	.hub_control		= ehci_hub_control,
+#if defined(CONFIG_PM)
+	.bus_suspend		= ehci_bus_suspend,
+	.bus_resume			= ehci_bus_resume,
+#endif
+	.relinquish_port	= ehci_relinquish_port,
+	.port_handed_over	= ehci_port_handed_over,
+	
+	.clear_tt_buffer_complete	= ehci_clear_tt_buffer_complete,
+};
+
+/*_--------------------------------------------------------------------------
+     panasonicç”¨ USBãƒ›ã‚¹ãƒˆãƒ‰ãƒ©ã‚¤ãƒ
+---------------------------------------------------------------------------_*/
+static int panasonic_ehci_probe(struct platform_device *pdev)
+{
+	const struct hc_driver *driver = &panasonic_ehci_hc_driver;
+	struct usb_hcd	*hcd;
+	struct resource *res;
+	unsigned long	rsrc_start;	/*_  memory/io resource start _*/
+	unsigned long	rsrc_len;	/*_  memory/io resource length _*/
+	int		irq;
+	int		retval=0;
+	
+	if( usb_disabled() ) return -ENODEV;
+	
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+	/*_ è¤‡æ•°ãƒ›ã‚¹ãƒˆã®å ´åˆã€å‘¼ã³åˆ†ã‘ã‚‹äº‹ _*/
+	USBH_RHP_VBUS_INIT();					/*_ RootHub Vbusåˆ¶å¾¡ç”¨GPIOã®åˆæœŸè¨­å®š _*/
+#if 0	/* Remove VBUS OFF in boot sequence */
+	USBH_RHP_VBUS_SET(pdev->id, USBH_RHP_VBUS_OFF);	/*_ RootHub Vbus OFFåˆ¶å¾¡ by GPIO _*/
+#endif	/* Remove VBUS OFF in boot sequence */
+#endif /* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
+	
+	/*_ ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰IRQã‚’å–å¾—ã™ã‚‹ _*/
+	res = platform_get_resource( pdev, IORESOURCE_IRQ, 0 );
+	assert( res );	/*_ resourceã¯ã€ãƒ‡ãƒã‚¤ã‚¹ç™»éŒ²æ™‚ã«Staticã§ç™»éŒ²ã™ã‚‹ã‹ã‚‰å¤±æ•—ã™ã‚‹ã¯ãšãŒç„¡ã„ã€‚å¤±æ•—ã—ãŸãªã‚‰ãƒ­ã‚¸ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ã‹ãƒ¡ãƒ¢ãƒªä¸è¶³ã€‚ _*/
+	if( !res ) goto done;
+	irq = res->start;
+	
+	/*_ ãƒ‡ãƒã‚¤ã‚¹ã‹ã‚‰ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã™ã‚‹ _*/
+	res = platform_get_resource( pdev, IORESOURCE_MEM, 0 );
+	assert( res );
+	if( !res ) goto done;
+	rsrc_start = res->start;
+	rsrc_len =   resource_size(res);
+	
+	/*_ hcdä½œæˆ _*/
+	hcd = usb_create_hcd( driver, &pdev->dev, dev_name(&pdev->dev) );
+	if( !hcd ){
+		retval = -ENOMEM;
+		goto done;
+	}
+	
+	/*_ hcdã«ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ _*/
+	hcd->rsrc_start = rsrc_start;
+	hcd->rsrc_len = rsrc_len;
+	hcd->regs = (struct ehci_regs*)( rsrc_start - USBH_IOBASEADDR );
+
+/*_ @LINUXHOST:V0302nx[11/11/11] IOREMAPã‚’ã‚³ãƒ³ãƒ•ã‚£ã‚°ã§é¸æŠžã§ãã‚‹ã‚ˆã†ã«å¤‰æ›´ _*/
+#ifdef CONFIG_USB_PANASONIC_EHCI_IOREMAP
+	/*_ ãƒ‡ãƒã‚¤ã‚¹çµ‚äº†æ™‚ã«è‡ªå‹•çš„ã«unmapã•ã‚Œã‚‹ã€‚ _*/
+	hcd->regs = devm_ioremap_nocache( &pdev->dev, (resource_size_t)hcd->regs, rsrc_len );
+#endif
+	hcd->irq = irq;
+	
+
+/*_ @LINUXHOST:V0106nx[10/08/23] å‰²è¾¼ç™»éŒ²æ™‚ã®ãƒ•ãƒ©ã‚°ã« SA_SAMPLE_RANDOM è¿½åŠ  _*/
+#ifdef CONFIG_SS_SC
+	/*_ hcdã‚’ç™»éŒ² _*/
+	retval = usb_add_hcd( hcd, irq, (IRQF_SHARED | IRQF_SAMPLE_RANDOM) );
+#else
+	/*_ hcdã‚’ç™»éŒ² _*/
+	retval = usb_add_hcd( hcd, irq, IRQF_SHARED );
+#endif
+
+	if( retval ){
+		usb_put_hcd( hcd );
+		goto done;
+	}
+	
+done:
+	return retval;
+}
+
+static int panasonic_ehci_remove(struct platform_device *pdev)
+{
+	struct usb_hcd *hcd = platform_get_drvdata(pdev);
+	
+	usb_remove_hcd(hcd);
+	usb_put_hcd(hcd);
+	
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+	/*_ è¤‡æ•°ãƒ›ã‚¹ãƒˆã®å ´åˆã€å‘¼ã³åˆ†ã‘ã‚‹äº‹ _*/
+	/*_ GerdaC ã§ã¯VBUSè½ã¨ã•ãªã„ _*/
+	/*USBH_RHP_VBUS_INIT();*/					/*_ RootHub Vbusåˆ¶å¾¡ç”¨GPIOã®åˆæœŸè¨­å®š _*/
+	/*USBH_RHP_VBUS_SET(USBH_RHP_VBUS_OFF);*/	/*_ RootHub Vbus OFFåˆ¶å¾¡ by GPIO _*/
+#endif /* CONFIG_USB_PANASONIC_GPIO_FOR_VBUS */
+	
+	return 0;
+}
+
+MODULE_ALIAS("platform:panasonic-ehci");
+
+static struct platform_driver panasonic_ehci_driver = {
+	.probe = panasonic_ehci_probe,
+	.remove = panasonic_ehci_remove,
+	.driver = {
+		.name = "panasonic-ehci",	/*_ platform_deviceã¨åŒã˜åå‰ã‚’æŒ‡å®šã™ã‚‹äº‹ã€‚ _*/
+	},
+};
+
+/*_---------------------------------------------------------------------------
+    panasonicç”¨ USBãƒ›ã‚¹ãƒˆãƒ‡ãƒã‚¤ã‚¹
+---------------------------------------------------------------------------_*/
+#define HOST_NUM	ARRAY_SIZE( host_res )
+static struct platform_device *myDevices[HOST_NUM];
+
+static int panasonic_ehci_device_init( void )
+{
+	int i, isSomeone;
+	
+	/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹ã®å‹•çš„åˆ‡æ›¿ç”¨ _*/
+	uint ehci_info;
+
+	/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ‰ãƒ©ã‚¤ãƒãƒãƒ¼ã‚¸ãƒ§ãƒ³æƒ…å ±ã®å‡ºåŠ› _*/
+	printk("Panasonic EHCI host driver v%04x start \n",USBH_DDVERSION);
+
+	/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹ã®å‹•çš„åˆ‡æ›¿ç”¨ _*/
+	ehci_info = usbh_get_host_enableinfo(USBH_ENABLEINFO_EHCI);
+	printk("Enable EHCI Info = %08x\n",ehci_info);
+
+	/*_  periphery Hardware init _*/
+	internal_host_peripheryhw_init();
+	
+	isSomeone=0;
+	for( i=0 ; i < HOST_NUM ; i++ ){
+
+		/*_ @LINUXHOST:V0302nx[11/11/11] ãƒ›ã‚¹ãƒˆæœ‰åŠ¹/ç„¡åŠ¹ã®å‹•çš„åˆ‡æ›¿ç”¨ _*/
+		if( ehci_info & (0x000000001 << i) ){
+			printk(" Ignore EHCI No.%d \n",i);
+			myDevices[i]=NULL;
+			continue;
+		}
+		assert( myDevices[i] == NULL );
+		
+		/*_ platform_deviceã¨ã—ã¦ã€USBãƒ›ã‚¹ãƒˆãƒ‡ãƒã‚¤ã‚¹ã‚’ç™»éŒ²ã™ã‚‹ _*/
+		myDevices[i] = platform_device_register_simple( "panasonic-ehci", i, (struct resource*)host_res[i], ARRAY_SIZE(host_res[i]) );
+		if( IS_ERR(myDevices[i]) ){
+			printk( "%s:%d error i=%d\n", __FUNCTION__, __LINE__, i );
+			myDevices[i]=NULL;
+			continue;
+		}
+		myDevices[i]->dev.coherent_dma_mask=0xffffffffull;
+		myDevices[i]->dev.dma_mask = &myDevices[i]->dev.coherent_dma_mask;
+		isSomeone=1;
+	}
+	
+	if( isSomeone ) return 0;
+	return -1;
+}
+
+static void panasonic_ehci_device_exit( void )
+{
+	int i;
+	
+	for( i=0 ; i < HOST_NUM ; i++ ){
+		if( myDevices[i] == NULL ) continue;
+		platform_device_unregister( myDevices[i] );
+		myDevices[i] = NULL;
+	}
+	/*_  periphery Hardware End _*/
+	internal_host_peripheryhw_end();
+}
+
+#if defined(CONFIG_USB_PANASONIC_TEST_MODE_IN_USB_DRIVER)
+#include "ehci-panasonic-test-mode.c"
+#endif
+
diff -uNr linux-3.14.19/drivers/usb/host/ehci-panasonic.h linux-gerda/drivers/usb/host/ehci-panasonic.h
--- linux-3.14.19/drivers/usb/host/ehci-panasonic.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-panasonic.h	2017-06-22 09:52:55.923039158 +0900
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2010, Panasonic Corporation.
+ *                       All Rights Reserved.
+ *
+ */
+
+#define assert(expr) \
+	if (!(expr)) { \
+		printk("Assertion failed! %s,%s,%s,line=%d\n", \
+		#expr, __FILE__, __func__, __LINE__); \
+	}
+
+#define _READB(_reg)     		readb((volatile void __iomem*)(_reg))
+#define _READL(_reg)     		readl((volatile void __iomem*)(_reg))
+#define _WRITEB(_val, _reg)     writeb((u8)(_val), (volatile void __iomem*)(_reg))
+#define _WRITEL(_val, _reg)     writel((u32)(_val), (volatile void __iomem*)(_reg))
+
+#define _REG_R8(_reg)           _READB(_reg)
+#define _REG_R16(_reg)          _READW(_reg)
+#define _REG_R32(_reg)          _READL(_reg)
+
+#define _REG_W8(_reg, _val)     _WRITEB(_val, _reg)
+#define _REG_W16(_reg, _val)    _WRITEW(_val, _reg)
+#define _REG_W32(_reg, _val)    _WRITEL(_val, _reg)
+
+#define _REG_SET8(_reg, _val) \
+    _REG_W8((_reg), _REG_R8(_reg) | (u8)(_val))
+#define _REG_SET16(_reg, _val) \
+    _REG_W16((_reg), _REG_R16(_reg) | (u16)(_val))
+#define _REG_SET32(_reg, _val) \
+    _REG_W32((_reg), _REG_R32(_reg) | (u32)(_val))
+
+#define _REG_SETM8(_reg, _val, _mask) \
+    _REG_W8((_reg), (_REG_R8(_reg) & (u8)(_mask)) | (u8)(_val))
+#define _REG_SETM16(_reg, _val, _mask) \
+    _REG_W16((_reg), (_REG_R16(_reg) & (u16)(_mask)) | (u16)(_val))
+#define _REG_SETM32(_reg, _val, _mask) \
+    _REG_W32((_reg), (_REG_R32(_reg) & (u32)(_mask)) | (u32)(_val))
+
+#define _REG_CLR8(_reg, _val) \
+    _REG_W8((_reg), (_REG_R8(_reg) & (~(u8)(_val))))
+#define _REG_CLR16(_reg, _val) \
+    _REG_W16((_reg), (_REG_R16(_reg) & (~(u16)(_val))))
+#define _REG_CLR32(_reg, _val) \
+    _REG_W32((_reg), (_REG_R32(_reg) & (~(u32)(_val))))
+
+#define _REG_TEST8(_reg, _val) \
+    ((_REG_R8(_reg) & (u8)(_val)) != 0 ? 1 : 0)
+#define _REG_TEST16(_reg, _val) \
+    ((_REG_R16(_reg) & (u16)(_val)) != 0 ? 1 : 0)
+#define _REG_TEST32(_reg, _val) \
+    ((_REG_R32(_reg) & (u32)(_val)) != 0 ? 1 : 0)
+
+/*_ GerdaC 2014/12/24 _*/
+#if defined(CONFIG_USB_PANASONIC_GERDAC)
+#include "ehci-panasonic-register-gerdac.h"
+#endif
+
+
diff -uNr linux-3.14.19/drivers/usb/host/ehci-q.c linux-gerda/drivers/usb/host/ehci-q.c
--- linux-3.14.19/drivers/usb/host/ehci-q.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-q.c	2017-06-22 09:52:55.935039157 +0900
@@ -626,8 +626,11 @@
 	i = urb->num_mapped_sgs;
 	if (len > 0 && i > 0) {
 		sg = urb->sg;
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		buf = sg_dma_address_local(sg);
+#else
 		buf = sg_dma_address(sg);
-
+#endif
 		/* urb->transfer_buffer_length may be smaller than the
 		 * size of the scatterlist (or vice versa)
 		 */
@@ -674,7 +677,11 @@
 			if (--i <= 0 || len <= 0)
 				break;
 			sg = sg_next(sg);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			buf = sg_dma_address_local(sg);
+#else
 			buf = sg_dma_address(sg);
+#endif
 			this_sg_len = min_t(int, sg_dma_len(sg), len);
 		}
 
diff -uNr linux-3.14.19/drivers/usb/host/ehci-sched.c linux-gerda/drivers/usb/host/ehci-sched.c
--- linux-3.14.19/drivers/usb/host/ehci-sched.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-sched.c	2017-06-22 09:52:55.927039158 +0900
@@ -466,7 +466,13 @@
 			case Q_TYPE_QH:
 				hw = here.qh->hw;
 				if (same_tt(dev, here.qh->ps.udev)) {
+
+/*_ @LINUXHOST:V0205nx[11/05/27] è»¢é€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ã«å¤±æ•—ã™ã‚‹ä¸å…·åˆå¯¾å¿œ _*//*_ GerdaC 2015/1/6 _*/
+#ifdef CONFIG_USB_PANASONIC_HOST
+					u16		mask;
+#else
 					u32		mask;
+#endif
 
 					mask = hc32_to_cpu(ehci,
 							hw->hw_info2);
@@ -1303,8 +1309,13 @@
 		} else {
  alloc_itd:
 			spin_unlock_irqrestore (&ehci->lock, flags);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			itd = dma_pool_alloc_local (ehci->itd_pool, mem_flags,
+					&itd_dma);
+#else
 			itd = dma_pool_alloc (ehci->itd_pool, mem_flags,
 					&itd_dma);
+#endif
 			spin_lock_irqsave (&ehci->lock, flags);
 			if (!itd) {
 				iso_sched_free(stream, sched);
@@ -2096,8 +2107,13 @@
 		} else {
  alloc_sitd:
 			spin_unlock_irqrestore (&ehci->lock, flags);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+			sitd = dma_pool_alloc_local (ehci->sitd_pool, mem_flags,
+					&sitd_dma);
+#else
 			sitd = dma_pool_alloc (ehci->sitd_pool, mem_flags,
 					&sitd_dma);
+#endif
 			spin_lock_irqsave (&ehci->lock, flags);
 			if (!sitd) {
 				iso_sched_free(stream, iso_sched);
diff -uNr linux-3.14.19/drivers/usb/host/ehci-timer.c linux-gerda/drivers/usb/host/ehci-timer.c
--- linux-3.14.19/drivers/usb/host/ehci-timer.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci-timer.c	2017-06-22 09:52:55.931039158 +0900
@@ -307,13 +307,21 @@
 
 	list_for_each_entry_safe(itd, n, &ehci->cached_itd_list, itd_list) {
 		list_del(&itd->itd_list);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		dma_pool_free_local(ehci->itd_pool, itd, itd->itd_dma);
+#else
 		dma_pool_free(ehci->itd_pool, itd, itd->itd_dma);
+#endif
 		if (itd == ehci->last_itd_to_free)
 			break;
 	}
 	list_for_each_entry_safe(sitd, sn, &ehci->cached_sitd_list, sitd_list) {
 		list_del(&sitd->sitd_list);
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+		dma_pool_free_local(ehci->sitd_pool, sitd, sitd->sitd_dma);
+#else
 		dma_pool_free(ehci->sitd_pool, sitd, sitd->sitd_dma);
+#endif
 		if (sitd == ehci->last_sitd_to_free)
 			break;
 	}
diff -uNr linux-3.14.19/drivers/usb/host/ehci.h linux-gerda/drivers/usb/host/ehci.h
--- linux-3.14.19/drivers/usb/host/ehci.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/host/ehci.h	2017-06-22 09:52:55.939039157 +0900
@@ -1,5 +1,6 @@
 /*
  * Copyright (c) 2001-2002 by David Brownell
+ * Copyright (C) 2015, Panasonic Corporation
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the
@@ -264,6 +265,10 @@
 
 	/* platform-specific data -- must come last */
 	unsigned long		priv[0] __aligned(sizeof(s64));
+#ifdef  CONFIG_USB_PANASONIC_HOST_INTRMEM	/*_ GerdaC 2015/1/6 _*/
+	struct _INTERMEM_TOP	*intermem;
+#endif
+
 };
 
 /* convert between an HCD pointer and the corresponding EHCI_HCD */
@@ -872,4 +877,52 @@
 extern int	ehci_resume(struct usb_hcd *hcd, bool hibernated);
 #endif	/* CONFIG_PM */
 
+#if CONFIG_USB_PANASONIC_HOST_RELATIVE_ADDRESS
+/* Absolute address to Relative address */
+#define DDR_BASE_ADDR (0xA0000000)
+static inline void *dma_pool_alloc_local(struct dma_pool *pool, gfp_t mem_flags,dma_addr_t *handle)
+{
+	void *retval;
+	retval = dma_pool_alloc(pool, mem_flags, handle);
+	*handle -= DDR_BASE_ADDR;
+
+	return retval;
+}
+
+static inline void dma_pool_free_local(struct dma_pool *pool, void *vaddr, dma_addr_t addr)
+{
+	dma_pool_free(pool, vaddr, addr + DDR_BASE_ADDR);
+}
+
+static inline dma_addr_t dma_map_single_local(struct device *dev, void *ptr, size_t size, enum dma_data_direction direction)
+{
+	return ( dma_map_single(dev, ptr, size, direction) - DDR_BASE_ADDR );
+}
+
+static inline void dma_unmap_single_local(struct device *dev, dma_addr_t dma_addr, size_t size, enum dma_data_direction direction)
+{
+	dma_unmap_single(dev, dma_addr + DDR_BASE_ADDR, size, direction);
+}
+
+
+static void * dma_alloc_coherent_local(struct device *dev, size_t size, dma_addr_t *dma_handle, gfp_t flag)
+{
+	void *retval;
+	retval = dma_alloc_coherent(dev, size, dma_handle, flag);
+	*dma_handle -= DDR_BASE_ADDR;
+
+	return retval;
+
+}
+
+static inline void dma_free_coherent_local(struct device *dev, size_t size, void *kvaddr,dma_addr_t dma_handle)
+{
+	dma_free_coherent(dev, size, kvaddr, dma_handle + DDR_BASE_ADDR);
+}
+
+#define sg_dma_address_local(sg)      ((sg)->dma_address - DDR_BASE_ADDR )
+
+#endif
+
+
 #endif /* __LINUX_EHCI_HCD_H */
diff -uNr linux-3.14.19/drivers/usb/storage/usb.c linux-gerda/drivers/usb/storage/usb.c
--- linux-3.14.19/drivers/usb/storage/usb.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/drivers/usb/storage/usb.c	2017-06-22 09:52:55.599039167 +0900
@@ -77,7 +77,11 @@
 MODULE_DESCRIPTION("USB Mass Storage driver for Linux");
 MODULE_LICENSE("GPL");
 
+#ifdef CONFIG_USB_PANASONIC_HOST	/*_ GerdaC 2015/1/6 _*/
+static unsigned int delay_use = 0;
+#else
 static unsigned int delay_use = 1;
+#endif
 module_param(delay_use, uint, S_IRUGO | S_IWUSR);
 MODULE_PARM_DESC(delay_use, "seconds to delay before using a new device");
 
diff -uNr linux-3.14.19/fs/binfmt_elf.c linux-gerda/fs/binfmt_elf.c
--- linux-3.14.19/fs/binfmt_elf.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/fs/binfmt_elf.c	2017-06-22 09:52:04.291040694 +0900
@@ -37,6 +37,9 @@
 #include <asm/uaccess.h>
 #include <asm/param.h>
 #include <asm/page.h>
+#ifdef CONFIG_KMC_NO_USER_PATCH
+#include <linux/kmc.h>
+#endif
 
 #ifndef user_long_t
 #define user_long_t long
@@ -875,6 +878,9 @@
 	end_code += load_bias;
 	start_data += load_bias;
 	end_data += load_bias;
+#ifdef CONFIG_KMC_NO_USER_PATCH
+	elf_brk += PAGE_SIZE;
+#endif
 
 	/* Calling set_brk effectively mmaps the pages that we need
 	 * for the bss and break sections.  We must do this before
@@ -886,6 +892,9 @@
 		send_sig(SIGKILL, current, 0);
 		goto out_free_dentry;
 	}
+#ifdef CONFIG_KMC_NO_USER_PATCH
+	__kmc_copy_supcode(elf_brk);
+#endif
 	if (likely(elf_bss != elf_brk) && unlikely(padzero(elf_bss))) {
 		send_sig(SIGSEGV, current, 0);
 		retval = -EFAULT; /* Nobody gets to see this, but.. */
diff -uNr linux-3.14.19/fs/exec.c linux-gerda/fs/exec.c
--- linux-3.14.19/fs/exec.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/fs/exec.c	2017-06-22 09:52:04.703040681 +0900
@@ -65,6 +65,10 @@
 
 #include <trace/events/sched.h>
 
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+#include <linux/kmc.h>
+#endif
+
 int suid_dumpable = 0;
 
 static LIST_HEAD(formats);
@@ -1531,6 +1535,9 @@
 	task_numa_free(current);
 	free_bprm(bprm);
 	putname(filename);
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+	__kmc_make_fork_tbl(current, 1, (unsigned long)filename);
+#endif
 	if (displaced)
 		put_files_struct(displaced);
 	return retval;
diff -uNr linux-3.14.19/include/linux/dmaengine.h linux-gerda/include/linux/dmaengine.h
--- linux-3.14.19/include/linux/dmaengine.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/dmaengine.h	2017-06-22 09:52:24.159040103 +0900
@@ -361,6 +361,9 @@
 	u32 dst_maxburst;
 	bool device_fc;
 	unsigned int slave_id;
+	void	(*setsize)(void *, u32);
+	u32	(*getsize)(void *);
+	void	*size_param;
 };
 
 /**
diff -uNr linux-3.14.19/include/linux/i2c/i2c-mn.h linux-gerda/include/linux/i2c/i2c-mn.h
--- linux-3.14.19/include/linux/i2c/i2c-mn.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/include/linux/i2c/i2c-mn.h	2017-06-22 09:52:24.331040098 +0900
@@ -0,0 +1,38 @@
+/*
+ *  i2c-mn.h i2c driver Hardware-specific common definition for Panasonic Gerda-C series
+ *
+ *  Copyright (C) 2014 Panasonic Corporation.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+
+#ifndef LINUX_I2C_MN__H__INCLUDED /* [ */
+#define LINUX_I2C_MN__H__INCLUDED 1
+
+#include <linux/types.h>
+
+
+#ifdef __KERNEL__ /* [ */
+
+/* Communication Control Data Structure of Each Chip */
+struct i2c_mn_pdata {
+	unsigned long		base;
+	int		irq;
+	int		rate;
+};
+
+#endif /* ] __KERNEL__ */
+
+/* Request Parameter Structure of IOCTRL */
+struct i2c_busreset_ioctl_data {
+	__u16 interval;
+	__u16 times;
+};
+
+#define I2C_BUSRESET		(0x0730)	/* Request Value of Bus Reset */
+#define I2C_SET_BUSRATE		(0x0731)	/* Request Value of Setting Bus Rate */
+#define I2C_GET_BUSRATE		(0x0732)	/* Request Value of Getting Bus Rate */
+
+#endif /* ] LINUX_I2C_MN__H__INCLUDED */
diff -uNr linux-3.14.19/include/linux/i2c.h linux-gerda/include/linux/i2c.h
--- linux-3.14.19/include/linux/i2c.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/i2c.h	2017-06-22 09:52:23.963040108 +0900
@@ -443,6 +443,10 @@
 	struct list_head userspace_clients;
 
 	struct i2c_bus_recovery_info *bus_recovery_info;
+#if defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE)
+	/* Customizing the IOCTL request handling function from the user application */
+	int (*pfControl)( struct i2c_adapter *i2c_adap, unsigned int cmd, unsigned long arg ); 
+#endif	/* defined(CONFIG_I2C_MN) || defined(CONFIG_I2C_MN_MODULE) */
 };
 #define to_i2c_adapter(d) container_of(d, struct i2c_adapter, dev)
 
diff -uNr linux-3.14.19/include/linux/kmc.h linux-gerda/include/linux/kmc.h
--- linux-3.14.19/include/linux/kmc.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/include/linux/kmc.h	2017-06-22 09:52:24.675040087 +0900
@@ -0,0 +1,53 @@
+/*
+ * PARTNER-Jet Linux support patch by KMC
+ *
+ * 2012.06.10 ver3.0-beta
+ */
+
+#include <linux/sched.h>
+#include <linux/module.h>
+
+extern void __kmc_do_exit__(struct task_struct *);
+extern void __kmc_schedule__(struct task_struct *, struct task_struct *);
+
+#ifdef CONFIG_KMC_MODULE_DEBUG
+extern void __kmc_mod_init_brfore__(struct module *);
+extern void __kmc_mod_init_after__(struct module *, int);
+extern void __kmc_mod_exit__(struct module *);
+extern void __kmc_chk_mod_sec__(struct module *, char *, void *);
+extern void __kmc_set_mod_sec(struct module *);
+#endif
+
+#ifdef CONFIG_KMC_NO_USER_PATCH
+extern void __kmc_copy_supcode(unsigned long);
+#endif
+
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+extern void __kmc_make_fork_tbl(struct task_struct *, int , unsigned long);
+#endif
+
+#ifdef CONFIG_KMC_NOTIFY_UPDATE_CONTEXTID
+extern void __kmc_notify_update_contextid(struct mm_struct *, u64);
+#endif
+
+
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+
+extern void __kmc_linux_event_set_logI(int evtid, int pid, int param);
+extern void __kmc_linux_event_set_logS(int evtid, int pid, const char* pname);
+extern void __kmc_linux_event_set_logT(int evtid, struct task_struct* t);
+extern void __kmc_linux_event_set_Pname(int pid, const char* pname);
+
+#define	__KMC_LINUX_EVENT_SET_LOG_I(a, b, c)	__kmc_linux_event_set_logI(a, b, c)
+#define	__KMC_LINUX_EVENT_SET_LOG_S(a, b, c)	__kmc_linux_event_set_logS(a, b, c)
+#define	__KMC_LINUX_EVENT_SET_LOG_T(a, b)	__kmc_linux_event_set_logT(a, b)
+#define	__KMC_LINUX_EVENT_SET_PNAME(a, b)	__kmc_linux_event_set_Pname(a, b)
+
+#else
+
+#define __KMC_LINUX_EVENT_SET_LOG_I(a, b, c)
+#define __KMC_LINUX_EVENT_SET_LOG_S(a, b, c)
+#define	__KMC_LINUX_EVENT_SET_LOG_T(a, b)
+#define	__KMC_LINUX_EVENT_SET_PNAME(a, b)
+
+#endif
diff -uNr linux-3.14.19/include/linux/mmc/gerdac.h linux-gerda/include/linux/mmc/gerdac.h
--- linux-3.14.19/include/linux/mmc/gerdac.h	1970-01-01 09:00:00.000000000 +0900
+++ linux-gerda/include/linux/mmc/gerdac.h	2017-06-22 09:52:24.451040094 +0900
@@ -0,0 +1,151 @@
+/*
+ * include/linux/mmc/gerdac.h
+ *
+ * Copyright (C) 20XX-20XX XXX XXX, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#ifndef LINUX_MMC_GERDAC_H
+#define LINUX_MMC_GERDAC_H
+
+#ifdef	CONFIG_MMC_GERDAC
+#define CTL_SD_CMD						0x00		//šbus_shift”pŽ~‚©H
+#define CTL_PORTSEL						0x02
+#define CTL_ARG_REG						0x04
+#define CTL_STOP_INTERNAL_ACTION		0x08
+#define CTL_XFER_BLK_COUNT				0x0a
+#define CTL_RESPONSE					0x0c
+#define CTL_STATUS						0x1c
+#define CTL_STATUS2						0x1e
+#define CTL_IRQ_MASK					0x20
+#define CTL_IRQ_MASK2					0x22
+#define CTL_SD_CARD_CLK_CTL				0x24
+#define CTL_CLK_AND_WAIT_CTL			0x25
+#define CTL_SD_XFER_LEN					0x26
+#define CTL_SD_MEM_CARD_OPT				0x28
+#define CTL_SD_ERROR_DETAIL_STATUS		0x2c
+#define CTL_SD_ERROR_DETAIL_STATUS2		0x2e
+#define CTL_SD_DATA_PORT				0x30
+#define CTL_TRANSACTION_CTL				0x34
+#define CTL_SDIO_STATUS					0x36
+#define CTL_SDIO_IRQ_MASK				0x38
+#define CTL_DMA_ENABLE					0xd8
+#define CTL_RESET_SD					0xe0
+//#define CTL_RESET_SDIO					0xe1
+#define CTL_VERSION						0xe2
+#define CTL_HOST_MODE					0xe4
+#define CTL_SDIF_MODE					0xe6
+#define CTL_BUS_MODE					0xf2
+#define CTL_UHS1MODE					0x200
+#define CTL_MMCMODE						0x202
+#else	/* CONFIG_MMC_GERDAC */
+#define CTL_SD_CMD						0x00
+#define CTL_PORTSEL						0x02
+#define CTL_ARG_REG						0x04
+#define CTL_STOP_INTERNAL_ACTION		0x08
+#define CTL_XFER_BLK_COUNT				0x0a
+#define CTL_RESPONSE					0x0c
+#define CTL_STATUS						0x1c
+#define CTL_STATUS2						0x1e
+#define CTL_IRQ_MASK					0x20
+#define CTL_IRQ_MASK2					0x22
+#define CTL_SD_CARD_CLK_CTL				0x24
+#define CTL_CLK_AND_WAIT_CTL			0x25
+#define CTL_SD_XFER_LEN					0x26
+#define CTL_SD_MEM_CARD_OPT				0x28
+#define CTL_SD_ERROR_DETAIL_STATUS		0x2c
+#define CTL_SD_ERROR_DETAIL_STATUS2		0x2e
+#define CTL_SD_DATA_PORT				0x30
+#define CTL_TRANSACTION_CTL				0x34
+#define CTL_SDIO_STATUS					0x36
+#define CTL_SDIO_IRQ_MASK				0x38
+#define CTL_DMA_ENABLE					0xd8
+#define CTL_RESET_SD					0xe0
+#define CTL_RESET_SDIO					0xe1
+#define CTL_VERSION						0xe2
+#define CTL_HOST_MODE					0xe4
+#define CTL_SDIF_MODE					0xe6
+#define CTL_UHS1MODE					0xf0
+#define CTL_MMCMODE						0xf2
+#endif
+
+/* Definitions for values the CTRL_STATUS register can take. */
+#define GERDAC_STAT_CMDRESPEND			0x00000001
+#define GERDAC_STAT_DATAEND				0x00000004
+#define GERDAC_STAT_CARD_REMOVE			0x00000008
+#define GERDAC_STAT_CARD_INSERT			0x00000010
+//#define GERDAC_STAT_SIGSTATE			0x00000020
+#define GERDAC_STAT_WRPROTECT			0x00000080
+#define GERDAC_STAT_CARD_REMOVE_A		0x00000100
+#define GERDAC_STAT_CARD_INSERT_A		0x00000200
+//#define GERDAC_STAT_SIGSTATE_A			0x00000400
+#define GERDAC_STAT_CMD_IDX_ERR			0x00010000
+#define GERDAC_STAT_CRCFAIL				0x00020000
+#define GERDAC_STAT_STOPBIT_ERR			0x00040000
+#define GERDAC_STAT_DATATIMEOUT			0x00080000
+#define GERDAC_STAT_RXOVERFLOW			0x00100000
+#define GERDAC_STAT_TXUNDERRUN			0x00200000
+#define GERDAC_STAT_CMDTIMEOUT			0x00400000
+#define GERDAC_STAT_SDDAT0				0x00800000
+#define GERDAC_STAT_RXRDY				0x01000000
+#define GERDAC_STAT_TXRQ				0x02000000
+//#define GERDAC_STAT_ILL_FUNC			0x20000000
+#define GERDAC_STAT_CLK_DIV_ENA			0x20000000
+#define GERDAC_STAT_CMD_BUSY			0x40000000
+#define GERDAC_STAT_ILL_ACCESS			0x80000000
+
+/* gerdac MMC platform flags */
+#define GERDAC_MMC_WRPROTECT_DISABLE	(1 << 0)
+/*
+ * Some controllers can support a 2-byte block size when the bus width
+ * is configured in 4-bit mode.
+ */
+#define GERDAC_MMC_BLKSZ_2BYTES		(1 << 1)
+/*
+ * Some controllers can support SDIO IRQ signalling.
+ */
+#define GERDAC_MMC_SDIO_IRQ		(1 << 2)
+/*
+ * A GPIO is used for card hotplug detection. We need an extra flag for this,
+ * because 0 is a valid GPIO number too, and requiring users to specify
+ * cd_gpio < 0 to disable GPIO hotplug would break backwards compatibility.
+ */
+#define GERDAC_MMC_USE_GPIO_CD		(1 << 5)
+
+/*
+ * Some controllers doesn't have over 0x100 register.
+ * it is used to checking accessibility of
+ * CTL_SD_CARD_CLK_CTL / CTL_CLK_AND_WAIT_CTL
+ */
+#define GERDAC_MMC_HAVE_HIGH_REG		(1 << 6)
+
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/of.h>
+/*
+ * data for the MMC controller
+ */
+struct gerdac_mmc_data {
+	unsigned int			hclk;
+	unsigned long			capabilities;
+	unsigned long			capabilities2;
+	unsigned long			flags;
+	unsigned long			bus_shift;
+	u32						ocr_mask;	/* available voltages */
+	bool					use_dma;
+	struct device			*dev;
+	void (*set_pwr)(struct platform_device *host, int state);
+	void (*set_clk_div)(struct platform_device *host, int state);
+	/* clock management callbacks */
+	int (*clk_enable)(struct platform_device *pdev, unsigned int *f);
+	void (*clk_disable)(struct platform_device *pdev);
+
+	int						slave_id_tx;
+	int						slave_id_rx;
+};
+
+#endif /* LINUX_MMC_GERDAC_H */
diff -uNr linux-3.14.19/include/linux/mmc/host.h linux-gerda/include/linux/mmc/host.h
--- linux-3.14.19/include/linux/mmc/host.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/mmc/host.h	2017-06-22 09:52:24.451040094 +0900
@@ -311,6 +311,8 @@
 
 	struct mmc_ios		ios;		/* current io bus settings */
 
+	u32				ocr;
+
 	/* group bitfields together to minimize padding */
 	unsigned int		use_spi_crc:1;
 	unsigned int		claimed:1;	/* host exclusively claimed */
diff -uNr linux-3.14.19/include/linux/module.h linux-gerda/include/linux/module.h
--- linux-3.14.19/include/linux/module.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/module.h	2017-06-22 09:52:23.839040112 +0900
@@ -340,6 +340,16 @@
 	unsigned int percpu_size;
 #endif
 
+#ifdef CONFIG_KMC_MODULE_DEBUG
+	void *__kmc_mod_text;
+	void *__kmc_mod_data;
+	void *__kmc_mod_bss;
+	void *__kmc_mod_exit_text;
+	void *__kmc_mod_exit_data;
+	void *__kmc_mod_init_text;
+	void *__kmc_mod_init_data;
+#endif
+
 #ifdef CONFIG_TRACEPOINTS
 	unsigned int num_tracepoints;
 	struct tracepoint * const *tracepoints_ptrs;
diff -uNr linux-3.14.19/include/linux/serial_8250.h linux-gerda/include/linux/serial_8250.h
--- linux-3.14.19/include/linux/serial_8250.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/serial_8250.h	2017-06-22 09:52:24.155040103 +0900
@@ -95,6 +95,9 @@
 
 	struct uart_8250_dma	*dma;
 
+	unsigned int		lsirevision;
+	int			iir;
+	int			lsr;
 	/* 8250 specific callbacks */
 	int			(*dl_read)(struct uart_8250_port *);
 	void			(*dl_write)(struct uart_8250_port *, int);
diff -uNr linux-3.14.19/include/linux/usb/ehci_def.h linux-gerda/include/linux/usb/ehci_def.h
--- linux-3.14.19/include/linux/usb/ehci_def.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/usb/ehci_def.h	2017-06-22 09:52:23.699040116 +0900
@@ -111,8 +111,14 @@
 	/* ASYNCLISTADDR: offset 0x18 */
 	u32		async_next;	/* address of next async queue head */
 
-	u32		reserved1[2];
+#ifdef CONFIG_USB_PANASONIC_HOST	/*_ GerdaC 2015/1/6 _*/
+	u32		reserved1[1];
 
+	/* BURSTSIZE : offset 0x20 		*/
+	u32		burstsize;
+#else   /* CONFIG_USB_PANASONIC_HOST */
+	u32		reserved1[2];
+#endif
 	/* TXFILLTUNING: offset 0x24 */
 	u32		txfill_tuning;	/* TX FIFO Tuning register */
 #define TXFIFO_DEFAULT	(8<<16)		/* FIFO burst threshold 8 */
diff -uNr linux-3.14.19/include/linux/usb/hcd.h linux-gerda/include/linux/usb/hcd.h
--- linux-3.14.19/include/linux/usb/hcd.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/usb/hcd.h	2017-06-22 09:52:23.695040116 +0900
@@ -146,6 +146,9 @@
 
 	unsigned int		irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
+#ifdef CONFIG_USB_PANASONIC_GPIO_FOR_VBUS
+	void __iomem		*gpio_regs;	/* GPIO/io */
+#endif
 	resource_size_t		rsrc_start;	/* memory/io resource start */
 	resource_size_t		rsrc_len;	/* memory/io resource length */
 	unsigned		power_budget;	/* in mA, 0 = no limit */
diff -uNr linux-3.14.19/include/linux/usb.h linux-gerda/include/linux/usb.h
--- linux-3.14.19/include/linux/usb.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/linux/usb.h	2017-06-22 09:52:23.807040113 +0900
@@ -525,6 +525,11 @@
 
 	struct device dev;
 
+/*_ @LINUXHOST:V0203nx[11/03/18] port_ctrlã‚’ç”¨ã„ãŸPort Power OFF æ™‚ã«çŠ¶æ…‹æ¤œå‡ºã§ãã‚‹ã‚ˆã†å¤‰æ›´ _*//*_ GerdaC 2015/1/8 _*/
+#ifdef CONFIG_USB_PANASONIC_PORT_CONTROL
+	struct usb_hub *hubdev;
+#endif /* CONFIG_USB_PANASONIC_PORT_CONTROL */
+
 	struct usb_device_descriptor descriptor;
 	struct usb_host_bos *bos;
 	struct usb_host_config *config;
@@ -581,9 +586,23 @@
 	struct usb3_lpm_parameters u1_params;
 	struct usb3_lpm_parameters u2_params;
 	unsigned lpm_disable_count;
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/8 _*/
+	spinlock_t			oc_ind_lock;
+	struct st_oc_ind*	oc_ind;
+#endif
+
 };
 #define	to_usb_device(d) container_of(d, struct usb_device, dev)
 
+#if defined(CONFIG_USB_PANASONIC_OC_DETECT)	/*_ GerdaC 2015/1/8 _*/
+struct st_oc_ind {
+	struct st_oc_ind*	next;		/*_ ãƒªãƒ³ã‚¯æ§‹é€ ã€‚æœ€å¾Œã®ãƒŽãƒ¼ãƒ‰ã¯next==NULL _*/
+	char				msg[16];
+	int					port;
+	u32					status;
+};
+#endif
+
 static inline struct usb_device *interface_to_usbdev(struct usb_interface *intf)
 {
 	return to_usb_device(intf->dev.parent);
diff -uNr linux-3.14.19/include/uapi/linux/serial_core.h linux-gerda/include/uapi/linux/serial_core.h
--- linux-3.14.19/include/uapi/linux/serial_core.h	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/include/uapi/linux/serial_core.h	2017-06-22 09:52:23.223040130 +0900
@@ -54,7 +54,8 @@
 #define PORT_ALTR_16550_F32 26	/* Altera 16550 UART with 32 FIFOs */
 #define PORT_ALTR_16550_F64 27	/* Altera 16550 UART with 64 FIFOs */
 #define PORT_ALTR_16550_F128 28 /* Altera 16550 UART with 128 FIFOs */
-#define PORT_MAX_8250	28	/* max port ID */
+#define PORT_MN		29	/* Panasonic SOCs internal UART */
+#define PORT_MAX_8250	29	/* max port ID */
 
 /*
  * ARM specific type numbers.  These are not currently guaranteed
@@ -238,4 +239,8 @@
 /* Tilera TILE-Gx UART */
 #define PORT_TILEGX	106
 
+/* Panasonic */
+#define PORT_MN_SIOEXT	107
+#define PORT_MN_STRM	108
+
 #endif /* _UAPILINUX_SERIAL_CORE_H */
diff -uNr linux-3.14.19/kernel/exit.c linux-gerda/kernel/exit.c
--- linux-3.14.19/kernel/exit.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/exit.c	2017-06-22 09:51:59.419040839 +0900
@@ -59,6 +59,14 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#ifdef CONFIG_RT3_LOG_EXIT_TRACE_LOG
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_LOG_EXIT_TRACE_LOG */
+
+#ifdef CONFIG_KMC_PATCH
+#include <linux/kmc.h>
+#endif
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
@@ -708,6 +716,10 @@
 
 	profile_task_exit(tsk);
 
+#ifdef CONFIG_KMC_PATCH
+	__kmc_do_exit__(tsk);
+#endif
+
 	WARN_ON(blk_needs_flush_plug(tsk));
 
 	if (unlikely(in_interrupt()))
@@ -726,6 +738,10 @@
 
 	ptrace_event(PTRACE_EVENT_EXIT, code);
 
+#ifdef CONFIG_RT3_LOG_EXIT_TRACE_LOG
+	rt3_log_process_exit_event(tsk, code);
+#endif /* CONFIG_RT3_LOG_EXIT_TRACE_LOG */
+
 	validate_creds_for_do_exit(tsk);
 
 	/*
diff -uNr linux-3.14.19/kernel/fork.c linux-gerda/kernel/fork.c
--- linux-3.14.19/kernel/fork.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/fork.c	2017-06-22 09:51:59.591040833 +0900
@@ -84,6 +84,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/task.h>
 
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+#include <linux/kmc.h>
+#endif
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -1493,6 +1497,10 @@
 		threadgroup_change_end(current);
 	perf_event_fork(p);
 
+#if defined(CONFIG_KMC_EVENTTRACKER_SUPPORT) || defined(CONFIG_KMC_NO_USER_PATCH)
+	__kmc_make_fork_tbl(p, 0, clone_flags);
+#endif
+
 	trace_task_newtask(p, clone_flags);
 	uprobe_copy_process(p, clone_flags);
 
diff -uNr linux-3.14.19/kernel/irq/handle.c linux-gerda/kernel/irq/handle.c
--- linux-3.14.19/kernel/irq/handle.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/irq/handle.c	2017-06-22 09:51:59.615040833 +0900
@@ -18,6 +18,10 @@
 
 #include <trace/events/irq.h>
 
+#ifdef CONFIG_RT3_LOG_ISR
+#include <asm/rt3.h>
+#endif
+
 #include "internals.h"
 
 /**
@@ -138,10 +142,18 @@
 	do {
 		irqreturn_t res;
 
+#ifdef CONFIG_RT3_LOG_ISR
+		rt3_log_isr_entry_event((0x0000 << 16) | (0xffff & (irq<<2)));
+#endif /* CONFIG_RT3_LOG_ISR */
+
 		trace_irq_handler_entry(irq, action);
 		res = action->handler(irq, action->dev_id);
 		trace_irq_handler_exit(irq, action, res);
 
+#ifdef CONFIG_RT3_LOG_ISR
+		rt3_log_isr_exit_event((0x0000 << 16) | (0xffff & (irq<<2)));
+#endif /* CONFIG_RT3_LOG_ISR */
+
 		if (WARN_ONCE(!irqs_disabled(),"irq %u handler %pF enabled interrupts\n",
 			      irq, action->handler))
 			local_irq_disable();
diff -uNr linux-3.14.19/kernel/module.c linux-gerda/kernel/module.c
--- linux-3.14.19/kernel/module.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/module.c	2017-06-22 09:51:59.591040833 +0900
@@ -67,6 +67,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/module.h>
 
+#ifdef CONFIG_KMC_MODULE_DEBUG
+#include <linux/kmc.h>
+#endif
+
 #ifndef ARCH_SHF_SMALL
 #define ARCH_SHF_SMALL 0
 #endif
@@ -857,6 +861,9 @@
 	/* Final destruction now no one is using it. */
 	if (mod->exit != NULL)
 		mod->exit();
+#ifdef CONFIG_KMC_MODULE_DEBUG
+	__kmc_mod_exit__(mod);
+#endif
 	blocking_notifier_call_chain(&module_notify_list,
 				     MODULE_STATE_GOING, mod);
 	async_synchronize_full();
@@ -2832,6 +2839,9 @@
 			memcpy(dest, (void *)shdr->sh_addr, shdr->sh_size);
 		/* Update sh_addr to point to copy in image. */
 		shdr->sh_addr = (unsigned long)dest;
+#ifdef CONFIG_KMC_MODULE_DEBUG
+		__kmc_chk_mod_sec__(mod, info->secstrings + shdr->sh_name, dest);
+#endif
 		pr_debug("\t0x%lx %s\n",
 			 (long)shdr->sh_addr, info->secstrings + shdr->sh_name);
 	}
@@ -2943,6 +2953,11 @@
 	/* Module has been copied to its final place now: return it. */
 	mod = (void *)info->sechdrs[info->index.mod].sh_addr;
 	kmemleak_load_module(mod, info);
+
+#ifdef CONFIG_KMC_MODULE_DEBUG
+	__kmc_set_mod_sec(mod);
+#endif
+
 	return mod;
 }
 
@@ -3032,7 +3047,15 @@
 	do_mod_ctors(mod);
 	/* Start the module */
 	if (mod->init != NULL)
+#ifdef CONFIG_KMC_MODULE_DEBUG
+	{
+		__kmc_mod_init_brfore__(mod);
+#endif
 		ret = do_one_initcall(mod->init);
+#ifdef CONFIG_KMC_MODULE_DEBUG
+		__kmc_mod_init_after__(mod, ret);
+	}
+#endif
 	if (ret < 0) {
 		/* Init routine failed: abort.  Try to protect us from
                    buggy refcounters. */
diff -uNr linux-3.14.19/kernel/ptrace.c linux-gerda/kernel/ptrace.c
--- linux-3.14.19/kernel/ptrace.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/ptrace.c	2017-06-22 09:51:59.771040828 +0900
@@ -27,6 +27,10 @@
 #include <linux/cn_proc.h>
 #include <linux/compat.h>
 
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_TRACE */
+
 
 static int ptrace_trapping_sleep_fn(void *flags)
 {
@@ -1039,6 +1043,38 @@
 	struct task_struct *child;
 	long ret;
 
+#ifdef CONFIG_RT3_TRACE
+	if (request == 0x52545310) {
+		return rt3_trace(RT3_TRACE_ENABLE, 0, NULL);
+	}
+	if (request == 0x52545311) {
+		return rt3_trace(RT3_TRACE_DISABLE, 0, NULL);
+	}
+	if (request == 0x52545312) {
+		return rt3_trace(RT3_TRACE_USERLOG,
+				     (int)data, NULL);
+	}
+	if (request == 0x52545313) {
+		return rt3_trace(RT3_TRACE_USERLOG_EXT,
+				     (int)addr, (int *)data);
+	}
+	if (request == 0x52545314) {
+		return	rt3_trace(RT3_SYS_TRACE_RT3INFO, 0, (int *)data);
+	}
+	if (request == 0x52545315) {
+		return rt3_trace(RT3_SYS_TRACE_GETISR, (int)addr, (int *)data);
+	}
+	if (request == 0x52545316) {
+		return rt3_trace(RT3_SYS_TRACE_GETBUF, 0, (int *)data);
+	}
+	if (request == 0x52545317) {
+		return rt3_trace(RT3_SYS_TRACE_GETNAME, 0, (int *)data);
+	}
+	if (request == 0x52545318) {
+		return rt3_trace(RT3_SYS_TRACE_INIT, 0, NULL);
+	}
+#endif/*CONFIG_RT3_TRACE*/
+
 	if (request == PTRACE_TRACEME) {
 		ret = ptrace_traceme();
 		if (!ret)
diff -uNr linux-3.14.19/kernel/sched/core.c linux-gerda/kernel/sched/core.c
--- linux-3.14.19/kernel/sched/core.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/sched/core.c	2017-06-22 09:51:59.599040833 +0900
@@ -89,6 +89,14 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/sched.h>
 
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_TRACE */
+
+#ifdef CONFIG_KMC_PATCH
+#include <linux/kmc.h>
+#endif
+
 void start_bandwidth_timer(struct hrtimer *period_timer, ktime_t period)
 {
 	unsigned long delta;
@@ -2268,6 +2276,14 @@
 	spin_release(&rq->lock.dep_map, 1, _THIS_IP_);
 #endif
 
+#ifdef CONFIG_RT3_TRACE
+	rt3_trace_switch_to(prev, next);
+#endif
+
+#ifdef CONFIG_KMC_PATCH
+	__kmc_schedule__(prev, next);
+#endif
+
 	context_tracking_task_switch(prev, next);
 	/* Here we just switch the register state and the stack. */
 	switch_to(prev, next, prev);
@@ -8015,3 +8031,8 @@
 	pr_info("Task dump for CPU %d:\n", cpu);
 	sched_show_task(cpu_curr(cpu));
 }
+
+#ifdef CONFIG_RT3_TRACE
+struct rq *rt3_runqueues = &runqueues;
+volatile int rim_offset_rq_curr = offsetof(struct rq, curr);
+#endif /* CONFIG_RT3_TRACE */
diff -uNr linux-3.14.19/kernel/softirq.c linux-gerda/kernel/softirq.c
--- linux-3.14.19/kernel/softirq.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/softirq.c	2017-06-22 09:51:59.819040827 +0900
@@ -29,6 +29,10 @@
 #define CREATE_TRACE_POINTS
 #include <trace/events/irq.h>
 
+#ifdef CONFIG_RT3_TRACE
+#include <asm/rt3.h>
+#endif /* CONFIG_RT3_TRACE */
+
 /*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
@@ -247,6 +251,11 @@
 	in_hardirq = lockdep_softirq_start();
 
 	cpu = smp_processor_id();
+
+#ifdef CONFIG_RT3_TRACE
+	rt3_log_dispatch_event(current->pid, RT3_TRACE_SOFTIRQ_PID);
+#endif
+
 restart:
 	/* Reset the pending bitmask before enabling irqs */
 	set_softirq_pending(0);
@@ -291,6 +300,10 @@
 		wakeup_softirqd();
 	}
 
+#ifdef CONFIG_RT3_TRACE
+	rt3_log_dispatch_event(RT3_TRACE_SOFTIRQ_PID, current->pid);
+#endif
+
 	lockdep_softirq_end(in_hardirq);
 	account_irq_exit_time(current);
 	__local_bh_enable(SOFTIRQ_OFFSET);
diff -uNr linux-3.14.19/kernel/sys.c linux-gerda/kernel/sys.c
--- linux-3.14.19/kernel/sys.c	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/kernel/sys.c	2017-06-22 09:51:59.671040831 +0900
@@ -61,6 +61,10 @@
 #include <asm/io.h>
 #include <asm/unistd.h>
 
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+#include <linux/kmc.h>
+#endif
+
 #ifndef SET_UNALIGN_CTL
 # define SET_UNALIGN_CTL(a,b)	(-EINVAL)
 #endif
@@ -1899,6 +1903,9 @@
 			return -EFAULT;
 		set_task_comm(me, comm);
 		proc_comm_connector(me);
+#ifdef CONFIG_KMC_EVENTTRACKER_SUPPORT
+		__KMC_LINUX_EVENT_SET_PNAME(me->pid, comm);
+#endif
 		break;
 	case PR_GET_NAME:
 		get_task_comm(comm, me);
diff -uNr linux-3.14.19/lib/Kconfig.debug linux-gerda/lib/Kconfig.debug
--- linux-3.14.19/lib/Kconfig.debug	2014-09-18 01:21:23.000000000 +0900
+++ linux-gerda/lib/Kconfig.debug	2017-06-22 09:52:02.915040735 +0900
@@ -1615,3 +1615,5 @@
 
 source "lib/Kconfig.kgdb"
 
+source "KMC/Kconfig_kmc"
+
